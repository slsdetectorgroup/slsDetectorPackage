---
# detectors: MYTHEN3

################# TEMPLATES #################
TIME_COMMAND:
  infer_action: true
  help: ""
  template: true
  actions:
    GET:
      require_det_id: true
      function: ''
      args:
        - argc: 0
          output: [ OutString(t) ]
        - argc: 1
          arg_types: [ special::time_unit ]
          output: [ "OutString(t , args[0])" ]
    PUT:
      function: ''
      require_det_id: true
      input: [ converted_time ]
      input_types: [ time::ns ]
      args:
        - argc: 1
          arg_types: [ std::string ]

          separate_time_units:
            input: 'args[0]'
            output: [ converted_time, unit ]
          output: [ 'args[0]' ]
        - argc: 2
          arg_types: [ int, special::time_unit ]

          convert_to_time:
            input: [ 'args[0]', 'args[1]' ]
            output: converted_time
          output: [ 'args[0]', 'args[1]' ]

TIME_GET_COMMAND:
  infer_action: true
  help: ""
  template: true
  actions:
    GET:
      require_det_id: true
      function: ''
      args:
        - argc: 0
          output: [ OutString(t) ]
        - argc: 1
          arg_types: [ special::time_unit ]
          output: [ "OutString(t , args[0])" ]

STRING_COMMAND:
  infer_action: true
  help: ""
  template: true
  actions:
    GET:
      require_det_id: true
      function: ''
      argc: 0
      output: [ OutString(t) ]
    PUT:
      function: ''
      output: [ 'args.front()' ]
      input: [ 'args[0]' ]
      input_types: [ std::string ]
      require_det_id: true
      cast_input: [ false ]
      argc: 1

INTEGER_COMMAND_HEX_WIDTH16:
  infer_action: true
  help: ""
  template: true
  actions:
    GET:
      require_det_id: true
      function: ''
      argc: 0
      output: [ "OutStringHex(t, 16)" ]
    PUT:
      function: ''
      output: [ "ToStringHex(args[0], 16)" ]
      input: [ 'args[0]' ]
      input_types: [ uint64_t ]
      require_det_id: true
      cast_input: [ true ]
      argc: 1


INTEGER_COMMAND_HEX:
  template: true
  infer_action: true
  help: ""
  actions:
    GET:
      require_det_id: true
      function: ''
      argc: 0
      output: [ "OutStringHex(t)" ]
    PUT:
      function: ''
      output: [ "args.front()" ]
      input: [ 'args[0]' ]
      input_types: [ uint32_t ]
      require_det_id: true
      cast_input: [ true ]
      argc: 1

INTEGER_COMMAND_VEC_ID_GET:
  template: true
  infer_action: true
  help: ""
  actions:
    GET:
      require_det_id: true
      function: ''
      argc: 0
      output: [ OutString(t) ]
    PUT:
      function: ''
      output: [ 'args.front()' ]
      input: [ 'args[0]' ]
      input_types: [ int ]
      require_det_id: true
      convert_det_id: false
      cast_input: [ true ]
      argc: 1


INTEGER_COMMAND_VEC_ID:
  template: true
  infer_action: true
  help: ""
  actions:
    GET:
      require_det_id: true
      function: ''
      argc: 0
      output: [ OutString(t) ]
    PUT:
      function: ''
      output: [ 'args.front()' ]
      input: [ 'args[0]' ]
      input_types: [ int ]
      require_det_id: true
      cast_input: [ true ]
      argc: 1
INTEGER_COMMAND_SET_NOID_GET_ID:
  template: true
  infer_action: true
  help: ""
  actions:
    GET:
      require_det_id: true
      function: ''
      argc: 0
      output: [ OutString(t) ]
    PUT:
      check_det_id: true
      function: ''
      output: [ 'args.front()' ]
      input: [ 'args[0]' ]
      input_types: [ int ]
      cast_input: [ true ]
      argc: 1

INTEGER_COMMAND_NOID:
  template: true
  infer_action: true
  help: ""
  actions:
    GET:
      check_det_id: true
      function: ''
      argc: 0
      output: [ OutString(t) ]
    PUT:
      check_det_id: true
      function: ''
      output: [ 'args.front()' ]
      input: [ 'args[0]' ]
      input_types: [ int ]
      cast_input: [ true ]
      argc: 1

INTEGER_IND_COMMAND:
  template: true
  infer_action: true
  help: ""
  actions:
    GET:
      # extra variable to store the index
      require_det_id: true
      function: ''
      input: [ 'INDEX' ]
      input_types: [ int ]
      cast_input: [ false ]
      argc: 0
      output: [ OutString(t) ]
    PUT:
      # extra variable to store the index
      function: ''
      output: [ 'args.front()' ]
      input: [ 'INDEX', 'args[0]' ]
      input_types: [ int, int ]
      require_det_id: true
      cast_input: [ false, true ]
      argc: 1

INTEGER_USER_IND_COMMAND:
  template: true
  infer_action: true
  help: ""
  actions:
    GET:
      # extra variable to store the index
      require_det_id: true
      function: ''
      input: [ 'INDEX', 'args[0]' ]
      input_types: [ int, int ]
      cast_input: [ false, true ]
      argc: 1
      output: [ 'args[0]', OutStringHex(t) ]
    PUT:
      # extra variable to store the index
      function: ''
      output: [ 'args[0]', 'args[1]' ]
      input: [ 'INDEX', 'args[0]', 'args[1]' ]
      input_types: [ int, int , int ]
      require_det_id: true
      cast_input: [ false, true, true ]
      argc: 2

EXECUTE_SET_COMMAND_NOID:
  template: true
  infer_action: true
  help: ""
  actions:
    PUT:
      check_det_id: true
      function: ''
      output: [ '"successful"' ]
      argc: 0

EXECUTE_SET_COMMAND_NOID_1ARG:
  template: true
  infer_action: true
  help: ""
  actions:
    PUT:
      check_det_id: true
      function: ''
      input: [ 'args[0]' ]
      input_types: [ std::string ]
      cast_input: [ false ]
      output: [ 'args.front()' ]
      argc: 1

GET_COMMAND:
  template: true
  infer_action: true
  help: ""
  actions:
    GET:
      require_det_id: true
      function: ''
      argc: 0
      output: [ OutString(t) ]

GET_COMMAND_NOID:
  template: true
  infer_action: true
  help: ""
  actions:
    GET:
      function: ''
      argc: 0
      output: [ ToString(t) ]

GET_IND_COMMAND:
  template: true
  infer_action: true
  help: ""
  actions:
    GET:
      require_det_id: true
      function: ''
      argc: 0
      output: [ OutString(t), '" Â°C"' ]
      input: [ 'VAL' ]
      input_types: [ int ]
      cast_input: [ false ]





CTB_SINGLE_DACNAME:
  template: true
  infer_action: true
  actions:
    GET:
      extra_variables:
        - name: index
          type: defs::dacIndex
          value: 0

      check_det_id: true
      exceptions:
        - condition: 'det->getDetectorType().squash() != defs::CHIPTESTBOARD'
          message: 'cmd + " only allowed for CTB."'
      argc: 1
      input: [ "static_cast<defs::dacIndex>(StringTo<int>(args[0]) + index)" ]
      input_types: [ defs::dacIndex ]
      output: [ 'args[0]',"' '", 't' ]

    PUT:
      extra_variables:
        - name: index
          type: defs::dacIndex
          value: 0

      check_det_id: true
      exceptions:
        - condition: 'det->getDetectorType().squash() != defs::CHIPTESTBOARD'
          message: 'cmd + " only allowed for CTB."'
      argc: 2
      input: [ "static_cast<defs::dacIndex>(StringTo<int>(args[0]) + index)","args[1]" ]
      input_types: [ defs::dacIndex , std::string ]
      output: [ 'ToString(args)' ]


CTB_GET_DACINDEX:
  template: true
  infer_action: true
  actions:
    GET:
      extra_variables:
        - name: index
          type: defs::dacIndex
          value: 0

      check_det_id: true
      exceptions:
        - condition: 'det->getDetectorType().squash() != defs::CHIPTESTBOARD'
          message: 'cmd + " only allowed for CTB."'
      argc: 1
      input: [ 'args[0]' ]
      input_types: [ std::string ]
      output: [ 'ToString(static_cast<int>(t) - index)' ]

CTB_SINGLE_NAME:
  template: true
  infer_action: true
  actions:
    GET:
      check_det_id: true
      exceptions:
        - condition: 'det->getDetectorType().squash() != defs::CHIPTESTBOARD'
          message: 'cmd + " only allowed for CTB."'
      argc: 1
      input: [ "args[0]" ]
      cast_input: [ true ]
      input_types: [ int ]
      output: [ 'args[0]',"' '", 't' ]
    PUT:
      check_det_id: true
      exceptions:
        - condition: 'det->getDetectorType().squash() != defs::CHIPTESTBOARD'
          message: 'cmd + " only allowed for CTB."'
      argc: 2
      cast_input: [ true, false ]
      input: [ "args[0]","args[1]" ]
      input_types: [ int , std::string ]
      output: [ 'ToString(args)' ]

CTB_GET_INDEX:
  template: true
  infer_action: true
  actions:
    GET:
      check_det_id: true
      exceptions:
        - condition: 'det->getDetectorType().squash() != defs::CHIPTESTBOARD'
          message: 'cmd + " only allowed for CTB."'
      argc: 1
      input: [ 'args[0]' ]
      input_types: [ std::string ]
      output: [ 'static_cast<int>(t)' ]


CTB_NAMED_LIST:
  template: true
  infer_action: true
  actions:
    GET:
      check_det_id: true
      exceptions:
        - condition: 'cmd != "daclist" && det->getDetectorType().squash() != defs::CHIPTESTBOARD'
          message: 'cmd + " only allowed for CTB."'
      argc: 0
      output: [ 'ToString(t)' ]
    PUT:
      check_det_id: true
      exceptions:
        - condition: 'cmd != "daclist" && det->getDetectorType().squash() != defs::CHIPTESTBOARD'
          message: 'cmd + " only allowed for CTB."'
        - condition: 'cmd == "daclist" && det->getDetectorType().squash() != defs::CHIPTESTBOARD'
          message: '"This detector already has fixed dac names. Cannot change them."'
      input: [ 'args' ]
      argc: -1 # unknown number of args
      input_types: [ std::string ]
      output: [ 'ToString(args)' ]

################# COMMANDS ##################################
################# CTB_NAMED_LIST #############################

daclist:
    inherit_actions: CTB_NAMED_LIST
    help: "[dacname1 dacname2 .. dacname18] \n\t\t[ChipTestBoard] Set the list of dac names for this detector.\n\t\t[All] Gets the list of dac names for every dac for this detector."
    actions:
      GET:
        function: getDacNames
      PUT:
        function: setDacNames
adclist:
  inherit_actions: CTB_NAMED_LIST
  help: "[adcname1 adcname2 .. adcname32] \n\t\t[ChipTestBoard] Set the list of adc names for this board."
  actions:
      GET:
          function: getAdcNames
      PUT:
          function: setAdcNames
signallist:
    inherit_actions: CTB_NAMED_LIST
    help: "[signalname1 signalname2 .. signalname63] \n\t\t[ChipTestBoard] Set the list of signal names for this board."
    actions:
      GET:
        function: getSignalNames
      PUT:
        function: setSignalNames
voltagelist:
    inherit_actions: CTB_NAMED_LIST
    help: "[voltagename1 voltagename2 .. voltagename4] \n\t\t[ChipTestBoard] Set the list of voltage names for this board."
    actions:
      GET:
        function: getVoltageNames
      PUT:
        function: setVoltageNames
slowadclist:
    inherit_actions: CTB_NAMED_LIST
    help: "[slowadcname1 slowadcname2 .. slowadcname7] \n\t\t[ChipTestBoard] Set the list of slowadc names for this board."
    actions:
      GET:
        function: getSlowADCNames
      PUT:
        function: setSlowADCNames



################# CTB_GET_INDEX #############################

adcindex:
  inherit_actions: CTB_GET_INDEX
  help: "[name] \n\t\t[ChipTestBoard] Get the adc index for the given name."
  actions:
    GET:
      function: getAdcIndex
signalindex:
  inherit_actions: CTB_GET_INDEX
  help: "[name] \n\t\t[ChipTestBoard] Get the signal index for the given name."
  actions:
    GET:
      function: getSignalIndex

################# CTB_SINGLE_NAME ###########################
adcname:
  inherit_actions: CTB_SINGLE_NAME
  help: "[0-31][name] \n\t\t[ChipTestBoard] Set the adc at the given position to the given name."
  actions:
    GET:
      function: getAdcName
    PUT:
      function: setAdcName
signalname:
  inherit_actions: CTB_SINGLE_NAME
  help: "[0-63][name] \n\t\t[ChipTestBoard] Set the signal at the given position to the given name."
  actions:
    GET:
      function: getSignalName
    PUT:
      function: setSignalName


################# CTB_GET_DACINDEX ##########################
dacindex:
  inherit_actions: CTB_GET_DACINDEX
  help: "[name] \n\t\t[ChipTestBoard] Get the dac index for the given name."
  actions:
    GET:
      function: getDacIndex
      extra_variables:
        - name: index
          type: defs::dacIndex
          value: defs::DAC_0

voltageindex:
  inherit_actions: CTB_GET_DACINDEX
  help: "[name] \n\t\t[ChipTestBoard] Get the voltage index for the given name."
  actions:
    GET:
      function: getVoltageIndex
      extra_variables:
        - name: index
          type: defs::dacIndex
          value: defs::V_POWER_A

slowadcindex:
  inherit_actions: CTB_GET_DACINDEX
  help: "[name] \n\t\t[ChipTestBoard] Get the slowadc index for the given name."
  actions:
    GET:
      function: getSlowADCIndex
      extra_variables:
        - name: index
          type: defs::dacIndex
          value: defs::SLOW_ADC0


################# CTB_SINGLE_DACNAME ########################
dacname:
  inherit_actions: CTB_SINGLE_DACNAME
  help: "[0-17][name] \n\t\t[ChipTestBoard] Set the dac at the given position to the given name."
  actions:
    GET:
      function: getDacName
      extra_variables:
        - name: index
          type: defs::dacIndex
          value: defs::DAC_0
    PUT:
      function: setDacName
      extra_variables:
        - name: index
          type: defs::dacIndex
          value: defs::DAC_0

voltagename:
  inherit_actions: CTB_SINGLE_DACNAME
  help: "[0-4][name] \n\t\t[ChipTestBoard] Set the voltage at the given position to the given name."
  actions:
    GET:
      function: getVoltageName
      extra_variables:
        - name: index
          type: defs::dacIndex
          value: defs::V_POWER_A
    PUT:
      function: setVoltageName
      extra_variables:
        - name: index
          type: defs::dacIndex
          value: defs::V_POWER_A

slowadcname:
  inherit_actions: CTB_SINGLE_DACNAME
  help: "[0-7][name] \n\t\t[ChipTestBoard] Set the slowadc at the given position to the given name."
  actions:
    GET:
      function: getSlowADCName
      extra_variables:
        - name: index
          type: defs::dacIndex
          value: defs::SLOW_ADC0
    PUT:
      function: setSlowADCName
      extra_variables:
        - name: index
          type: defs::dacIndex
          value: defs::SLOW_ADC0

################# CTB_VALUES ################################
voltagevalues:
  help: "[name] \n\t\t[ChipTestBoard] Get values of all voltages."
  actions:
    GET:
      argc: 0
      ctb_output_list:
        GETFCNLIST: getVoltageList
        GETFCNNAME: getVoltageNames
        GETFCN: getVoltage
        suffix: "mV"
        printable_name: "*name_it++"

slowadcvalues:
  help: "[name] \n\t\t[ChipTestBoard] Get values of all slow adcs."
  actions:
    GET:
      argc: 0
      ctb_output_list:
        GETFCNLIST: getSlowADCList
        GETFCNNAME: getSlowADCNames
        GETFCN: getSlowADC
        suffix: "mV"
        printable_name: "*name_it++"





################# GET_IND_COMMAND ############################
temp_adc:
  inherit_actions: GET_IND_COMMAND
  help: "[n_value]\n\t[Jungfrau][Moench][Gotthard] ADC Temperature"
  actions:
    GET:
      function: getTemperature
      input: [ 'slsDetectorDefs::TEMPERATURE_ADC' ]
temp_fpga:
  inherit_actions: GET_IND_COMMAND
  help: "[n_value]\n\t[Eiger][Jungfrau][Moench][Gotthard][Mythen3][Gotthard2] FPGA Temperature"
  actions:
    GET:
      function: getTemperature
      input: [ 'slsDetectorDefs::TEMPERATURE_FPGA' ]
temp_fpgaext:
  inherit_actions: GET_IND_COMMAND
  help: "[n_value]\n\t[Eiger]Temperature close to the FPGA"
  actions:
    GET:
      function: getTemperature
      input: [ 'slsDetectorDefs::TEMPERATURE_FPGAEXT' ]
temp_10ge:
  inherit_actions: GET_IND_COMMAND
  help: "[n_value]\n\t[Eiger]Temperature close to the 10GbE"
  actions:
    GET:
      function: getTemperature
      input: [ 'slsDetectorDefs::TEMPERATURE_10GE' ]
temp_dcdc:
  inherit_actions: GET_IND_COMMAND
  help: "[n_value]\n\t[Eiger]Temperature close to the dc dc converter"
  actions:
    GET:
      function: getTemperature
      input: [ 'slsDetectorDefs::TEMPERATURE_DCDC' ]
temp_sodl:
  inherit_actions: GET_IND_COMMAND
  help: "[n_value]\n\t[Eiger]Temperature close to the left so-dimm memory"
  actions:
    GET:
      function: getTemperature
      input: [ 'slsDetectorDefs::TEMPERATURE_SODL' ]
temp_sodr:
  inherit_actions: GET_IND_COMMAND
  help: "[n_value]\n\t[Eiger]Temperature close to the right so-dimm memory"
  actions:
    GET:
      function: getTemperature
      input: [ 'slsDetectorDefs::TEMPERATURE_SODR' ]
temp_fpgafl:
  inherit_actions: GET_IND_COMMAND
  help: "[n_value]\n\t[Eiger]Temperature of the left front end board fpga."
  actions:
    GET:
      function: getTemperature
      input: [ 'slsDetectorDefs::TEMPERATURE_FPGA2' ]
temp_fpgafr:
  inherit_actions: GET_IND_COMMAND
  help: "[n_value]\n\t[Eiger]Temperature of the left front end board fpga."
  actions:
    GET:
      function: getTemperature
      input: [ 'slsDetectorDefs::TEMPERATURE_FPGA3' ]
temp_slowadc:
  inherit_actions: GET_IND_COMMAND
  help: "[n_value]\n\t[Ctb]Temperature of the slow adc"
  actions:
    GET:
      function: getTemperature
      input: [ 'slsDetectorDefs::SLOW_ADC_TEMP' ]

vm_a:
  inherit_actions: GET_IND_COMMAND
  help: "\n\t[Ctb] Measured voltage of power supply a in mV."
  actions:
    GET:
      function: getMeasuredVoltage
      input: [ 'defs::V_POWER_A' ]
vm_b:
  inherit_actions: GET_IND_COMMAND
  help: "\n\t[Ctb] Measured voltage of power supply b in mV."
  actions:
    GET:
      function: getMeasuredVoltage
      input: [ 'defs::V_POWER_B' ]
vm_c:
  inherit_actions: GET_IND_COMMAND
  help: "\n\t[Ctb] Measured voltage of power supply c in mV."
  actions:
    GET:
      function: getMeasuredVoltage
      input: [ 'defs::V_POWER_C' ]
vm_d:
  inherit_actions: GET_IND_COMMAND
  help: "\n\t[Ctb] Measured voltage of power supply d in mV."
  actions:
    GET:
      function: getMeasuredVoltage
      input: [ 'defs::V_POWER_D' ]
vm_io:
  inherit_actions: GET_IND_COMMAND
  help: "\n\t[Ctb] Measured voltage of power supply io in mV."
  actions:
    GET:
      function: getMeasuredVoltage
      input: [ 'defs::V_POWER_IO' ]
im_a:
  inherit_actions: GET_IND_COMMAND
  help: "\n\t[Ctb] Measured current of power supply a in mA."
  actions:
    GET:
      function: getMeasuredCurrent
      input: [ 'defs::I_POWER_A' ]
im_b:
  inherit_actions: GET_IND_COMMAND
  help: "\n\t[Ctb] Measured current of power supply b in mA."
  actions:
    GET:
      function: getMeasuredCurrent
      input: [ 'defs::I_POWER_B' ]
im_c:
  inherit_actions: GET_IND_COMMAND
  help: "\n\t[Ctb] Measured current of power supply c in mA."
  actions:
    GET:
      function: getMeasuredCurrent
      input: [ 'defs::I_POWER_C' ]
im_d:
  inherit_actions: GET_IND_COMMAND
  help: "\n\t[Ctb] Measured current of power supply d in mA."
  actions:
    GET:
      function: getMeasuredCurrent
      input: [ 'defs::I_POWER_D' ]
im_io:
  inherit_actions: GET_IND_COMMAND
  help: "\n\t[Ctb] Measured current of power supply io in mA."
  actions:
    GET:
      function: getMeasuredCurrent
      input: [ 'defs::I_POWER_IO' ]

################# GET_COMMAND_HEX ############################
serialnumber:
  inherit_actions: GET_COMMAND
  help: "\n\t[Jungfrau][Moench][Gotthard][Mythen3][Gotthard2][CTB]\nSerial number of detector."
  actions:
    GET:
      function: getSerialNumber
      output: [ "OutStringHex(t)" ]

################# GET_COMMAND_NOID ###########################
nmod:
  inherit_actions: GET_COMMAND_NOID
  help: "\n\tNumber of modules in shared memory."
  actions:
    GET:
      function: size
settingslist:
  inherit_actions: GET_COMMAND_NOID
  help: "\n\tList of settings implemented for this detector."
  actions:
    GET:
      function: getSettingsList
drlist:
  inherit_actions: GET_COMMAND_NOID
  help: "\n\tGets the list of dynamic ranges for this detector."
  actions:
    GET:
      function: getDynamicRangeList
timinglist:
  inherit_actions: GET_COMMAND_NOID
  help: "\n\tGets the list of timing modes for this detector."
  actions:
    GET:
      function: getTimingModeList
readoutspeedlist:
  inherit_actions: GET_COMMAND_NOID
  help: "\n\tList of readout speed levels implemented for this detector."
  actions:
    GET:
      function: getReadoutSpeedList
templist:
  inherit_actions: GET_COMMAND_NOID
  help: "\n\tList of temperature commands implemented for this detector."
  actions:
    GET:
      function: getTemperatureList



################# GET_COMMAND ################################
rx_framescaught:
  inherit_actions: GET_COMMAND
  help: "\n\tNumber of frames caught by each port in receiver."
  actions:
    GET:
      function: getFramesCaught

detectorserverversion:
  inherit_actions: GET_COMMAND
  help: "\n\tOn-board detector server software version"
  actions:
    GET:
      function: getDetectorServerVersion
hardwareversion:
  inherit_actions: GET_COMMAND
  help: "\n\t[Jungfrau][Gotthard2][Myhten3][Gotthard][Ctb][Moench] Hardware version of detector. \n\t[Eiger] Hardware version of front FPGA on detector."
  actions:
    GET:
      function: getHardwareVersion
kernelversion:
  inherit_actions: GET_COMMAND
  help: "\n\tGet kernel version on the detector including time and date."
  actions:
    GET:
      function: getKernelVersion
rx_version:
  inherit_actions: GET_COMMAND
  help: "\n\tReceiver version"
  actions:
    GET:
      function: getReceiverVersion
moduleid:
  inherit_actions: GET_COMMAND
  help: "\n\t[Gotthard2][Eiger][Mythen3][Jungfrau][Moench] 16 bit value (ideally unique) that is streamed out in the UDP header of the detector. Picked up from a file on the module."
  actions:
    GET:
      function: getModuleId
type:
  inherit_actions: GET_COMMAND
  help: "\n\tReturns detector type. Can be Eiger, Jungfrau, Gotthard, Moench, Mythen3, Gotthard2, ChipTestBoard"
  actions:
    GET:
      function: getDetectorType

framesl:
  inherit_actions: GET_COMMAND
  help: "\n\t[Gotthard][Jungfrau][Moench][Mythen3][Gotthard2][CTB] Number of frames left in acquisition. \n\t[Gotthard2] only in continuous auto mode."
  actions:
    GET:
      function: getNumberOfFramesLeft
triggersl:
  inherit_actions: GET_COMMAND
  help: "\n\t[Gotthard][Jungfrau][Moench][Mythen3][Gotthard2][CTB] Number of triggers left in acquisition. Only when external trigger used."
  actions:
    GET:
      function: getNumberOfTriggersLeft
maxadcphaseshift:
  inherit_actions: GET_COMMAND
  help: "\n\t[Jungfrau][Moench][CTB] Absolute maximum Phase shift of ADC clock."
  actions:
    GET:
      function: getMaxADCPhaseShift
maxdbitphaseshift:
  inherit_actions: GET_COMMAND
  help: "\n\t[CTB][Jungfrau] Absolute maximum Phase shift of of the clock to latch digital bits."
  actions:
    GET:
      function: getMaxDBITPhaseShift
rx_missingpackets:
  inherit_actions: GET_COMMAND
  help: "\n\tNumber of missing packets for receiver. If negative, they are packets in excess."
  actions:
    GET:
      function: getNumMissingPackets
rx_frameindex:
  inherit_actions: GET_COMMAND
  help: "\n\tCurrent frame index received for receiver during acquisition."
  actions:
    GET:
      function: getRxCurrentFrameIndex
scanerrmsg:
  inherit_actions: GET_COMMAND
  help: "\n\tGets Scan error message if scan ended in error for non blocking acquisitions."
  actions:
    GET:
      function: getScanErrorMessage
udp_numdst:
  inherit_actions: GET_COMMAND
  help: "\n\t[Jungfrau][Moench][Eiger][Mythen3][Gotthard2] One can enter upto 32 (64 for Mythen3) destinations that the detector will stream images out in a round robin fashion. This is get only command. Default: 1"
  actions:
    GET:
      function: getNumberofUDPDestinations
rx_printconfig:
  inherit_actions: GET_COMMAND
  help: "\n\tPrints the receiver configuration."
  actions:
    GET:
      function: printRxConfiguration
rx_realudpsocksize:
  inherit_actions: GET_COMMAND
  help: "\n\tActual udp socket buffer size. Double the size of rx_udpsocksize due to kernel bookkeeping."
  actions:
    GET:
      function: getRxRealUDPSocketBufferSize
rx_lastclient:
  inherit_actions: GET_COMMAND
  help: "\n\tClient IP Address that last communicated with the receiver."
  actions:
    GET:
      function: getRxLastClientIP
burstsl:
  inherit_actions: GET_COMMAND
  help: "\n\t[Gotthard2] Number of bursts left in acquisition. Only in burst auto mode."
  actions:
    GET:
      function: getNumberOfBurstsLeft
rx_threads:
  inherit_actions: GET_COMMAND
  help: "\n\tGet kernel thread ids from the receiver in order of [parent, tcp, listener 0, processor 0, streamer 0, listener 1, processor 1, streamer 1, arping]. If no streamer yet or there is no second interface, it gives 0 in its place."
  actions:
    GET:
      function: getRxThreadIds
chipversion:
  inherit_actions: GET_COMMAND
  help: "\n\t[Jungfrau] Returns chip version. Can be 1.0 or 1.1"
  actions:
    GET:
      function: getChipVersion
syncclk:
  inherit_actions: GET_COMMAND
  help: "[n_clk in MHz]\n\t[Ctb] Sync clock in MHz."
  actions:
    GET:
      function: getSYNCClock
patfname:
  inherit_actions: GET_COMMAND
  help: "\n\t[Ctb][Mythen3] Gets the pattern file name including path of the last pattern uploaded. Returns an empty if nothing was uploaded or via a server default file"
  actions:
    GET:
      function: getPatterFileName
lastclient:
  inherit_actions: GET_COMMAND
  help: "\n\tClient IP Address that last communicated with the detector."
  actions:
    GET:
      function: getLastClientIP
framecounter:
  inherit_actions: GET_COMMAND
  help: "\n\t[Jungfrau][Moench][Mythen3][Gotthard2][CTB] Number of frames from start run control.\n\t[Gotthard2] only in continuous mode."
  actions:
    GET:
      function: getNumberOfFramesFromStart


################# EXECUTE_SET_COMMAND_NOID_1ARG ##############
config:
  inherit_actions: EXECUTE_SET_COMMAND_NOID_1ARG
  help: "\n\tFrees shared memory before loading configuration file. Set up once."
  actions:
    PUT:
      function: loadConfig
parameters:
  inherit_actions: EXECUTE_SET_COMMAND_NOID_1ARG
  help: "\n\tSets detector measurement parameters to those contained in fname. Set up per measurement."
  actions:
    PUT:
      function: loadParameters
savepattern:
  inherit_actions: EXECUTE_SET_COMMAND_NOID_1ARG
  help: "\n\t[Ctb][Mythen3] Saves pattern to file (ascii). \n\t[Ctb] Also executes pattern."
  actions:
    PUT:
      function: savePattern

################# EXECUTE_SET_COMMAND ########################
start:
  inherit_actions: EXECUTE_SET_COMMAND_NOID
  help: "\n\tStarts detector acquisition. Status changes to RUNNING or WAITING and automatically returns to idle at the end of acquisition. If the acquisition was abruptly stopped, some detectors come back to STOPPED."
  actions:
    PUT:
      require_det_id: true
      function: startDetector

defaultpattern:
  inherit_actions: EXECUTE_SET_COMMAND_NOID
  help: "\n\t[Mythen3] Loads and runs default pattern in pattern generator. It is to go back to initial settings."
  actions:
    PUT:
      require_det_id: true
      function: loadDefaultPattern
resetfpga:
  inherit_actions: EXECUTE_SET_COMMAND_NOID
  help: "\n\t[Jungfrau][Moench][Ctb] Reset FPGA."
  actions:
    PUT:
      require_det_id: true
      function: resetFPGA
firmwaretest:
  inherit_actions: EXECUTE_SET_COMMAND_NOID
  help: "\n\t[Jungfrau][Moench][Gotthard][Mythen3][Gotthard2][Ctb] Firmware test, ie. reads a read fixed pattern from a register."
  actions:
    PUT:
      require_det_id: true
      function: executeFirmwareTest
bustest:
  inherit_actions: EXECUTE_SET_COMMAND_NOID
  help: "\n\t[Jungfrau][Moench][Gotthard][Mythen3][Gotthard2][Ctb] Bus test, ie. Writes different values in a R/W register and confirms the writes to check bus.\n\tAdvanced User function!"
  actions:
    PUT:
      require_det_id: true
      function: executeBusTest
rebootcontroller:
  inherit_actions: EXECUTE_SET_COMMAND_NOID
  help: "\n\t[Jungfrau][Moench][Ctb][Gotthard][Mythen3][Gotthard2] Reboot controller of detector."
  actions:
    PUT:
      require_det_id: true
      function: rebootController
patternstart:
  inherit_actions: EXECUTE_SET_COMMAND_NOID
  help: "\n\t[Mythen3] Starts Pattern"
  actions:
    PUT:
      require_det_id: true
      function: startPattern
stop:
  inherit_actions: EXECUTE_SET_COMMAND_NOID
  help: "\n\tAbort detector acquisition. Status changes to IDLE or STOPPED. Goes to stop server."
  actions:
    PUT:
      require_det_id: true
      function: stopDetector
udp_cleardst:
  inherit_actions: EXECUTE_SET_COMMAND_NOID
  help: "\n\tClears udp destination details on the detector."
  actions:
    PUT:
      require_det_id: true
      function: clearUDPDestinations
udp_reconfigure:
  inherit_actions: EXECUTE_SET_COMMAND_NOID
  help: "\n\tReconfigures Detector with UDP destination. More for debugging as the configuration is done automatically when the detector has sufficient UDP details."
  actions:
    PUT:
      require_det_id: true
      function: reconfigureUDPDestination
udp_validate:
  inherit_actions: EXECUTE_SET_COMMAND_NOID
  help: "\n\tValidates that UDP configuration in the detector is valid. If not configured, it will throw with error message requesting missing udp information."
  actions:
    PUT:
      require_det_id: true
      function: validateUDPConfiguration
clearroi:
  inherit_actions: EXECUTE_SET_COMMAND_NOID
  help: "[Gotthard] Resets Region of interest in detector. All channels enabled. Default is all channels enabled."
  actions:
    PUT:
      require_det_id: true
      function: clearROI


################# EXECUTE_SET_COMMAND_NOID #######################
clearbusy:
  inherit_actions: EXECUTE_SET_COMMAND_NOID
  help: "\n\tIf acquisition aborted during acquire command, use this to clear acquiring flag in shared memory before starting next acquisition"
  actions:
    PUT:
      function: clearAcquiringFlag

rx_start:
  inherit_actions: EXECUTE_SET_COMMAND_NOID
  help: "\n\tStarts receiver listener for detector data packets and create a data file (if file write enabled)."
  actions:
    PUT:
      function: startReceiver
rx_stop:
  inherit_actions: EXECUTE_SET_COMMAND_NOID
  help: "\n\tStops receiver listener for detector data packets and closes current data file (if file write enabled)."
  actions:
    PUT:
      function: stopReceiver
readout:
  inherit_actions: EXECUTE_SET_COMMAND_NOID
  help: "\n\t[Mythen3] Starts detector readout. Status changes to TRANSMITTING and automatically returns to idle at the end of readout."
  actions:
    PUT:
      function: startDetectorReadout
rx_clearroi:
  inherit_actions: EXECUTE_SET_COMMAND_NOID
  help: "Resets Region of interest in receiver. Default is all channels/pixels enabled."
  actions:
    PUT:
      function: clearRxROI



################# INTEGER_USER_IND_COMMAND ###################
vchip_comp_fe:
  inherit_actions: INTEGER_USER_IND_COMMAND
  help: "[chip index 0-10, -1 for all][10 bit hex value] \n\t[Gotthard2] On chip Dac for comparator current of analogue front end."
  actions:
    GET:
      function: getOnChipDAC
      input: [ 'defs::VB_COMP_FE',  'args[0]' ]
    PUT:
      function: setOnChipDAC
      input: [ 'defs::VB_COMP_FE', 'args[0]', 'args[1]' ]

vchip_opa_1st:
  inherit_actions: INTEGER_USER_IND_COMMAND
  help: "[chip index 0-10, -1 for all][10 bit hex value] \n\t[Gotthard2] On chip Dac for opa current for driving the other DACs in chip."
  actions:
    GET:
      function: getOnChipDAC
      input: [ 'defs::VB_OPA_1ST',  'args[0]' ]
    PUT:
      function: setOnChipDAC
      input: [ 'defs::VB_OPA_1ST', 'args[0]', 'args[1]' ]

vchip_opa_fd:
  inherit_actions: INTEGER_USER_IND_COMMAND
  help: "[chip index 0-10, -1 for all][10 bit hex value] \n\t[Gotthard2] On chip Dac current for CDS opa stage."
  actions:
    GET:
      function: getOnChipDAC
      input: [ 'defs::VB_OPA_FD',  'args[0]' ]
    PUT:
      function: setOnChipDAC
      input: [ 'defs::VB_OPA_FD', 'args[0]', 'args[1]' ]

vchip_comp_adc:
  inherit_actions: INTEGER_USER_IND_COMMAND
  help: "[chip index 0-10, -1 for all][10 bit hex value] \n\t[Gotthard2] On chip Dac for comparator current of ADC."
  actions:
    GET:
      function: getOnChipDAC
      input: [ 'defs::VB_COMP_ADC',  'args[0]' ]
    PUT:
      function: setOnChipDAC
      input: [ 'defs::VB_COMP_ADC', 'args[0]', 'args[1]' ]


vchip_ref_comp_fe:
  inherit_actions: INTEGER_USER_IND_COMMAND
  help: "[chip index 0-10, -1 for all][10 bit hex value] \n\t[Gotthard2] On chip Dac for reference voltage of the comparator of analogue front end."
  actions:
    GET:
      function: getOnChipDAC
      input: [ 'defs::VREF_COMP_FE',  'args[0]' ]
    PUT:
      function: setOnChipDAC
      input: [ 'defs::VREF_COMP_FE', 'args[0]', 'args[1]' ]

vchip_cs:
  inherit_actions: INTEGER_USER_IND_COMMAND
  help: "[chip index 0-10, -1 for all][10 bit hex value] \n\t[Gotthard2] On chip Dac for current injection into preamplifier."
  actions:
    GET:
      function: getOnChipDAC
      input: [ 'defs::VB_CS',  'args[0]' ]
    PUT:
      function: setOnChipDAC
      input: [ 'defs::VB_CS', 'args[0]', 'args[1]' ]


################# INTEGER_IND_COMMAND #######################
v_limit:
  inherit_actions: INTEGER_IND_COMMAND
  help: "[n_value]\n\t[Ctb] Soft limit for power supplies (ctb only) and DACS in mV."
  actions:
    GET:
      function: getVoltage
      input: [ 'defs::V_LIMIT' ]
    PUT:
      function: setVoltage
      input: [ 'defs::V_LIMIT', 'args[0]' ]


v_a:
  inherit_actions: INTEGER_IND_COMMAND
  help: "[n_value]\n\t[Ctb] Voltage supply a in mV."
  actions:
    GET:
      function: getVoltage
      input: [ 'defs::V_POWER_A' ]
    PUT:
      function: setVoltage
      input: [ 'defs::V_POWER_A', 'args[0]' ]
v_b:
  inherit_actions: INTEGER_IND_COMMAND
  help: "[n_value]\n\t[Ctb] Voltage supply b in mV."
  actions:
    GET:
      function: getVoltage
      input: [ 'defs::V_POWER_B' ]
    PUT:
      function: setVoltage
      input: [ 'defs::V_POWER_B', 'args[0]' ]
v_c:
  inherit_actions: INTEGER_IND_COMMAND
  help: "[n_value]\n\t[Ctb] Voltage supply c in mV."
  actions:
    GET:
      function: getVoltage
      input: [ 'defs::V_POWER_C' ]
    PUT:
      function: setVoltage
      input: [ 'defs::V_POWER_C', 'args[0]' ]
v_d:
  inherit_actions: INTEGER_IND_COMMAND
  help: "[n_value]\n\t[Ctb] Voltage supply d in mV."
  actions:
    GET:
      function: getVoltage
      input: [ 'defs::V_POWER_D' ]
    PUT:
      function: setVoltage
      input: [ 'defs::V_POWER_D', 'args[0]' ]
v_io:
  inherit_actions: INTEGER_IND_COMMAND
  help: "[n_value]\n\t[Ctb] Voltage supply io in mV. Minimum 1200 mV. Must be the first power regulator to be set after fpga reset (on-board detector server start up)."
  actions:
    GET:
      function: getVoltage
      input: [ 'defs::V_POWER_IO' ]
    PUT:
      function: setVoltage
      input: [ 'defs::V_POWER_IO', 'args[0]' ]
v_chip:
  inherit_actions: INTEGER_IND_COMMAND
  help: "[n_value]\n\t[Ctb] Voltage supply chip in mV. Do not use it unless you are completely sure you will not fry the board."
  actions:
    GET:
      function: getVoltage
      input: [ 'defs::V_POWER_CHIP' ]
    PUT:
      function: setVoltage
      input: [ 'defs::V_POWER_CHIP', 'args[0]' ]

################# INTEGER_COMMAND_NOID #######################
fmaster:
  inherit_actions: INTEGER_COMMAND_NOID
  help: "[0, 1]\n\tEnable or disable receiver master file. Default is 1."
  actions:
    GET:
      function: getMasterFileWrite
    PUT:
      function: setMasterFileWrite
      input_types: [ bool ]


################# INTEGER_COMMAND_SET_NOID_GET_ID ############
sync:
  inherit_actions: INTEGER_COMMAND_SET_NOID_GET_ID
  help: "[0, 1]\n\t[Jungfrau][Moench] Enables or disables synchronization between modules."
  actions:
    GET:
      function: getSynchronization
    PUT:
      function: setSynchronization
      input_types: [ bool ]


frames:
  inherit_actions: INTEGER_COMMAND_SET_NOID_GET_ID
  help: "[n_frames]\n\tNumber of frames per acquisition. In trigger mode, number of frames per trigger. \n\tCannot be set in modular level. \n\tIn scan mode, number of frames is set to number of steps.\n\t[Gotthard2] Burst mode has a maximum of 2720 frames."
  actions:
    GET:
      function: getNumberOfFrames
    PUT:
      function: setNumberOfFrames
      input_types: [ int64_t ]

triggers:
  inherit_actions: INTEGER_COMMAND_SET_NOID_GET_ID
  help: "[n_triggers]\n\tNumber of triggers per aquire. Set timing mode to use triggers."
  actions:
    GET:
      function: getNumberOfTriggers
    PUT:
      function: setNumberOfTriggers
      input_types: [ int64_t ]
dr:
  inherit_actions: INTEGER_COMMAND_SET_NOID_GET_ID
  help: "[value]\n\tDynamic Range or number of bits per pixel in detector.\n\t[Eiger] Options: 4, 8, 12, 16, 32. If set to 32, also sets clkdivider to 2, else to 0.\n\t[Mythen3] Options: 8, 16, 32\n\t[Jungfrau][Moench][Gotthard][Ctb][Mythen3][Gotthard2] 16"
  actions:
    GET:
      function: getDynamicRange
    PUT:
      function: setDynamicRange

rx_zmqhwm:
  inherit_actions: INTEGER_COMMAND_SET_NOID_GET_ID
  help: "[n_value]\n\tReceiver's zmq send high water mark. Default is the zmq library's default (1000). This is a high number and can be set to 2 for gui purposes. One must also set the client's receive high water mark to similar value. Final effect is sum of them. Also restarts receiver zmq streaming if enabled. Can set to -1 to set default value."
  actions:
    GET:
      function: getRxZmqHwm
    PUT:
      function: setRxZmqHwm
extrastoragecells:
  inherit_actions: INTEGER_COMMAND_SET_NOID_GET_ID
  help: "[0-15]\n\t[Jungfrau] Only for chipv1.0. Number of additional storage cells. Default is 0. For advanced users only. \n\tThe #images = #frames x #triggers x (#extrastoragecells + 1)."
  actions:
    GET:
      function: getNumberOfAdditionalStorageCells
    PUT:
      function: setNumberOfAdditionalStorageCells

bursts:
  inherit_actions: INTEGER_COMMAND_SET_NOID_GET_ID
  help: "[n_bursts]\n\t[Gotthard2] Number of bursts per aquire. Only in auto timing mode and burst mode. Use timing command to set timing mode and burstmode command to set burst mode."
  actions:
    GET:
      function: getNumberOfBursts
    PUT:
      function: setNumberOfBursts

################# INTEGER_COMMAND_VEC_ID_GET #################

master:
  inherit_actions: INTEGER_COMMAND_VEC_ID_GET
  actions:
    GET:
      function: getMaster
    PUT:
      function: setMaster
udp_dstport:
  inherit_actions: INTEGER_COMMAND_VEC_ID_GET
  actions:
    GET:
      function: getDestinationUDPPort
    PUT:
      function: setDestinationUDPPort
udp_dstport2:
  inherit_actions: INTEGER_COMMAND_VEC_ID_GET
  actions:
    GET:
      function: getDestinationUDPPort2
    PUT:
      function: setDestinationUDPPort2
rx_tcpport:
  inherit_actions: INTEGER_COMMAND_VEC_ID_GET
  actions:
    GET:
      function: getRxPort
    PUT:
      function: setRxPort
rx_zmqport:
  inherit_actions: INTEGER_COMMAND_VEC_ID_GET
  actions:
    GET:
      function: getRxZmqPort
    PUT:
      function: setRxZmqPort
zmqport:
  inherit_actions: INTEGER_COMMAND_VEC_ID_GET
  actions:
    GET:
      function: getClientZmqPort
    PUT:
      function: setClientZmqPort


################# INTEGER_COMMAND_VEC_ID #################

trimval:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getAllTrimbits
    PUT:
      function: setAllTrimbits

fliprows:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getFlipRows
    PUT:
      function: setFlipRows
row:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getRow
    PUT:
      function: setRow
column:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getColumn
    PUT:
      function: setColumn
highvoltage:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getHighVoltage
    PUT:
      function: setHighVoltage
powerchip:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getPowerChip
    PUT:
      function: setPowerChip
imagetest:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getImageTestMode
    PUT:
      function: setImageTestMode
parallel:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getParallelMode
    PUT:
      function: setParallelMode
filterresistor:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getFilterResistor
    PUT:
      function: setFilterResistor
dbitpipeline:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getDBITPipeline
    PUT:
      function: setDBITPipeline
readnrows:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getReadNRows
    PUT:
      function: setReadNRows
numinterfaces:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getNumberofUDPInterfaces
    PUT:
      function: setNumberofUDPInterfaces
selinterface:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getSelectedUDPInterface
    PUT:
      function: selectUDPInterface
udp_firstdst:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getFirstUDPDestination
    PUT:
      function: setFirstUDPDestination
tengiga:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getTenGiga
    PUT:
      function: setTenGiga
flowcontrol10g:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getTenGigaFlowControl
    PUT:
      function: setTenGigaFlowControl
txdelay_frame:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getTransmissionDelayFrame
    PUT:
      function: setTransmissionDelayFrame
txdelay_left:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getTransmissionDelayLeft
    PUT:
      function: setTransmissionDelayLeft
txdelay_right:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getTransmissionDelayRight
    PUT:
      function: setTransmissionDelayRight
rx_fifodepth:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getRxFifoDepth
    PUT:
      function: setRxFifoDepth
rx_silent:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getRxSilentMode
    PUT:
      function: setRxSilentMode
rx_padding:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getPartialFramesPadding
    PUT:
      function: setPartialFramesPadding
rx_udpsocksize:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getRxUDPSocketBufferSize
    PUT:
      function: setRxUDPSocketBufferSize
rx_lock:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getRxLock
    PUT:
      function: setRxLock
rx_arping:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getRxArping
    PUT:
      function: setRxArping
fwrite:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getFileWrite
    PUT:
      function: setFileWrite
foverwrite:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getFileOverWrite
    PUT:
      function: setFileOverWrite
rx_framesperfile:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getFramesPerFile
    PUT:
      function: setFramesPerFile
rx_zmqstream:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getRxZmqDataStream
    PUT:
      function: setRxZmqDataStream
rx_zmqfreq:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getRxZmqFrequency
    PUT:
      function: setRxZmqFrequency
rx_zmqstartfnum:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getRxZmqStartingFrame
    PUT:
      function: setRxZmqStartingFrame
overflow:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getOverFlowMode
    PUT:
      function: setOverFlowMode
interruptsubframe:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getInterruptSubframe
    PUT:
      function: setInterruptSubframe
activate:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getActive
    PUT:
      function: setActive
partialreset:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getPartialReset
    PUT:
      function: setPartialReset
top:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getTop
    PUT:
      function: setTop
temp_threshold:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getThresholdTemperature
    PUT:
      function: setThresholdTemperature
temp_control:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getTemperatureControl
    PUT:
      function: setTemperatureControl
autocompdisable:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getAutoComparatorDisable
    PUT:
      function: setAutoComparatorDisable
storagecell_start:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getStorageCellStart
    PUT:
      function: setStorageCellStart
filtercells:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getNumberOfFilterCells
    PUT:
      function: setNumberOfFilterCells
veto:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getVeto
    PUT:
      function: setVeto
gates:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getNumberOfGates
    PUT:
      function: setNumberOfGates
interpolation:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getInterpolation
    PUT:
      function: setInterpolation
pumpprobe:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getPumpProbe
    PUT:
      function: setPumpProbe
apulse:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getAnalogPulsing
    PUT:
      function: setAnalogPulsing
dpulse:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getDigitalPulsing
    PUT:
      function: setDigitalPulsing
asamples:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getNumberOfAnalogSamples
    PUT:
      function: setNumberOfAnalogSamples
adcclk:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getADCClock
    PUT:
      function: setADCClock
runclk:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getRUNClock
    PUT:
      function: setRUNClock
dsamples:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getNumberOfDigitalSamples
    PUT:
      function: setNumberOfDigitalSamples
tsamples:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getNumberOfTransceiverSamples
    PUT:
      function: setNumberOfTransceiverSamples
dbitclk:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getDBITClock
    PUT:
      function: setDBITClock
extsampling:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getExternalSampling
    PUT:
      function: setExternalSampling
extsamplingsrc:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getExternalSamplingSource
    PUT:
      function: setExternalSamplingSource
rx_dbitoffset:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getRxDbitOffset
    PUT:
      function: setRxDbitOffset
led:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getLEDEnable
    PUT:
      function: setLEDEnable
adcpipeline:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getADCPipeline
    PUT:
      function: setADCPipeline
updatemode:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getUpdateMode
    PUT:
      function: setUpdateMode
port:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getControlPort
    PUT:
      function: setControlPort
stopport:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getStopPort
    PUT:
      function: setStopPort
lock:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getDetectorLock
    PUT:
      function: setDetectorLock
#
settings:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getSettings
    PUT:
      function: setSettings
      input_types: [ slsDetectorDefs::detectorSettings ]
timing:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getTimingMode
    PUT:
      function: setTimingMode
      input_types: [ slsDetectorDefs::timingMode ]
nextframenumber:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getNextFrameNumber
    PUT:
      function: setNextFrameNumber
      input_types: [ uint64_t ]
findex:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getAcquisitionIndex
    PUT:
      function: setAcquisitionIndex
      input_types: [ uint64_t ]

rx_discardpolicy:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getRxFrameDiscardPolicy
    PUT:
      function: setRxFrameDiscardPolicy
      input_types: [ slsDetectorDefs::frameDiscardPolicy ]
fformat:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getFileFormat
    PUT:
      function: setFileFormat
      input_types: [ slsDetectorDefs::fileFormat ]
cdsgain:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getCDSGain
    PUT:
      function: setCDSGain
      input_types: [ bool ]
gainmode:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getGainMode
    PUT:
      function: setGainMode
      input_types: [ slsDetectorDefs::gainMode ]
timingsource:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getTimingSource
    PUT:
      function: setTimingSource
      input_types: [ slsDetectorDefs::timingSourceType ]
romode:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getReadoutMode
    PUT:
      function: setReadoutMode
      input_types: [ slsDetectorDefs::readoutMode ]
polarity:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getPolarity
    PUT:
      function: setPolarity
      input_types: [ defs::polarity ]

udp_srcmac:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getSourceUDPMAC
    PUT:
      function: setSourceUDPMAC
      input_types: [ MacAddr ]
      input: [ 'MacAddr(args[0])' ]
      cast_input: [ false ]
udp_srcmac2:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getSourceUDPMAC2
    PUT:
      function: setSourceUDPMAC2
      input_types: [ MacAddr ]
      input: [ 'MacAddr(args[0])' ]
      cast_input: [ false ]
udp_dstmac:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getDestinationUDPMAC
    PUT:
      function: setDestinationUDPMAC
      input_types: [ MacAddr ]
      input: [ 'MacAddr(args[0])' ]
      cast_input: [ false ]
udp_dstmac2:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getDestinationUDPMAC2
    PUT:
      function: setDestinationUDPMAC2
      input_types: [ MacAddr ]
      input: [ 'MacAddr(args[0])' ]
      cast_input: [ false ]
rx_zmqip:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getRxZmqIP
    PUT:
      function: setRxZmqIP
      input_types: [ IpAddr ]
      input: [ 'IpAddr(args[0])' ]
      cast_input: [ false ]
zmqip:
  inherit_actions: INTEGER_COMMAND_VEC_ID
  actions:
    GET:
      function: getClientZmqIp
    PUT:
      function: setClientZmqIp
      input_types: [ IpAddr ]
      input: [ 'IpAddr(args[0])' ]
      cast_input: [ false ]


################# INTEGER_COMMAND_HEX #################
adcenable:
  inherit_actions: INTEGER_COMMAND_HEX
  actions:
    GET:
      function: getADCEnableMask
    PUT:
      function: setADCEnableMask
adcenable10g:
  inherit_actions: INTEGER_COMMAND_HEX
  actions:
    GET:
      function: getTenGigaADCEnableMask
    PUT:
      function: setTenGigaADCEnableMask
transceiverenable:
  inherit_actions: INTEGER_COMMAND_HEX
  actions:
    GET:
      function: getTransceiverEnableMask
    PUT:
      function: setTransceiverEnableMask
adcinvert:
  inherit_actions: INTEGER_COMMAND_HEX
  actions:
    GET:
      function: getADCInvert
    PUT:
      function: setADCInvert


################# INTEGER_COMMAND_HEX_WIDTH16 #################
patioctrl:
  inherit_actions: INTEGER_COMMAND_HEX_WIDTH16
  actions:
    GET:
      function: getPatternIOControl
    PUT:
      function: setPatternIOControl
patmask:
  inherit_actions: INTEGER_COMMAND_HEX_WIDTH16
  actions:
    GET:
      function: getPatternMask
    PUT:
      function: setPatternMask
patsetbit:
  inherit_actions: INTEGER_COMMAND_HEX_WIDTH16
  actions:
    GET:
      function: getPatternBitMask
    PUT:
      function: setPatternBitMask


################# TIME_COMMAND #############

period:
  inherit_actions: TIME_COMMAND
  actions:
    GET:
      function: getPeriod
    PUT:
      function: setPeriod

delay:
  inherit_actions: TIME_COMMAND
  actions:
    GET:
      function: getDelayAfterTrigger
    PUT:
      function: setDelayAfterTrigger

subexptime:
  inherit_actions: TIME_COMMAND
  actions:
    GET:
      function: getSubExptime
    PUT:
      function: setSubExptime

subdeadtime:
  inherit_actions: TIME_COMMAND
  actions:
    GET:
      function: getSubDeadTime
    PUT:
      function: setSubDeadTime
compdisabletime:
  inherit_actions: TIME_COMMAND
  actions:
    GET:
      function: getComparatorDisableTime
    PUT:
      function: setComparatorDisableTime

storagecell_delay:
  inherit_actions: TIME_COMMAND
  actions:
    GET:
      function: getStorageCellDelay
    PUT:
      function: setStorageCellDelay
burstperiod:
  inherit_actions: TIME_COMMAND
  actions:
    GET:
      function: getBurstPeriod
    PUT:
      function: setBurstPeriod

################# TIME_GET_COMMAND #############
delayl:
  inherit_actions: TIME_GET_COMMAND
  actions:
    GET:
      function: getDelayAfterTriggerLeft
frametime:
  inherit_actions: TIME_GET_COMMAND
  actions:
    GET:
      function: getMeasurementTime
runtime:
  inherit_actions: TIME_GET_COMMAND
  actions:
    GET:
      function: getActualTime
exptimel:
  inherit_actions: TIME_GET_COMMAND
  actions:
    GET:
      function: getExptimeLeft
measuredsubperiod:
  inherit_actions: TIME_GET_COMMAND
  actions:
    GET:
      function: getMeasuredSubFramePeriod
measuredperiod:
  inherit_actions: TIME_GET_COMMAND
  actions:
    GET:
      function: getMeasuredPeriod
periodl:
  inherit_actions: TIME_GET_COMMAND
  actions:
    GET:
      function: getPeriodLeft

################# STRING_COMMAND #################
settingspath:
  inherit_actions: STRING_COMMAND
  actions:
    GET:
      function: getSettingsPath
    PUT:
      function: setSettingsPath
fpath:
  inherit_actions: STRING_COMMAND
  actions:
    GET:
      function: getFilePath
    PUT:
      function: setFilePath
fname:
  inherit_actions: STRING_COMMAND
  actions:
    GET:
      function: getFileNamePrefix
    PUT:
      function: setFileNamePrefix








################# special commands ##########################
tempvalues:
  help: "\n\tGets the values for every temperature for this detector."
  actions:
    GET:
      argc: 0
      ctb_output_list:
        GETFCNLIST: getTemperatureList
        GETFCNNAME: ""
        GETFCN: getTemperature
        suffix: "Â°C"
        printable_name: "*it"





exptime:
  help: ""
  infer_action: true # infer action based on actions' argc (they must be unique if true)
  actions:
    GET:
      require_det_id: true
      function: getExptime
      args:
        - argc: 0
          output: [ OutString(t) ]
        - argc: 1
          arg_types: [ special::time_unit ]
          output: [ "OutString(t , args[0])" ]
      detectors:
        MYTHEN3:
          function: getExptimeForAllGates
    PUT:
      function: setExptime
      require_det_id: true
      input: [ converted_time ]
      input_types: [ time::ns ]
      args:
        - argc: 1
          separate_time_units:
            input: 'args[0]'
            output: [ converted_time, unit ]
          output: [ 'args[0]' ]
          arg_types: [ int ]

        - argc: 2
          arg_types: [ int, special::time_unit ]

          convert_to_time:
            input: [ 'args[0]', 'args[1]' ]
            output: converted_time
          output: [ 'args[0]', 'args[1]' ]




exptime1:
  inherit_actions: exptime
  actions:
    GET:
      extra_variables:
        - name: gateIndex
          type: int
          value: 0
      input: [ gateIndex ]
      input_types: [ int ]
      detectors:
    PUT:
      extra_variables:
        - name: gateIndex
          type: int
          value: 0
      detectors:
        MYTHEN3:
          input: [ gateIndex,converted_time ]
          input_types: [ int, time::ns ]




exptime2:
  inherit_actions: exptime1
  actions:
    GET:
      extra_variables:
        - name: gateIndex
          type: int
          value: 1
    PUT:
      extra_variables:
        - name: gateIndex
          type: int
          value: 1

exptime3:
  inherit_actions: exptime1
  actions:
    GET:
      extra_variables:
        - name: gateIndex
          type: int
          value: 2
    PUT:
      extra_variables:
        - name: gateIndex
          type: int
          value: 2



virtual:
  function_alias: virtualFunction
  help: "[n_servers] [starting_port_number]\n\tConnecs to n virtual server at local host starting at specific control port. Every virtual server will have a stop port (control port + 1)"
  actions:
    PUT:
      function: setVirtualDetectorServers
      argc: 2
      check_det_id: true
      input: [ 'args[0]', 'args[1]' ]
      input_types: [ int, int ]
      cast_input: [ true, true ]
      output: [ 'ToString(args)' ]

firmwareversion:
  help: "\n\tFirmware version of detector in format [0xYYMMDD] or an increasing 2 digit number for Eiger."
  actions:
    GET:
      argc: 0
      require_det_id: true
      function: getFirmwareVersion
      output: [ OutStringHex(t) ]
      detectors:
        EIGER:
          output: [ OutString(t) ]

packageversion:
  help: "\n\tPackage version (git branch)."
  actions:
    GET:
      argc: 0
      function: getPackageVersion
      output: [ t ]

clientversion:
  help: "\n\tClient software version"
  actions:
    GET:
      argc: 0
      function: getClientVersion
      output: [ t ]


detsize:
  help: "[nx] [ny]\n\tDetector size, ie. Number of channels in x and y dim. This is used to calculate module coordinates included in UDP data. \n\tBy default, it adds module in y dimension for 2d detectors and in x dimension for 1d detectors packet header."
  actions:
    GET:
      argc: 0
      function: getDetectorSize
      output: [ t ]
    PUT:
      argc: 2
      function: setDetectorSize
      input: [ 'defs::xy(StringTo<int>(args[0]),StringTo<int>(args[1]))' ]
      input_types: [ defs::xy ]
      arg_types: [int, int]
      output: [ 'ToString(args)' ]


trimbits:
  infer_action: true
  help: "[fname]\n\t[Eiger][Mythen3] Put will load the trimbit file to detector. If no extension specified, serial number of each module is attached. Get will save the trimbits from the detector to file with serial number added to file name."
  actions:
    GET:
      argc: 1
      require_det_id: true
      store_result_in_t: false
      function: saveTrimbits
      input: [ 'args[0]' ]
      input_types: [ std::string ]
      output: [ "args[0]" ]
    PUT:
      argc: 1
      function: loadTrimbits
      input: [ 'args[0]' ]
      input_types: [ std::string ]
      output: [ "args[0]" ]

gappixels:
  help: "[0, 1]\n\t[Eiger][Jungfrau][Moench] Include Gap pixels in client data call back in Detecor api. Will not be in detector streaming, receiver file or streaming. Default is 0. "
  actions:
    GET:
      argc: 0
      check_det_id: true
      function: getGapPixelsinCallback
      output: [ t ]
    PUT:
      argc: 1
      check_det_id: true
      function: setGapPixelsinCallback
      input: [ 'args[0]' ]
      input_types: [ bool ]
      cast_input: [ true ]
      output: [ args.front() ]

readoutspeed:
  help: "\n\t[0 or full_speed|1 or half_speed|2 or quarter_speed]\n\t[Eiger][Jungfrau][Moench] Readout speed of chip.\n\t[Eiger][Moench] Default speed is full_speed.\n\t[Jungfrau] Default speed is half_speed. full_speed option only available from v2.0 boards and is recommended to set number of interfaces to 2. Also overwrites adcphase to recommended default.\n\t [144|108]\n\t\t[Gotthard2] Readout speed of chip in MHz. Default is 108."
  actions:
    GET:
      exceptions:
        - condition: 'det->getDetectorType().squash() == defs::CHIPTESTBOARD'
          message: '"ReadoutSpeed not implemented. Did you mean runclk?"'
      argc: 0
      require_det_id: true
      function: getReadoutSpeed
      output: [ OutString(t) ]
    PUT:
      argc: 1
      require_det_id: true
      function: setReadoutSpeed
      input: [ 'args[0]' ]
      input_types: [ defs::speedLevel ]
      cast_input: [ true ]
      output: [ 'ToString(StringTo<defs::speedLevel>(args[0]))' ]


adcphase:
  infer_action: true
  help: "[n_value] [(optional)deg]\n\t[Jungfrau][Moench][Ctb][Gotthard] Phase shift of ADC clock. \n\t[Jungfrau][Moench] Absolute phase shift. If deg used, then shift in degrees. Changing Speed also resets adcphase to recommended defaults.\n\t[Ctb] Absolute phase shift. If deg used, then shift in degrees. Changing adcclk also resets adcphase and sets it to previous values.\n\t[Gotthard] Relative phase shift. Cannot get"
  actions:
    GET:
      require_det_id: true
      extra_variables:
        - name: det_type
          type: auto
          value: det->getDetectorType().squash(defs::GENERIC);

      exceptions:
        - condition: 'det_type == defs::EIGER || det_type == defs::MYTHEN3 || det_type == defs::GOTTHARD2'
          message: '"adcphase not implemented for this detector"'
      args:
        - argc: 0
          function: getADCPhase
          output: [ OutString(t) ]
        - argc: 1
          exceptions:
            - condition: 'det_type == defs::EIGER || det_type == defs::MYTHEN3 || det_type == defs::GOTTHARD2'
              message: '"adcphase not implemented for this detector"'
            - condition: 'args[0] != "deg"'
              message: '"Unknown adcphase   argument " + args[0] + ". Did you mean deg?    "'
          function: getADCPhaseInDegrees
          arg_types: [ special::deg ]
          output: [ OutString(t), '" deg"' ]

    PUT:
      extra_variables:
        - name: det_type
          type: auto
          value: det->getDetectorType().squash(defs::GENERIC);
      exceptions:
        - condition: 'det_type == defs::EIGER || det_type == defs::MYTHEN3 || det_type == defs::GOTTHARD2'
          message: '"adcphase not implemented for this detector"'
      require_det_id: true
      input: [ 'args[0]' ]
      input_types: [ int ]
      cast_input: [ true ]

      args:
        - argc: 1
          function: setADCPhase
          output: [ 'args.front()' ]
        - argc: 2
          arg_types: [ int, special::deg ]
          exceptions:
            - condition: 'det_type == defs::EIGER || det_type == defs::MYTHEN3 || det_type == defs::GOTTHARD2'
              message: '"adcphase not implemented for this detector"'
            - condition: 'args[1] != "deg"'
              message: '"Unknown adcphase   2nd argument " + args[1] + ". Did you    mean deg?"'

          function: setADCPhaseInDegrees
          output: [ 'args[0]',"' '", 'args[1]' ]


dbitphase:
  help: "[n_value] [(optional)deg]\n\t[Ctb][Jungfrau] Phase shift of clock to latch digital bits. Absolute phase shift. If deg used, then shift in degrees. \n\t[Ctb]Changing dbitclk also resets dbitphase and sets to previous values."
  actions:
    GET:
      extra_variables:
        - name: det_type
          type: auto
          value: det->getDetectorType().squash(defs::GENERIC);

      exceptions:
        - condition: 'det_type == defs::EIGER || det_type == defs::MYTHEN3 || det_type == defs::GOTTHARD2 || det_type == defs::MOENCH'
          message: '"dbitphase not implemented for this detector"'
      args:
        - argc: 0
          function: getDBITPhase
          output: [ OutString(t) ]
          require_det_id: true
        - argc: 1
          exceptions:
            - condition: 'det_type == defs::EIGER || det_type == defs::MYTHEN3 || det_type == defs::GOTTHARD2 || det_type == defs::MOENCH'
              message: '"dbitphase not implemented for this detector"'
            - condition: 'args[0] != "deg"'
              message: '"Unknown dbitphase argument " + args[0] + ". Did you mean deg?  "'
          function: getDBITPhaseInDegrees
          require_det_id: true
          arg_types: [ special::deg ]
          output: [ OutString(t), '" deg"' ]
    PUT:
      extra_variables:
        - name: det_type
          type: auto
          value: det->getDetectorType().squash(defs::GENERIC);

      exceptions:
        - condition: 'det_type == defs::EIGER || det_type == defs::MYTHEN3 || det_type == defs::GOTTHARD2 || det_type == defs::MOENCH'
          message: '"dbitphase not implemented for this detector"'
      require_det_id: true
      input: [ 'args[0]' ]
      input_types: [ int ]
      cast_input: [ true ]
      args:
        - argc: 1
          function: setDBITPhase
          output: [ 'args.front()' ]
        - argc: 2
          arg_types: [ int, special::deg ]
          exceptions:
            - condition: 'det_type == defs::EIGER || det_type == defs::MYTHEN3 || det_type == defs::GOTTHARD2 || det_type == defs::MOENCH'
              message: '"dbitphase not implemented for this detector"'
            - condition: 'args[1] != "deg"'
              message: '"Unknown dbitphase 2nd argument " + args[1] + ". Did you mean deg?  "'
          function: setDBITPhaseInDegrees
          output: [ 'args[0]',"' '", 'args[1]' ]



clkfreq:
  help: "[n_clock (0-5)] [freq_in_Hz]\n\t[Gotthard2][Mythen3] Frequency of clock n_clock in Hz. Use clkdiv to set frequency."
  actions:
    GET:
      extra_variables:
        - name: type
          type: defs::detectorType
          value: det->getDetectorType().squash(defs::GENERIC);
      exceptions:
        - condition: 'type != defs::GOTTHARD2 && type != defs::MYTHEN3'
          message: '"clkfreq not implemented for this detector."'
      argc: 1
      require_det_id: true
      function: getClockFrequency
      input: [ 'args[0]' ]
      input_types: [ int ]
      cast_input: [ true ]
      output: [ OutString(t) ]


clkphase:
  help: "[n_clock (0-5)] [phase] [deg (optional)]\n\t[Gotthard2][Mythen3] Phase of clock n_clock. If deg, then phase shift in degrees, else absolute phase shift values."
  actions:
    GET:
      extra_variables:
        - name: type
          type: defs::detectorType
          value: det->getDetectorType().squash(defs::GENERIC);
      exceptions:
        - condition: 'type != defs::GOTTHARD2 && type != defs::MYTHEN3'
          message: '"clkphase not implemented for this detector."'
      require_det_id: true
      input: [ 'args[0]' ]
      input_types: [ int ]
      cast_input: [ true ]
      output: [ OutString(t) ]
      args:
        - argc: 1
          function: getClockPhase
        - argc: 2
          exceptions:
            - condition: 'type != defs::GOTTHARD2 && type != defs::MYTHEN3'
              message: '"clkphase not implemented for this detector."'
            - condition: 'args[1] != "deg"'
              message: '"Cannot scan argument" + args[1] + ". Did you mean deg?"'
          arg_types: [ int , special::deg ]
          function: getClockPhaseinDegrees
          output: [ OutString(t), '" deg"' ]

    PUT:
      extra_variables:
        - name: type
          type: defs::detectorType
          value: det->getDetectorType().squash(defs::GENERIC);
      exceptions:
        - condition: 'type != defs::GOTTHARD2 && type != defs::MYTHEN3'
          message: '"clkphase not implemented for this detector."'
      require_det_id: true
      input: [ 'args[0]', 'args[1]' ]
      input_types: [ int, int ]
      cast_input: [ true, true ]
      args:
        - argc: 2
          function: setClockPhase
          output: [ 'args[1]' ]
        - argc: 3
          arg_types: [int, int , special::deg ]

          exceptions:
            - condition: 'type != defs::GOTTHARD2 && type != defs::MYTHEN3'
              message: '"clkphase not implemented for this detector."'
            - condition: 'args[1] != "deg"'
              message: '"Cannot scan argument" + args[2] + ". Did you mean deg?"'
          function: setClockPhaseinDegrees
          output: [ 'args[1]', '" "', 'args[2]' ]

maxclkphaseshift:
  help: "[n_clock (0-5)]\n\t[Gotthard2][Mythen3] Absolute Maximum Phase shift of clock n_clock."
  actions:
    GET:
      extra_variables:
        - name: type
          type: defs::detectorType
          value: det->getDetectorType().squash(defs::GENERIC);
      exceptions:
        - condition: 'type != defs::GOTTHARD2 && type != defs::MYTHEN3'
          message: '"maxclkphaseshift not implemented for this detector."'
      require_det_id: true
      input: [ 'args[0]' ]
      input_types: [ int ]
      cast_input: [ true ]
      output: [ OutString(t) ]
      argc: 1
      function: getMaxClockPhaseShift

clkdiv:
  help: "[n_clock (0-5)] [n_divider]\n\t[Gotthard2][Mythen3] Clock Divider of clock n_clock. Must be greater than 1."
  actions:
    GET:
      extra_variables:
        - name: type
          type: defs::detectorType
          value: det->getDetectorType().squash(defs::GENERIC);
      exceptions:
        - condition: 'type != defs::GOTTHARD2 && type != defs::MYTHEN3'
          message: '"clkdiv not implemented for this detector."'
      require_det_id: true
      input: [ 'args[0]' ]
      input_types: [ int ]
      cast_input: [ true ]
      output: [ OutString(t) ]
      argc: 1
      function: getClockDivider
    PUT:
      extra_variables:
        - name: type
          type: defs::detectorType
          value: det->getDetectorType().squash(defs::GENERIC);
      exceptions:
        - condition: 'type != defs::GOTTHARD2 && type != defs::MYTHEN3'
          message: '"clkdiv not implemented for this detector."'
      input: [ 'args[0]', 'args[1]', "{det_id}" ]
      input_types: [ int, int, auto ]
      cast_input: [ true, true, false ]
      argc: 2
      arg_types: [ int, int ]
      function: setClockDivider
      output: [ 'args[1]' ]

extsig:
  help: "[n_signal] [signal_type]\n\t[Gotthard][Mythen3] External signal mode for trigger timing mode.\n\t[Gotthard] [0] [trigger_in_rising_edge|trigger_in_falling_edge]\n\t[Mythen3] [0-7] [trigger_in_rising_edge|trigger_in_falling_edge|inversion_on|inversion_off]\n\t where 0 is master input trigger signal, 1-3 is master input gate signals, 4 is busy out signal and 5-7 is master output gate signals."
  actions:
    GET:
      argc: 1
      require_det_id: true
      function: getExternalSignalFlags
      input: [ 'args[0]' ]
      input_types: [ int ]
      cast_input: [ true ]
      output: [ "args[0]","' '", OutString(t) ]
    PUT:
      argc: 2
      require_det_id: true
      function: setExternalSignalFlags
      input: [ 'args[0]', 'args[1]' ]
      input_types: [ int, slsDetectorDefs::externalSignalFlag ]
      cast_input: [ true, true ]
      output: [ 'args[0]', "' '", 'args[1]' ]


dac:
  help: "" # TODO
  actions:
    GET:
      exceptions:
        - condition: "args.size() > 0 && action != defs::HELP_ACTION && is_int(args[0]) && det->getDetectorType().squash() != defs::CHIPTESTBOARD"
          message: '"Dac indices can only be used for chip test board. Use daclist to get list of dac names for current detector."'
      extra_variables:
        - name: dacIndex
          type: defs::dacIndex
          value: "(det->getDetectorType().squash() == defs::CHIPTESTBOARD && !is_int(args[0])) ? det->getDacIndex(args[0]) : StringTo<defs::dacIndex>(args[0])"
      function: getDAC
      input_types: [ defs::dacIndex, bool ]
      cast_input: [ false, true ]
      require_det_id: true
      args:
        - argc: 1
          input: [ dacIndex, '"0"' ]
          output: [ OutString(t) ]
          arg_types: [defs::dacIndex]
        - argc: 2
          exceptions:
            - condition: "args.size() > 0 && action != defs::HELP_ACTION && is_int(args[0]) && det->getDetectorType().squash() != defs::CHIPTESTBOARD"
              message: '"Dac indices can only be used for chip test board. Use daclist to get list of dac names for current detector."'
            - condition: 'args[1] != "mv" && args[1] != "mV"'
              message: '"Unknown argument " + args[1] + ". Did you mean mV?"'
          input: [ dacIndex, '"1"' ]
          arg_types: [defs::dacIndex, special::mv]
          output: [ OutString(t), '" mV"' ]
    PUT:
      exceptions:
        - condition: "args.size() > 0 && action != defs::HELP_ACTION && is_int(args[0]) && det->getDetectorType().squash() != defs::CHIPTESTBOARD"
          message: '"Dac indices can only be used for chip test board. Use daclist to get list of dac names for current detector."'
      extra_variables:
        - name: dacIndex
          type: defs::dacIndex
          value: "(det->getDetectorType().squash() == defs::CHIPTESTBOARD && !is_int(args[0])) ? det->getDacIndex(args[0]) : StringTo<defs::dacIndex>(args[0])"
      function: setDAC
      require_det_id: true
      input_types: [ defs::dacIndex, int, bool ]
      cast_input: [ false, true, true ]

      args:
        - argc: 2
          input: [ dacIndex, "args[1]", '"0"' ]
          arg_types: [defs::dacIndex, int]
          output: [ "args[0]", "' '", "args[1]" ]
        - argc: 3
          input: [ dacIndex, "args[1]", '"1"' ]
          arg_types: [defs::dacIndex, int, special::mv]
          output: [ "args[0]", "' '", "args[1]", '" mV"' ]

resetdacs:
  help: "[(optional) hard] \n\t[Eiger][Jungfrau][Moench][Gotthard][Gotthard2][Mythen3]Reset dac values to the defaults. A 'hard' optional reset will reset the dacs to the hardcoded defaults in on-board detector server."
  actions:
    PUT:
      function: resetToDefaultDacs
      require_det_id: true
      output: [ '"successful"' ]
      input_types: [ bool ]
      args:
        - argc: 1
          arg_types: [ special::hard ]
          exceptions:
            - condition: 'args[0] != "hard"'
              message: '"Unknown argument " + args[0] + ". Did you mean hard?"'
          input: [ '"1"' ]
        - argc: 0
          input: [ '"0"' ]

defaultdac:
  help: "[dac name][value][(optional)setting]\n\tSets the default for that dac to this value.\n\t[Jungfrau][Moench][Mythen3] When settings is provided, it sets the default value only for that setting"
  actions:
    GET:
      function: getDefaultDac
      require_det_id: true

      args:
        - argc: 1
          input: [ "args[0]" ]
          input_types: [ defs::dacIndex ]
          output: [ "args[0]", "' '", OutString(t) ]
          cast_input: [ true ]

        - argc: 2
          cast_input: [ true, true ]
          input: [ "args[0]", "args[1]" ]
          input_types: [ defs::dacIndex, slsDetectorDefs::detectorSettings ]
          output: [ "args[0]", "' '", "args[1]", "' '", OutString(t) ]
    PUT:
      function: setDefaultDac
      args:
        - argc: 2
          cast_input: [ true, true ]
          input: [ "args[0]", "args[1]" ]
          input_types: [ defs::dacIndex, int ]
          output: [ "args[0]", "' '", "args[1]" ]
        - argc: 3
          cast_input: [ true, true, true ]
          input: [ "args[0]", "args[1]", "args[2]" ]
          input_types: [ defs::dacIndex, int, slsDetectorDefs::detectorSettings ]
          output: [ "args[0]", "' '", "args[2]", "' '", "args[1]" ]
          require_det_id: true

rx_status:
  help: "[running, idle, transmitting]\n\tReceiver listener status."
  actions:
    GET:
      argc: 0
      function: getReceiverStatus
      require_det_id: true
      output: [ OutString(t) ]
      # TODO add specific error on PUT

status:
  help: "[running, error, transmitting, finished, waiting, idle]\n\tDetector status. Goes to stop server."
  actions:
    GET:
      argc: 0
      function: getDetectorStatus
      require_det_id: true
      output: [ OutString(t) ]
    # TODO add specific error on PUT


scan:
  help: "[dac_name|0|trimbits] [start_val] [stop_val] [step_size] [dac settling time ns|us|ms|s]\n\tEnables/ disables scans for dac and trimbits \n\tEnabling scan sets number of frames to number of steps in receiver. \n\tTo cancel scan configuration, set dac to '0', which also sets number of frames to 1. \n\t[Eiger][Mythen3] Use trimbits as dac name for a trimbit scan."
  actions:
    GET:
      argc: 0
      function: getScan
      output: [ OutString(t) ]
    PUT:
      check_det_id: true
      function: setScan
      output: [ ToString(args) ]

      args:
        - argc: 1
          arg_types: [ int ]
          exceptions:
            - condition: 'StringTo<int>(args[0]) != 0'
              message: '"Unknown argument " + args[0] + ". Did you mean 0?"'
          input: [ "defs::scanParameters()" ]
          input_types: [ auto ]
        - argc: 4
          arg_types: [ defs::dacIndex, int, int, int ]

          input: [ "defs::scanParameters(StringTo<defs::dacIndex>(args[0]), StringTo<int>(args[1]), StringTo<int>(args[2]), StringTo<int>(args[3]))" ]
          input_types: [ auto ]
        - argc: 5
          arg_types: [ defs::dacIndex, int, int, int, std::string ]
          separate_time_units:
            input: 'args[4]'
            output: [ t, unit ]
          input: [ "defs::scanParameters(StringTo<defs::dacIndex>(args[0]), StringTo<int>(args[1]), StringTo<int>(args[2]), StringTo<int>(args[3]), t)" ]
          input_types: [ auto ]

Trigger:
  template: true
  actions:
    PUT:
      check_det_id: true
      argc: 0
      function: sendSoftwareTrigger
      input: [ block ]
      input_types: [ bool ]
      cast_input: [ false ]
      output: [ '"successful"' ]

trigger:
  inherit_actions: Trigger
  help: "\n\t[Eiger][Mythen3][Jungfrau][Moench] Sends software trigger signal to detector"
  actions:
    PUT:
      extra_variables:
        - name: block
          type: bool
          value: "false"

blockingtrigger:
  inherit_actions: Trigger
  help: "\n\t[Eiger][Mythen3][Jungfrau][Moench] Sends software trigger signal to detector"
  actions:
    PUT:
      extra_variables:
        - name: block
          type: bool
          value: "true"

udp_dstlist:
  help: "[ip=x.x.x.x] [(optional)ip2=x.x.x.x] \n\t\t[mac=xx:xx:xx:xx:xx:xx] [(optional)mac2=xx:xx:xx:xx:xx:xx]\n\t\t[port=value] [(optional)port2=value]\n\t\tThe order of ip, mac and port does not matter. entry_value can be >0 only for [Eiger][Jungfrau][Moench][Mythen3][Gotthard2] where round robin is implemented. If 'auto' used, then ip is set to ip of rx_hostname."
  actions:
    GET:
      exceptions:
        - condition: "rx_id < 0 || rx_id >= MAX_UDP_DESTINATION"
          message: '"Invalid receiver index " + std::to_string(rx_id) + ".to set round robin entry."'
      check_det_id: true
      argc: 0
      input: [ rx_id ]
      input_types: [ auto ]
      function: getDestinationUDPList
      require_det_id: true
      output: [ OutString(t) ]
    PUT:
      exceptions:
        - condition: "rx_id < 0 || rx_id >= MAX_UDP_DESTINATION"
          message: '"Invalid receiver index to set round robin entry."'
      check_det_id: true
      argc: 1
      input: [ getUdpEntry() ]
      input_types: [ auto ]
      arg_types: [ std::string ]
      function: setDestinationUDPList
      require_det_id: true
      convert_det_id: false
      output: [ ToString(args) ]

txdelay:
  help: "[n_delay]\n\t[Eiger][Jungfrau][Moench][Mythen3] Set transmission delay for all modules in the detector using the step size provided.Sets up \n\t\t[Eiger] txdelay_left to (2 * mod_index * n_delay), \n\t\t[Eiger] txdelay_right to ((2 * mod_index + 1) * n_delay) and \n\t\t[Eiger] txdelay_frame to (2 *num_modules * n_delay)  \n\t\t[Jungfrau][Moench][Mythen3] txdelay_frame to (num_modules * n_delay)  \nfor every module."
  actions:
    GET:
      argc: 0
      check_det_id: true
      function: getTransmissionDelay
      output: [ OutString(t) ]
    PUT:
      argc: 1
      check_det_id: true
      function: setTransmissionDelay
      input: [ 'args[0]' ]
      input_types: [ int ]
      cast_input: [ true ]
      output: [ 'args.front()' ]


zmqhwm:
  help: "[n_limit] \n\tClient's zmq receive high water mark. Default is the zmq library's default (1000), can also be set here using -1. \n\tThis is a high number and can be set to 2 for gui purposes. \n\tOne must also set the receiver's send high water mark to similar value. Final effect is sum of them.\n\t Setting it via command line is useful only before zmq enabled (before opening gui)."
  actions:
    GET:
      argc: 0
      function: getClientZmqHwm
      output: [ t ]
    PUT:
      argc: 1
      function: setClientZmqHwm
      input: [ 'args[0]' ]
      input_types: [ int ]
      cast_input: [ true ]
      output: [ 'det->getClientZmqHwm()' ]


pulse:
  help: "[n_times] [x] [y]\n\t[Eiger] Pulse pixel n number of times at coordinates (x, y). Advanced User!"
  actions:
    PUT:
      argc: 3
      require_det_id: true
      function: pulsePixel
      extra_variables:
        - name: c
          type: defs::xy
          value: defs::xy(StringTo<int>(args[1]), StringTo<int>(args[2]))
      input: [ 'args[0]', c ]
      arg_types: [int , int, int]
      input_types: [ int, defs::xy ]
      cast_input: [ true, false ]
      output: [ ToString(args) ]

pulsenmove:
  help: "[n_times] [x] [y]\n\t[Eiger] Pulse pixel n number of times and moves relatively by (x, y). Advanced User!"
  actions:
    PUT:
      argc: 3
      require_det_id: true
      function: pulsePixelNMove
      extra_variables:
        - name: c
          type: defs::xy
          value: defs::xy(StringTo<int>(args[1]), StringTo<int>(args[2]))
      input: [ 'args[0]', c ]
      arg_types: [ int , int, int ]

      input_types: [ int, defs::xy ]
      cast_input: [ true, false ]
      output: [ ToString(args) ]


pulsechip:
  help: "[n_times] \n\t[Eiger] Pulse chip n times. If n is -1, resets to normal mode (reset chip completely at start of acquisition, where partialreset = 0). Advanced User!"
  actions:
    PUT:
      argc: 1
      require_det_id: true
      function: pulseChip
      input: [ 'args[0]' ]
      input_types: [ int ]
      cast_input: [ true ]
      output: [ args.front() ]

quad:
  help: "[0, 1]\n\t[Eiger] Sets detector size to a quad. 0 (disabled) is default. (Specific hardware required)."
  actions:
    GET:
      argc: 0
      require_det_id: true
      function: getQuad
      output: [ OutString(t) ]
    PUT:
      argc: 1
      check_det_id: true
      function: setQuad
      input: [ 'args[0]' ]
      input_types: [ bool ]
      cast_input: [ true ]
      output: [ args.front() ]

datastream:
  help: "[left|right] [0, 1]\n\t[Eiger] Enables or disables data streaming from left or/and right side of detector for 10 GbE mode. 1 (enabled) by default."
  actions:
    GET:
      argc: 1
      require_det_id: true
      function: getDataStream
      input: [ 'args[0]' ]
      input_types: [ defs::portPosition ]
      cast_input: [ true ]
      output: [ OutString(t) ]
    PUT:
      argc: 2
      require_det_id: true
      function: setDataStream
      input: [ 'args[0]', 'args[1]' ]
      input_types: [ defs::portPosition, bool ]
      cast_input: [ true, true ]
      output: [ 'args[0]', 'args[1]' ]

temp_event:
  help: "[0]\n\t[Jungfrau][Moench] 1, if a temperature event occured. To clear this event, set it to 0.\n\tIf temperature crosses threshold temperature and temperature control is enabled, power to chip will be switched off and temperature event occurs. To power on chip again, temperature has to be less than threshold temperature and temperature event has to be cleared."
  actions:
    GET:
      argc: 0
      require_det_id: true
      function: getTemperatureEvent
      output: [ OutString(t) ]
    PUT:
      argc: 1
      exceptions:
        - condition: 'StringTo<int>(args[0]) != 0'
          message: '"Unknown argument for temp event: ( " + args[0] + " ). Did you mean 0 to reset event?"'
      require_det_id: true
      arg_types: [ int ]
      function: resetTemperatureEvent
      output: [ '"cleared"' ]


roi:
  help: "[xmin] [xmax] \n\t[Gotthard] Region of interest in detector.\n\tOptions: Only a single ROI per module. \n\tEither all channels or a single adc or 2 chips (256 channels). Default is all channels enabled (-1 -1). "
  actions:
    GET:
      argc: 0
      require_det_id: true
      function: getROI
      output: [ t ]
    PUT:
      argc: 2
      exceptions:
        - condition: 'det_id == -1 && det->size() > 1'
          message: '"Cannot execute ROI at multi module level"'
      require_det_id: true
      convert_det_id: false
      function: setROI
      extra_variables:
        - name: t
          type: defs::ROI
          value: defs::ROI(StringTo<int>(args[0]), StringTo<int>(args[1]))
      input: [ t ]
      arg_types: [ int, int ]
      input_types: [ defs::ROI ]
      output: [ 't' ]


inj_ch:
  help: "[offset] [increment]\n\t[Gotthard2] Inject channels with current source for calibration. Offset is starting channel that is injected, increment determines succeeding channels to be injected."
  actions:
    GET:
      argc: 0
      require_det_id: true
      function: getInjectChannel
      output: [ OutString(t) ]
    PUT:
      argc: 2
      function: setInjectChannel
      input: [ 'args[0]', 'args[1]', "{det_id}" ]
      input_types: [ int, int , auto ]
      arg_types: [int, int]
      cast_input: [ true, true, false ]
      output: [ ToString(args) ]


vetophoton:
  help: "[ichip] [#photons] [energy in keV] [reference file]\n\t[Gotthard2] Set veto reference for 128 channels for chip ichip according to reference file and #photons and energy in keV.\n[ichip] [output file]\n\t Get gain indices and veto reference for 128 channels for chip ichip, saved to file."
  actions:
    GET:
      argc: 2
      require_det_id: true
      function: getVetoPhoton
      store_result_in_t: false
      input: [ 'args[0]', 'args[1]' ]
      input_types: [ int, std::string ]
      cast_input: [ true, false ]
      output: [ '"saved to file "' , "args[1]" ]
    PUT:
      argc: 4
      require_det_id: true
      function: setVetoPhoton
      input: [ 'args[0]', 'args[1]', "args[2]", "args[3]" ]
      input_types: [ int, int, int, std::string ]
      cast_input: [ true, true, true, false ]
      output: [ ToString(args) ]


vetoref:
  help: "[gain index] [12 bit value]\n\t[Gotthard2] Set veto reference for all 128 channels for all chips."
  actions:
    PUT:
      argc: 2
      function: setVetoReference
      input: [ 'args[0]', 'args[1]', "{det_id}" ]
      input_types: [ int, int, auto ]
      cast_input: [ true, true, false ]
      output: [ ToString(args) ]

vetofile:
  help: "[chip index 0-10, -1 for all] [file name] \n\t[Gotthard2] Set veto reference for each 128 channels for specific chip. The file should have 128 rows of gain index and 12 bit value in dec"
  actions:
    PUT:
      argc: 2
      function: setVetoFile
      input: [ 'args[0]', 'args[1]' ]
      input_types: [ int, std::string ]
      cast_input: [ true, false ]
      require_det_id: true
      output: [ ToString(args) ]

vetoalg:
  help: "[hits|raw] [lll|10gbe]\n\t[Gotthard2] Set the veto algorithm. Default is hits."
  actions:
    GET:
      argc: 1
      extra_variables:
        - name: interface
          type: defs::streamingInterface
          value: StringTo<defs::streamingInterface>(args[0])
      exceptions:
        - condition: 'interface == defs::streamingInterface::NONE'
          message: '"Must specify an interface to set algorithm"'
      require_det_id: true
      function: getVetoAlgorithm
      input: [ 'interface' ]
      input_types: [ defs::streamingInterface ]
      cast_input: [ false ]
      output: [ OutString(t), "' '", ToString(interface) ]
    PUT:
      argc: 2
      extra_variables:
        - name: alg
          type: defs::vetoAlgorithm
          value: StringTo<defs::vetoAlgorithm>(args[0])
        - name: interface
          type: defs::streamingInterface
          value: StringTo<defs::streamingInterface>(args[1])
      exceptions:
        - condition: 'interface == defs::streamingInterface::NONE'
          message: '"Must specify an interface to set algorithm"'
      require_det_id: true
      function: setVetoAlgorithm
      input: [ 'alg', 'interface' ]
      input_types: [ defs::vetoAlgorithm, defs::streamingInterface ]
      cast_input: [ false, false ]


confadc:
  help: "[chip index 0-9, -1 for all] [adc index 0-31, -1 for all] [7 bit configuration value in hex]\n\t[Gotthard2] Sets  configuration for specific chip and adc, but configures 1 chip (all adcs for that chip) at a time."
  actions:
    GET:
      argc: 2
      require_det_id: true
      function: getADCConfiguration
      input: [ 'args[0]', 'args[1]' ]
      input_types: [ int, int ]
      cast_input: [ true, true ]
      output: [ OutStringHex(t) ]
    PUT:
      argc: 3
      require_det_id: true
      function: setADCConfiguration
      input: [ 'args[0]', 'args[1]', 'args[2]' ]
      input_types: [ int, int, int ]
      cast_input: [ true, true, true ]
      output: [ "'['", "args[0]", '", "', "args[1]", '", "', "ToStringHex( StringTo<int>(args[2]))", '"]"' ]


gatedelay:
  help: "[duration] [(optional unit) ns|us|ms|s]\n\t[Mythen3] Gate Delay of all gate signals in auto and trigger mode (internal gating)."
  actions:
    GET:
      function: getGateDelayForAllGates
      require_det_id: true

      args:
        - argc: 0
          output: [ OutString(t) ]
        - argc: 1
          arg_types: [ special::time_unit ]
          output: [ "OutString(t, args[0])" ]
    PUT:
      extra_variables:
        - name: gateIndex
          type: int
          value: -1
      require_det_id: true
      function: setGateDelay
      input: [ gateIndex, converted_time ]
      input_types: [ int, time::ns ]
      args:
        - argc: 1
          arg_types: [ std::string ]

          separate_time_units:
            input: 'args[0]'
            output: [ converted_time, unit ]
          output: [ 'args[0]' ]
        - argc: 2
          arg_types: [ int, special::time_unit ]

          convert_to_time:
            input: [ 'args[0]', 'args[1]' ]

            output: converted_time
          output: [ 'args[0]', 'args[1]' ]

gatedelay1:
  help: "[duration] [(optional unit) ns|us|ms|s]\n\t[Mythen3] Gate Delay of gate signal 1 in auto and trigger mode (internal gating)."
  inherit_actions: gatedelay
  actions:
    GET:
      require_det_id: true
      extra_variables:
        - name: gateIndex
          type: int
          value: 0
      function: getGateDelay
      input: [ gateIndex ]
      input_types: [ int ]
      args:
        - argc: 0
          output: [ OutString(t) ]
        - argc: 1
          output: [ "OutString(t, args[0])" ]
    PUT:
      extra_variables:
        - name: gateIndex
          type: int
          value: 0

gatedelay2:
  help: "[duration] [(optional unit) ns|us|ms|s]\n\t[Mythen3] Gate Delay of gate signal 2 in auto and trigger mode (internal gating)."
  inherit_actions: gatedelay1
  actions:
    GET:
      extra_variables:
        - name: gateIndex
          type: int
          value: 1
    PUT:
      extra_variables:
        - name: gateIndex
          type: int
          value: 1

gatedelay3:
  help: "[duration] [(optional unit) ns|us|ms|s]\n\t[Mythen3] Gate Delay of gate signal 3 in auto and trigger mode (internal gating)."
  inherit_actions: gatedelay1
  actions:
    GET:
      extra_variables:
        - name: gateIndex
          type: int
          value: 2
    PUT:
      extra_variables:
        - name: gateIndex
          type: int
          value: 2


adcvpp:
  help: "[dac or mV value][(optional unit) mV] \n\t[Ctb] Vpp of ADC.\n\t 0 -> 1V ; 1 -> 1.14V ; 2 -> 1.33V ; 3 -> 1.6V ; 4 -> 2V. \n\tAdvanced User function!"
  actions:
    GET:
      require_det_id: true
      function: getADCVpp
      args:
        - argc: 0
          output: [ OutString(t) ]
          input: [ '"0"' ]
          input_types: [ bool ]
          cast_input: [ true ]
        - argc: 1
          exceptions:
            - condition: '(args[0] != "mv") && (args[0] != "mV")'
              message: '"Unknown argument " + args[0] + ". Did you mean mV?"'
          input: [ '"1"' ]
          arg_type: [ special::mv ]
          input_types: [ bool ]
          cast_input: [ true ]
          output: [ OutString(t), '" mV"' ]
    PUT:
      require_det_id: true
      function: setADCVpp
      args:
        - argc: 0
          output: [ "args[0]" ]
          input: [ "args[0]", '"0"' ]
          input_types: [ int, bool ]
          cast_input: [ true, true ]
        - argc: 1
          arg_types: [ special::mv ]
          exceptions:
            - condition: '(args[1] != "mv") && (args[1] != "mV")'
              message: '"Unknown argument " + args[1] + ". Did you mean mV?"'
          input: [ "args[0]", '"1"' ]
          input_types: [ int, bool ]
          cast_input: [ true , true ]
          output: [ "args[0]", '" mV"' ]


diodelay:
  help: "[0-775]\n\t[Ctb] Delay for diode. Delay is in ps and max of 775 ps. Resolution is 25 ps."
  actions:
    PUT:
      argc: 2

      require_det_id: true
      function: setDigitalIODelay
      input: [ 'args[0]', 'args[1]' ]
      input_types: [ uint64_t, int ]
      cast_input: [ true, true ]
      output: [ ToString(args) ]

# pattern is a keyword in yaml, so patternX is used to avoid it
patternX:
  help: "[fname]\n\t[Mythen3][Ctb] Loads ASCII pattern file directly to server (instead of executing line by line)"
  command_name: "pattern"
  actions:
    PUT:
      argc: 1
      require_det_id: true
      function: setPattern
      input: [ 'args[0]' ]
      input_types: [ std::string ]
      cast_input: [ false ]
      output: [ 'args.front()' ]


patword:
  help: "[step or address] [64 bit mask]\n\t[Ctb][Mythen3] 64 bit pattern at address of pattern memory.\n\t[Ctb] read is same as executing pattern"
  actions:
    GET:
      argc: 1
      require_det_id: true
      function: getPatternWord
      input: [ 'args[0]' ]
      input_types: [ int ]
      cast_input: [ true ]
      output: [ "'['","ToStringHex(StringTo<int>(args[0]), 4)", '", "', "OutStringHex(t, 16)", '"]"' ]
    PUT:
      argc: 2
      require_det_id: true
      function: setPatternWord
      input: [ 'args[0]', 'args[1]' ]
      input_types: [ int, uint64_t ]
      cast_input: [ true, true ]
      output: [ "'['", "ToStringHex(args[0], 4)", '", "', "ToStringHex(args[1], 16)", '"]"' ]


rx_jsonpara:
  help: "[key1] [value1]\n\t[Receiver] Additional json header parameter streamed out from receiver. If not found in header, the pair is appended. An empty values deletes parameter. Max 20 characters for each key/value."
  actions:
    GET:
      argc: 1
      require_det_id: true
      function: getAdditionalJsonParameter
      input: [ 'args[0]' ]
      input_types: [ std::string ]
      output: [ OutString(t) ]
    PUT:
      require_det_id: true
      function: setAdditionalJsonParameter
      args:
        - argc: 1
          input: [ 'args[0]', '""' ]
          arg_types: [ std::string ]
          input_types: [ std::string, std::string ]
          cast_input: [ false, false ]
          output: [ 'args[0]', '" deleted"' ]
        - argc: 2
          input: [ 'args[0]', 'args[1]' ]
          input_types: [ std::string, std::string ]
          cast_input: [ false, false ]
          output: [ '"{"', 'args[0]', '": "', 'args[1]', '"}"' ]

programfpga:
  help: "[fname.pof | fname.rbf (full path)][(opitonal)--force-delete-normal-file]\n\t[Jungfrau][Moench][Ctb] Programs FPGA from pof file (full path). Then, detector controller is rebooted. \n\t\tUse --force-delete-normal-file argument, if normal file found in device tree, it must be deleted, a new device drive created and programming continued.\n\t[Mythen3][Gotthard2] Programs FPGA from rbf file (full path). Then, detector controller is rebooted."
  actions:
    PUT:
      output: [ '"successful"' ]
      require_det_id: true
      function: programFPGA

      args:
        - argc: 1
          input: [ 'args[0]', '"0"' ]
          arg_types: [ std::string ]
          input_types: [ std::string, bool ]
          cast_input: [ false, true ]
        - argc: 2
          arg_types: [std::string, special::force-delete-normal-file]
          exceptions:
            - condition: 'args[1] != "--force-delete-normal-file"'
              message: '"Could not scan second argument. Did you mean --force-delete-normal-file?"'
          input: [ 'args[0]', '"1"' ]
          input_types: [ std::string, bool ]
          cast_input: [ false, true ]


updatedetectorserver:
  help: "[server_name  with full path]\n\t[Jungfrau][Moench][Eiger][Ctb][Mythen3][Gotthard2] Copies detector server via TCP (without tftp). Makes a symbolic link with a shorter name (without vx.x.x). Then, detector controller reboots (except Eiger).\n\t[Jungfrau][Moench][Ctb]Also changes respawn server to the link, which is effective after a reboot."
  actions:
    PUT:
      argc: 1
      require_det_id: true
      function: updateDetectorServer
      input: [ 'args[0]' ]
      input_types: [ std::string ]
      output: [ '"successful"' ]

updatekernel:
  help: "[kernel_name with full path]\n\t[Jungfrau][Moench][Ctb][Mythen3][Gotthard2] Advanced Command!! You could damage the detector. Please use with caution.\n\tUpdates the kernel image. Then, detector controller reboots with new kernel."
  actions:
    PUT:
      argc: 1
      require_det_id: true
      function: updateKernel
      input: [ 'args[0]' ]
      input_types: [ std::string ]
      output: [ '"successful"' ]


update:
  help: "\n\tWithout tftp: [server_name (incl fullpath)] [fname.pof (incl full path)] This does not use tftp.\n\t\t[Jungfrau][Moench][Gotthard][CTB] Updates the firmware, detector server, deletes old server, creates the symbolic link and then reboots detector controller. \n\t\t[Mythen3][Gotthard2] will require a script to start up the shorter named server link at start up. \n\t\tserver_name is full path name of detector server binary\n\t\tfname is full path of programming file"
  actions:
    PUT:
      argc: 2
      exceptions:
        - condition: 'args[args.size() - 1].find(".pof") == std::string::npos && args[args.size() - 1].find(".rbf") == std::string::npos'
          message: '"Programming file must be a pof/rbf file."'
      require_det_id: true
      function: updateFirmwareAndServer
      input: [ 'args[0]', 'args[1]' ]
      input_types: [ std::string, std::string ]
      output: [ '"successful"' ]


reg:
  help: "[address] [32 bit value]\n\t[Mythen3][Gotthard2] Reads/writes to a 32 bit register in hex. Advanced Function!\n\tGoes to stop server. Hence, can be called while calling blocking acquire().\n\t[Eiger] +0x100 for only left, +0x200 for only right."
  actions:
    GET:
      argc: 1
      require_det_id: true
      function: readRegister
      input: [ 'args[0]' ]
      input_types: [ uint32_t ]
      cast_input: [ true ]
      output: [ OutStringHex(t) ]
    PUT:
      argc: 2
      require_det_id: true
      function: writeRegister
      input: [ 'args[0]', 'args[1]' ]
      input_types: [ uint32_t, uint32_t ]
      cast_input: [ true, true ]
      output: [ ToString(args) ]

adcreg:
  help: "[address] [value]\n\t[Jungfrau][Moench][Ctb][Gotthard] Writes to an adc register in hex. Advanced user Function!"
  actions:
    PUT:
      argc: 2
      require_det_id: true
      function: writeAdcRegister
      input: [ 'args[0]', 'args[1]' ]
      input_types: [ uint32_t, uint32_t ]
      cast_input: [ true, true ]
      output: [ ToString(args) ]


getbit:
  help: "[reg address in hex] [bit index]\n\tGets bit in address."
  actions:
    GET:
      argc: 2
      exceptions:
        - condition: 'StringTo<int>(args[1]) < 0 || StringTo<int>(args[1]) > 31'
          message: '"Bit number out of range: " + args[1]'
      require_det_id: true
      function: getBit
      input: [ 'args[0]', 'args[1]' ]
      input_types: [ uint32_t, int ]
      cast_input: [ true, true ]
      output: [ OutString(t) ]

setbit:
  help: "[reg address in hex] [bit index]\n\tSets bit in address."
  actions:
    PUT:
      argc: 2
      exceptions:
        - condition: 'StringTo<int>(args[1]) < 0 || StringTo<int>(args[1]) > 31'
          message: '"Bit number out of range: " + args[1]'
      require_det_id: true
      function: setBit
      input: [ 'args[0]', 'args[1]' ]
      input_types: [ uint32_t, int ]
      cast_input: [ true, true ]
      output: [ ToString(args) ]


clearbit:
  help: "[reg address in hex] [bit index]\n\tClears bit in address."
  actions:
    PUT:
      argc: 2
      exceptions:
        - condition: 'StringTo<int>(args[1]) < 0 || StringTo<int>(args[1]) > 31'
          message: '"Bit number out of range: " + args[1]'
      require_det_id: true
      function: setBit
      input: [ 'args[0]', 'args[1]' ]
      input_types: [ uint32_t, int ]
      cast_input: [ true, true ]
      output: [ ToString(args) ]


initialchecks:
  help: "[0, 1]\n\t[Mythen3][Gotthard2] Enable or disable intial compatibility and other checks at detector start up. It is enabled by default. Must come before 'hostname' command to take effect. Can be used to reprogram fpga when current firmware is incompatible.\n\tAdvanced User function!"
  actions:
    GET:
      argc: 0
      check_det_id: true
      function: getInitialChecks
      output: [ t ]
    PUT:
      argc: 1
      check_det_id: true
      function: setInitialChecks
      input: [ 'args[0]' ]
      input_types: [ bool ]
      cast_input: [ true ]
      output: [ args.front() ]


user:
  help: "\n\tUser details from shared memory (hostname, type, PID, User, Date)."
  actions:
    GET:
      argc: 0
      check_det_id: true
      function: getUserDetails
      output: [ t ]

patlimits:
  help: "[start addr] [stop addr] \n\t[Ctb][Mythen3] Limits of complete pattern"
  actions:
    GET:
      argc: -1
      function: getPatternLoopAddresses
      output: [ "OutStringHex(t, 4)" ]
      input: [ '"-1"' ]
      input_types: [ int ]
      cast_input: [ true ]
      require_det_id: true
    PUT:
      argc: -1
      function: setPatternLoopAddresses
      input: [ '"-1"', 'args[0]', 'args[1]' ]
      input_types: [ int, int, int ]
      cast_input: [ true, true, true ]
      require_det_id: true
      output: [ "'['" , "ToStringHex(StringTo<int>(args[0]), 4)" , '", "' , "ToStringHex(StringTo<int>(args[1]), 4)", "']'" ]


patloop:
  help: "[0-6] [start addr] [stop addr] \n\t[Ctb][Mythen3] Limits of the loop level provided.\n\t[Mythen3] Level options: 0-3 only."
  actions:
    GET:
      argc: -1
      pattern_command:
        command_name: patloop
        nGetArgs: 0
        nPutArgs: 2
      function: getPatternLoopAddresses
      input: [ level ]
      input_types: [ int ]
      cast_input: [ false ]
      output: [ "OutStringHex(t, 4)" ]
      require_det_id: true
    PUT:
      argc: -1

      extra_variables:
        - name: start
          type: int
          value: "StringTo<int>(args[iArg++])"
        - name: stop
          type: int
          value: "StringTo<int>(args[iArg++])"
      pattern_command:
        command_name: patloop
        nGetArgs: 0
        nPutArgs: 2
      function: setPatternLoopAddresses
      input: [ level, start, stop ]
      require_det_id: true
      input_types: [ int, int, int ]
      output: [ "'['" , "ToStringHex(start, 4)" , '", "' , "ToStringHex(stop, 4)", "']'" ]


patloop0:
    help: "Depreciated command. Use patloop."
    inherit_actions: patloop

patloop1:
    help: "Depreciated command. Use patloop."
    inherit_actions: patloop

patloop2:
    help: "Depreciated command. Use patloop."
    inherit_actions: patloop

patnloop:
  help: "[0-6] [n_cycles] \n\t[Ctb][Mythen3] Number of cycles of the loop level provided.\n\t[Mythen3] Level options: 0-3 only."
  actions:
    GET:
      argc: -1
      pattern_command:
        command_name: patnloop
        nGetArgs: 0
        nPutArgs: 1
      function: getPatternLoopCycles
      input: [ level ]
      input_types: [ int ]
      cast_input: [ false ]
      output: [ "OutString(t)" ]
      require_det_id: true
    PUT:
      argc: -1
      extra_variables:
        - name: nloops
          type: std::string
          value: "args[iArg++]"
      pattern_command:
        command_name: patnloop
        nGetArgs: 0
        nPutArgs: 1
      function: setPatternLoopCycles
      input: [ level, nloops ]
      require_det_id: true
      input_types: [ int, int ]
      cast_input: [ false, true ]
      output: [ nloops ]

patnloop0:
    help: "Depreciated command. Use patnloop."
    inherit_actions: patnloop

patnloop1:
    help: "Depreciated command. Use patnloop."
    inherit_actions: patnloop

patnloop2:
    help: "Depreciated command. Use patnloop."
    inherit_actions: patnloop

patwait:
  help: "[0-6] [addr] \n\t[Ctb][Mythen3] Wait address for loop level provided. \n\t[Mythen3] Level options: 0-3 only."
  actions:
    GET:
      argc: -1
      pattern_command:
        command_name: patwait
        nGetArgs: 0
        nPutArgs: 1
      function: getPatternWaitAddr
      input: [ level ]
      input_types: [ int ]
      cast_input: [ false ]
      output: [ "OutStringHex(t, 4)" ]
      require_det_id: true
    PUT:
      argc: -1
      extra_variables:
        - name: addr
          type: int
          value: "StringTo<int>(args[iArg++])"
      pattern_command:
        command_name: patwait
        nGetArgs: 0
        nPutArgs: 1
      function: setPatternWaitAddr
      input: [ level, addr ]
      require_det_id: true
      input_types: [ int, int ]
      output: [ "ToStringHex(addr, 4)" ]


patwait0:
    help: "Depreciated command. Use patwait."
    inherit_actions: patwait

patwait1:
    help: "Depreciated command. Use patwait."
    inherit_actions: patwait

patwait2:
    help: "Depreciated command. Use patwait."
    inherit_actions: patwait




patwaittime:
  help: "[0-6] [n_clk] \n\t[Ctb][Mythen3] Wait time in clock cycles for the loop provided.\n\t[Mythen3] Level options: 0-3 only."
  actions:
    GET:
      argc: -1
      pattern_command:
        command_name: patwaittime
        nGetArgs: 0
        nPutArgs: 1
      function: getPatternWaitTime
      input: [ level ]
      input_types: [ int ]
      cast_input: [ false ]
      output: [ "OutString(t)" ]
      require_det_id: true
    PUT:
      argc: -1
      extra_variables:
        - name: waittime
          type: uint64_t
          value: "StringTo<uint64_t>(args[iArg++])"
      pattern_command:
        command_name: patwaittime
        nGetArgs: 0
        nPutArgs: 1
      function: setPatternWaitTime
      input: [ level, waittime, "{det_id}" ]
      input_types: [ int, int, auto ]
      output: [ "waittime" ]

patwaittime0:
    help: "Depreciated command. Use patwaittime."
    inherit_actions: patwaittime

patwaittime1:
    help: "Depreciated command. Use patwaittime."
    inherit_actions: patwaittime

patwaittime2:
    help: "Depreciated command. Use patwaittime."
    inherit_actions: patwaittime

######################### description only commands #############################
## code is generated for these commands
hostname:
  is_description: true
  actions:
    GET:
      argc: 0
    PUT:
      argc: -1
      arg_types: [ std::string ]

acquire:
  is_description: true
  actions:
    GET:
      argc: 0
    PUT:
      argc: 0

versions:
  is_description: true
  actions:
    GET:
      argc: 0

threshold:
    is_description: true
    actions:
        GET:
          argc: 0
        PUT:
          args:
            - argc: 1
              arg_types: [ int ]
            - argc: 2
              arg_types: [ int, defs::detectorSettings ]
            - argc: 3
              arg_types: [ int,int,int ]
            - argc: 4
              arg_types: [ int ,int,int,defs::detectorSettings]
thresholdnotb:
  is_description: true
  duplicate_function: true
  function_alias: threshold
  actions:
    GET:
      argc: 0
    PUT:
      args:
        - argc: 1
          arg_types: [ int ]
        - argc: 2
          arg_types: [ int, defs::detectorSettings ]
        - argc: 3
          arg_types: [ int,int,int ]
        - argc: 4
          arg_types: [ int ,int,int,defs::detectorSettings ]


trimen:
    is_description: true
    actions:
        GET:
          argc: 0
        PUT:
          argc: -1

badchannels:
  is_description: true
  actions:
    GET:
      argc: 1
      arg_types: [ std::string ]
    PUT:
      argc: -1

udp_srcip:
    is_description: true
    actions:
        GET:
          argc: 0
        PUT:
          argc: 1
          arg_types: [ std::string ]


udp_srcip2:
    is_description: true
    actions:
        GET:
          argc: 0
        PUT:
          argc: 1
          arg_types: [ std::string ]

udp_dstip:
    is_description: true
    actions:
        GET:
          argc: 0
        PUT:
          argc: 1
          arg_types: [ std::string ]

udp_dstip2:
    is_description: true
    actions:
        GET:
          argc: 0
        PUT:
          argc: 1
          arg_types: [ std::string ]


rx_hostname:
    is_description: true
    actions:
        GET:
          argc: 0
        PUT:
          argc: -1

rx_roi:
    is_description: true
    actions:
        GET:
          argc: 0
        PUT:
          args:
            - argc: 2
              arg_types: [ int, int ]
            - argc: 4
              arg_types: [ int, int, int, int ]

ratecorr:
    is_description: true
    actions:
        GET:
          argc: 0
        PUT:
          argc: 1
          arg_types: [ int ]


burstmode:
    is_description: true
    actions:
        GET:
          argc: 0
        PUT:
          argc: 1
          arg_types: [ defs::burstMode ]

vetostream:
    is_description: true
    actions:
        GET:
          argc: 0
        PUT:
          argc: -1

counters:
    is_description: true
    actions:
        GET:
          argc: 0
        PUT:
          argc: -1

samples:
    is_description: true
    actions:
        GET:
          argc: 0
        PUT:
          argc: 1
          arg_types: [ int ]

slowadc:
    is_description: true
    actions:
        GET:
          argc: 1
          arg_types: [ int ]

rx_dbitlist:
    is_description: true
    actions:
        GET:
          argc: 0
        PUT:
          argc: -1

rx_jsonaddheader:
    is_description: true
    actions:
        GET:
          argc: 0
        PUT:
          argc: -1
execcommand:
    is_description: true
    actions:
        PUT:
          argc: -1

dacvalues:
    is_description: true
    actions:
        GET:
          args:
            - argc: 0
            - argc: 1
              arg_types: [ special::mv ]


currentsource:
    is_description: true
    actions:
        GET:
          argc: 0
        PUT:
          args:
            - argc: 1
              arg_types: [ bool ]
            - argc: 3
              arg_types: [ bool, special::currentSourceFix, int ]
            - argc: 4
              arg_types: [bool, special::currentSourceFix, int, special::currentSourceLow ]

gaincaps:
    is_description: true
    actions:
        GET:
          argc: 0
        PUT:
          argc: -1
          arg_types: [ defs::defs::M3_GainCaps ]