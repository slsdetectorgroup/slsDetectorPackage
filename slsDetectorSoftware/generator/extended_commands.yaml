acquire:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: true
    PUT:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: false
  command_name: acquire
  function_alias: acquire
  help: ''
  infer_action: true
  is_description: true
activate:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getActive
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - bool
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setActive
        input:
        - args[0]
        input_types:
        - bool
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: activate
  function_alias: activate
  help: "[0, 1]\n\t[Eiger] 1 is default. 0 deactivates readout and does not send data."
  infer_action: true
  template: true
adcclk:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getADCClock
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setADCClock
        input:
        - args[0]
        input_types:
        - int
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: adcclk
  function_alias: adcclk
  help: "[n_clk in MHz]\n\t[Ctb] ADC clock frequency in MHz."
  infer_action: true
  template: true
adcenable:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getADCEnableMask
        input: []
        input_types: []
        output:
        - OutStringHex(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - uint32_t
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setADCEnableMask
        input:
        - args[0]
        input_types:
        - uint32_t
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: adcenable
  function_alias: adcenable
  help: "[bitmask]\n\t[Ctb] ADC Enable Mask for 1Gb Enable for each 32 ADC channel."
  infer_action: true
  template: true
adcenable10g:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getTenGigaADCEnableMask
        input: []
        input_types: []
        output:
        - OutStringHex(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - uint32_t
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setTenGigaADCEnableMask
        input:
        - args[0]
        input_types:
        - uint32_t
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: adcenable10g
  function_alias: adcenable10g
  help: "[bitmask]\n\t[Ctb] ADC Enable Mask for 10Gb mode for each 32 ADC channel.\
    \ However, if any of a consecutive 4 bits are enabled, the complete 4 bits are\
    \ enabled."
  infer_action: true
  template: true
adcindex:
  actions:
    GET:
      args:
      - arg_types:
        - std::string
        argc: 1
        cast_input:
        - false
        check_det_id: true
        convert_det_id: true
        exceptions:
        - condition: det->getDetectorType().squash(defs::GENERIC) != defs::CHIPTESTBOARD
            && det->getDetectorType().squash(defs::GENERIC) != defs::XILINX_CHIPTESTBOARD
          message: cmd + " only allowed for CTB."
        function: getAdcIndex
        input:
        - args[0]
        input_types:
        - std::string
        output:
        - static_cast<int>(t)
        require_det_id: false
        store_result_in_t: true
  command_name: adcindex
  function_alias: adcindex
  help: "[name] \n\t\t[Ctb][Xilinx_Ctb] Get the adc index for the given name."
  infer_action: true
  template: true
adcinvert:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getADCInvert
        input: []
        input_types: []
        output:
        - OutStringHex(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - uint32_t
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setADCInvert
        input:
        - args[0]
        input_types:
        - uint32_t
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: adcinvert
  function_alias: adcinvert
  help: "[bitmask]\n\t[Ctb][Jungfrau][Moench] ADC Inversion Mask.\n\t[Jungfrau][Moench]\
    \ Inversions on top of the default mask."
  infer_action: true
  template: true
adclist:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: true
        convert_det_id: true
        exceptions:
        - condition: cmd != "daclist" && det_type != defs::CHIPTESTBOARD && det_type
            != defs::XILINX_CHIPTESTBOARD
          message: cmd + " only allowed for CTB."
        extra_variables:
        - name: det_type
          type: auto
          value: det->getDetectorType().squash(defs::GENERIC);
        function: getAdcNames
        input: []
        input_types: []
        output:
        - ToString(t)
        require_det_id: false
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - std::string
        argc: -1
        cast_input:
        - false
        check_det_id: true
        convert_det_id: true
        exceptions:
        - condition: cmd != "daclist" && det_type != defs::CHIPTESTBOARD && det_type
            != defs::XILINX_CHIPTESTBOARD
          message: cmd + " only allowed for CTB."
        - condition: cmd == "daclist" && det_type != defs::CHIPTESTBOARD && det_type
            != defs::XILINX_CHIPTESTBOARD
          message: '"This detector already has fixed dac names. Cannot change them."'
        extra_variables:
        - name: det_type
          type: auto
          value: det->getDetectorType().squash(defs::GENERIC);
        function: setAdcNames
        input:
        - args
        input_types:
        - std::string
        output:
        - ToString(args)
        require_det_id: false
        store_result_in_t: false
  command_name: adclist
  function_alias: adclist
  help: "[adcname1 adcname2 .. adcname32] \n\t\t[Ctb][Xilinx_Ctb] Set the list of\
    \ adc names for this board."
  infer_action: true
  template: true
adcname:
  actions:
    GET:
      args:
      - arg_types:
        - int
        argc: 1
        cast_input:
        - true
        check_det_id: true
        convert_det_id: true
        exceptions:
        - condition: det->getDetectorType().squash(defs::GENERIC) != defs::CHIPTESTBOARD
            && det->getDetectorType().squash(defs::GENERIC) != defs::XILINX_CHIPTESTBOARD
          message: cmd + " only allowed for CTB."
        function: getAdcName
        input:
        - args[0]
        input_types:
        - int
        output:
        - args[0]
        - ''' '''
        - t
        require_det_id: false
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        - std::string
        argc: 2
        cast_input:
        - true
        - false
        check_det_id: true
        convert_det_id: true
        exceptions:
        - condition: det->getDetectorType().squash(defs::GENERIC) != defs::CHIPTESTBOARD
            && det->getDetectorType().squash(defs::GENERIC) != defs::XILINX_CHIPTESTBOARD
          message: cmd + " only allowed for CTB."
        function: setAdcName
        input:
        - args[0]
        - args[1]
        input_types:
        - int
        - std::string
        output:
        - ToString(args)
        require_det_id: false
        store_result_in_t: false
  command_name: adcname
  function_alias: adcname
  help: "[0-31][name] \n\t\t[Ctb][Xilinx_Ctb] Set the adc at the given position to\
    \ the given name."
  infer_action: true
  template: true
adcphase:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        exceptions:
        - condition: det_type == defs::EIGER || det_type == defs::MYTHEN3 || det_type
            == defs::GOTTHARD2
          message: '"adcphase not implemented for this detector"'
        extra_variables:
        - name: det_type
          type: auto
          value: det->getDetectorType().squash(defs::GENERIC);
        function: getADCPhase
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
      - arg_types:
        - special::deg
        argc: 1
        cast_input: []
        check_det_id: false
        convert_det_id: true
        exceptions:
        - condition: det_type == defs::EIGER || det_type == defs::MYTHEN3 || det_type
            == defs::GOTTHARD2
          message: '"adcphase not implemented for this detector"'
        - condition: args[0] != "deg"
          message: '"Unknown adcphase   argument " + args[0] + ". Did you mean deg?    "'
        extra_variables:
        - name: det_type
          type: auto
          value: det->getDetectorType().squash(defs::GENERIC);
        function: getADCPhaseInDegrees
        input: []
        input_types: []
        output:
        - OutString(t)
        - '" deg"'
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        exceptions:
        - condition: det_type == defs::EIGER || det_type == defs::MYTHEN3 || det_type
            == defs::GOTTHARD2
          message: '"adcphase not implemented for this detector"'
        extra_variables:
        - name: det_type
          type: auto
          value: det->getDetectorType().squash(defs::GENERIC);
        function: setADCPhase
        input:
        - args[0]
        input_types:
        - int
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
      - arg_types:
        - int
        - special::deg
        argc: 2
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        exceptions:
        - condition: det_type == defs::EIGER || det_type == defs::MYTHEN3 || det_type
            == defs::GOTTHARD2
          message: '"adcphase not implemented for this detector"'
        - condition: args[1] != "deg"
          message: '"Unknown adcphase 2nd argument " + args[1] + ". Did you mean deg?"'
        extra_variables:
        - name: det_type
          type: auto
          value: det->getDetectorType().squash(defs::GENERIC);
        function: setADCPhaseInDegrees
        input:
        - args[0]
        input_types:
        - int
        output:
        - args[0]
        - ''' '''
        - args[1]
        require_det_id: true
        store_result_in_t: false
  command_name: adcphase
  function_alias: adcphase
  help: "[n_value] [(optional)deg]\n\t[Jungfrau][Moench][Ctb][Gotthard] Phase shift\
    \ of ADC clock. \n\t[Jungfrau][Moench] Absolute phase shift. If deg used, then\
    \ shift in degrees. Changing Speed also resets adcphase to recommended defaults.\n\
    \t[Ctb] Absolute phase shift. If deg used, then shift in degrees. Changing adcclk\
    \ also resets adcphase and sets it to previous values.\n\t[Gotthard] Relative\
    \ phase shift. Cannot get"
  infer_action: true
adcpipeline:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getADCPipeline
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setADCPipeline
        input:
        - args[0]
        input_types:
        - int
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: adcpipeline
  function_alias: adcpipeline
  help: "[n_value]\n\t[Ctb][Moench] Pipeline for ADC clock."
  infer_action: true
  template: true
adcreg:
  actions:
    PUT:
      args:
      - arg_types:
        - uint32_t
        - uint32_t
        argc: 2
        cast_input:
        - true
        - true
        check_det_id: false
        convert_det_id: true
        function: writeAdcRegister
        input:
        - args[0]
        - args[1]
        input_types:
        - uint32_t
        - uint32_t
        output:
        - ToString(args)
        require_det_id: true
        store_result_in_t: false
  command_name: adcreg
  function_alias: adcreg
  help: "[address] [value]\n\t[Jungfrau][Moench][Ctb][Gotthard] Writes to an adc register\
    \ in hex. Advanced user Function!"
  infer_action: true
adcvpp:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: getADCVpp
        input:
        - '"0"'
        input_types:
        - bool
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
      - arg_type:
        - special::mv
        arg_types:
        - bool
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        exceptions:
        - condition: (args[0] != "mv") && (args[0] != "mV")
          message: '"Unknown argument " + args[0] + ". Did you mean mV?"'
        function: getADCVpp
        input:
        - '"1"'
        input_types:
        - bool
        output:
        - OutString(t)
        - '" mV"'
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        argc: 1
        cast_input:
        - true
        - true
        check_det_id: false
        convert_det_id: true
        function: setADCVpp
        input:
        - args[0]
        - '"0"'
        input_types:
        - int
        - bool
        output:
        - args[0]
        require_det_id: true
        store_result_in_t: false
      - arg_types:
        - int
        - special::mv
        argc: 2
        cast_input:
        - true
        - true
        check_det_id: false
        convert_det_id: true
        exceptions:
        - condition: (args[1] != "mv") && (args[1] != "mV")
          message: '"Unknown argument " + args[1] + ". Did you mean mV?"'
        function: setADCVpp
        input:
        - args[0]
        - '"1"'
        input_types:
        - int
        - bool
        output:
        - args[0]
        - '" mV"'
        require_det_id: true
        store_result_in_t: false
  command_name: adcvpp
  function_alias: adcvpp
  help: "[dac or mV value][(optional unit) mV] \n\t[Ctb] Vpp of ADC.\n\t 0 -> 1V ;\
    \ 1 -> 1.14V ; 2 -> 1.33V ; 3 -> 1.6V ; 4 -> 2V. \n\tAdvanced User function!"
  infer_action: true
apulse:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getAnalogPulsing
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - bool
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setAnalogPulsing
        input:
        - args[0]
        input_types:
        - bool
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: apulse
  function_alias: apulse
  help: "[0, 1]\n\t[Mythen3] Enables or disables analog pulsing. Default is disabled"
  infer_action: true
  template: true
asamples:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getNumberOfAnalogSamples
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setNumberOfAnalogSamples
        input:
        - args[0]
        input_types:
        - int
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: asamples
  function_alias: asamples
  help: "[n_samples]\n\t[Ctb] Number of analog samples expected."
  infer_action: true
  template: true
autocompdisable:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getAutoComparatorDisable
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - bool
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setAutoComparatorDisable
        input:
        - args[0]
        input_types:
        - bool
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: autocompdisable
  function_alias: autocompdisable
  help: "[0, 1]\n\t[Jungfrau] Auto comparator disable mode. By default, the on-chip\
    \ gain switching is active during the entire exposure.This mode disables the on\
    \ - chip gain switching comparator automatically after 93.75% (only for chipv1.0)\
    \ of exposure time (only for longer than 100us). It is possible to set the duration\
    \ for chipv1.1 using compdisabletime command.\n\tDefault is 0 or this mode disabled(comparator\
    \ enabled throughout). 1 enables mode. 0 disables mode. "
  infer_action: true
  template: true
badchannels:
  actions:
    GET:
      args:
      - arg_types:
        - std::string
        argc: 1
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: true
    PUT:
      args:
      - arg_types: []
        argc: -1
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: false
  command_name: badchannels
  function_alias: badchannels
  help: ''
  infer_action: true
  is_description: true
blockingtrigger:
  actions:
    PUT:
      args:
      - arg_types: []
        argc: 0
        cast_input:
        - false
        check_det_id: true
        convert_det_id: true
        extra_variables:
        - name: block
          type: bool
          value: 'true'
        function: sendSoftwareTrigger
        input:
        - block
        input_types:
        - bool
        output:
        - '"successful"'
        require_det_id: false
        store_result_in_t: false
  command_name: blockingtrigger
  function_alias: blockingtrigger
  help: "\n\t[Eiger][Jungfrau][Moench] Sends software trigger signal to detector and\
    \ blocks till the frames are sent out for that trigger."
  infer_action: true
  template: true
burstmode:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - defs::burstMode
        argc: 1
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: false
  command_name: burstmode
  function_alias: burstmode
  help: ''
  infer_action: true
  is_description: true
burstperiod:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getBurstPeriod
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
      - arg_types:
        - special::time_unit
        argc: 1
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getBurstPeriod
        input: []
        input_types: []
        output:
        - OutString(t , args[0])
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - std::string
        argc: 1
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: setBurstPeriod
        input:
        - converted_time
        input_types:
        - time::ns
        output:
        - args[0]
        require_det_id: true
        separate_time_units:
          input: args[0]
          output:
          - converted_time
          - unit
        store_result_in_t: false
      - arg_types:
        - int
        - special::time_unit
        argc: 2
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        convert_to_time:
          input:
          - args[0]
          - args[1]
          output: converted_time
        function: setBurstPeriod
        input:
        - converted_time
        input_types:
        - time::ns
        output:
        - args[0]
        - args[1]
        require_det_id: true
        store_result_in_t: false
  command_name: burstperiod
  function_alias: burstperiod
  help: "[duration] [(optional unit) ns|us|ms|s]\n\t[Gotthard2] Period between 2 bursts.\
    \ Only in burst mode and auto timing mode."
  infer_action: true
  template: true
bursts:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getNumberOfBursts
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int64_t
        argc: 1
        cast_input:
        - true
        check_det_id: true
        convert_det_id: true
        function: setNumberOfBursts
        input:
        - args[0]
        input_types:
        - int64_t
        output:
        - args.front()
        require_det_id: false
        store_result_in_t: false
  command_name: bursts
  function_alias: bursts
  help: "[n_bursts]\n\t[Gotthard2] Number of bursts per aquire. Only in auto timing\
    \ mode and burst mode. Use timing command to set timing mode and burstmode command\
    \ to set burst mode."
  infer_action: true
  template: true
burstsl:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getNumberOfBurstsLeft
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
  command_name: burstsl
  function_alias: burstsl
  help: "\n\t[Gotthard2] Number of bursts left in acquisition. Only in burst auto\
    \ mode."
  infer_action: true
  template: true
bustest:
  actions:
    PUT:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: executeBusTest
        input: []
        input_types: []
        output:
        - '"successful"'
        require_det_id: true
        store_result_in_t: false
  command_name: bustest
  function_alias: bustest
  help: "\n\t[Jungfrau][Moench][Gotthard][Mythen3][Gotthard2][Ctb] Bus test, ie. Writes\
    \ different values in a R/W register and confirms the writes to check bus.\n\t\
    Advanced User function!"
  infer_action: true
  template: true
cdsgain:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getCDSGain
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - bool
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setCDSGain
        input:
        - args[0]
        input_types:
        - bool
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: cdsgain
  function_alias: cdsgain
  help: "[0, 1]\n\t[Gotthard2] Enable or disable CDS gain. Default is disabled."
  infer_action: true
  template: true
chipversion:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getChipVersion
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
  command_name: chipversion
  function_alias: chipversion
  help: "\n\t[Jungfrau] Returns chip version. Can be 1.0 or 1.1"
  infer_action: true
  template: true
clearbit:
  actions:
    PUT:
      args:
      - arg_types:
        - uint32_t
        - int
        argc: 2
        cast_input:
        - true
        - true
        - true
        check_det_id: false
        convert_det_id: true
        exceptions:
        - condition: StringTo<int>(args[1]) < 0 || StringTo<int>(args[1]) > 31
          message: '"Bit number out of range: " + args[1]'
        function: clearBit
        input:
        - args[0]
        - args[1]
        - '"0"'
        input_types:
        - uint32_t
        - int
        - bool
        output:
        - '"["'
        - args[0]
        - '", "'
        - args[1]
        - '"]"'
        require_det_id: true
        store_result_in_t: false
      - arg_types:
        - uint32_t
        - int
        - special::validate
        argc: 3
        cast_input:
        - true
        - true
        - true
        check_det_id: false
        convert_det_id: true
        exceptions:
        - condition: StringTo<int>(args[1]) < 0 || StringTo<int>(args[1]) > 31
          message: '"Bit number out of range: " + args[1]'
        - condition: args[2] != "--validate"
          message: '"Could not scan third argument. Did you mean --validate?"'
        function: clearBit
        input:
        - args[0]
        - args[1]
        - '"1"'
        input_types:
        - uint32_t
        - int
        - bool
        output:
        - '"["'
        - args[0]
        - '", "'
        - args[1]
        - '"]"'
        require_det_id: true
        store_result_in_t: false
  command_name: clearbit
  function_alias: clearbit
  help: "[reg address in hex] [bit index]\n\tClears bit in address.\n\tUse --validate\
    \ to force validation."
  infer_action: true
  template: true
clearbusy:
  actions:
    PUT:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: true
        convert_det_id: true
        function: clearAcquiringFlag
        input: []
        input_types: []
        output:
        - '"successful"'
        require_det_id: false
        store_result_in_t: false
  command_name: clearbusy
  function_alias: clearbusy
  help: "\n\tIf acquisition aborted during acquire command, use this to clear acquiring\
    \ flag in shared memory before starting next acquisition"
  infer_action: true
  template: true
clearroi:
  actions:
    PUT:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: clearROI
        input: []
        input_types: []
        output:
        - '"successful"'
        require_det_id: true
        store_result_in_t: false
  command_name: clearroi
  function_alias: clearroi
  help: "\n\t[Gotthard] Resets Region of interest in detector. All channels enabled.\
    \ Default is all channels enabled."
  infer_action: true
  template: true
clientversion:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getClientVersion
        input: []
        input_types: []
        output:
        - t
        require_det_id: false
        store_result_in_t: true
  command_name: clientversion
  function_alias: clientversion
  help: "\n\tClient software version"
  infer_action: true
clkdiv:
  actions:
    GET:
      args:
      - arg_types:
        - int
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        exceptions:
        - condition: type != defs::GOTTHARD2 && type != defs::MYTHEN3
          message: '"clkdiv not implemented for this detector."'
        extra_variables:
        - name: type
          type: defs::detectorType
          value: det->getDetectorType().squash(defs::GENERIC);
        function: getClockDivider
        input:
        - args[0]
        input_types:
        - int
        output:
        - args[0]
        - ''' '''
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        - int
        argc: 2
        cast_input:
        - true
        - true
        check_det_id: false
        convert_det_id: true
        exceptions:
        - condition: type != defs::GOTTHARD2 && type != defs::MYTHEN3
          message: '"clkdiv not implemented for this detector."'
        extra_variables:
        - name: type
          type: defs::detectorType
          value: det->getDetectorType().squash(defs::GENERIC);
        function: setClockDivider
        input:
        - args[0]
        - args[1]
        input_types:
        - int
        - int
        output:
        - args[0]
        - ''' '''
        - args[1]
        require_det_id: true
        store_result_in_t: false
  command_name: clkdiv
  function_alias: clkdiv
  help: "[n_clock] [n_divider]\n\t[Gotthard2][Mythen3] Clock Divider of clock n_clock.\
    \ Must be greater than 1.\n\t[Gotthard2] Clock index range: 0-5\n\t[Mythen3] Clock\
    \ index range: 0"
  infer_action: true
clkfreq:
  actions:
    GET:
      args:
      - arg_types:
        - int
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        exceptions:
        - condition: type != defs::GOTTHARD2 && type != defs::MYTHEN3
          message: '"clkfreq not implemented for this detector."'
        extra_variables:
        - name: type
          type: defs::detectorType
          value: det->getDetectorType().squash(defs::GENERIC);
        function: getClockFrequency
        input:
        - args[0]
        input_types:
        - int
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
  command_name: clkfreq
  function_alias: clkfreq
  help: "[n_clock] [freq_in_Hz]\n\t[Gotthard2][Mythen3] Frequency of clock n_clock\
    \ in Hz. Use clkdiv to set frequency.\n\t[Gotthard2] Clock index range: 0-5\n\t\
    [Mythen3] Clock index range: 0"
  infer_action: true
clkphase:
  actions:
    GET:
      args:
      - arg_types:
        - int
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        exceptions:
        - condition: type != defs::GOTTHARD2 && type != defs::MYTHEN3
          message: '"clkphase not implemented for this detector."'
        extra_variables:
        - name: type
          type: defs::detectorType
          value: det->getDetectorType().squash(defs::GENERIC);
        function: getClockPhase
        input:
        - args[0]
        input_types:
        - int
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
      - arg_types:
        - int
        - special::deg
        argc: 2
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        exceptions:
        - condition: type != defs::GOTTHARD2 && type != defs::MYTHEN3
          message: '"clkphase not implemented for this detector."'
        - condition: args[1] != "deg"
          message: '"Cannot scan argument" + args[1] + ". Did you mean deg?"'
        extra_variables:
        - name: type
          type: defs::detectorType
          value: det->getDetectorType().squash(defs::GENERIC);
        function: getClockPhaseinDegrees
        input:
        - args[0]
        input_types:
        - int
        output:
        - OutString(t)
        - '" deg"'
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        - int
        argc: 2
        cast_input:
        - true
        - true
        check_det_id: false
        convert_det_id: true
        exceptions:
        - condition: type != defs::GOTTHARD2 && type != defs::MYTHEN3
          message: '"clkphase not implemented for this detector."'
        extra_variables:
        - name: type
          type: defs::detectorType
          value: det->getDetectorType().squash(defs::GENERIC);
        function: setClockPhase
        input:
        - args[0]
        - args[1]
        input_types:
        - int
        - int
        output:
        - args[1]
        require_det_id: true
        store_result_in_t: false
      - arg_types:
        - int
        - int
        - special::deg
        argc: 3
        cast_input:
        - true
        - true
        check_det_id: false
        convert_det_id: true
        exceptions:
        - condition: type != defs::GOTTHARD2 && type != defs::MYTHEN3
          message: '"clkphase not implemented for this detector."'
        - condition: args[2] != "deg"
          message: '"Cannot scan argument" + args[2] + ". Did you mean deg?"'
        extra_variables:
        - name: type
          type: defs::detectorType
          value: det->getDetectorType().squash(defs::GENERIC);
        function: setClockPhaseinDegrees
        input:
        - args[0]
        - args[1]
        input_types:
        - int
        - int
        output:
        - args[1]
        - '" "'
        - args[2]
        require_det_id: true
        store_result_in_t: false
  command_name: clkphase
  function_alias: clkphase
  help: "[n_clock] [phase] [deg (optional)]\n\t[Gotthard2][Mythen3] Phase of clock\
    \ n_clock. If deg, then phase shift in degrees, else absolute phase shift values.n\t\
    [Gotthard2] Clock index range: 0-5\n\t[Mythen3] Clock index range: 0"
  infer_action: true
collectionmode:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getCollectionMode
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - defs::collectionMode
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setCollectionMode
        input:
        - args[0]
        input_types:
        - defs::collectionMode
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: collectionmode
  function_alias: collectionmode
  help: "[hole|electron]\n\t[Jungfrau] Sets collection mode to hole or electron. Default\
    \ is hole."
  infer_action: true
  template: true
column:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getColumn
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setColumn
        input:
        - args[0]
        input_types:
        - int
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: column
  function_alias: column
  help: "[value]\n\tSet Detector column (udp header) to value. \n\tGui uses it to\
    \ rearrange for complete image"
  infer_action: true
  template: true
compdisabletime:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getComparatorDisableTime
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
      - arg_types:
        - special::time_unit
        argc: 1
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getComparatorDisableTime
        input: []
        input_types: []
        output:
        - OutString(t , args[0])
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - std::string
        argc: 1
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: setComparatorDisableTime
        input:
        - converted_time
        input_types:
        - time::ns
        output:
        - args[0]
        require_det_id: true
        separate_time_units:
          input: args[0]
          output:
          - converted_time
          - unit
        store_result_in_t: false
      - arg_types:
        - int
        - special::time_unit
        argc: 2
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        convert_to_time:
          input:
          - args[0]
          - args[1]
          output: converted_time
        function: setComparatorDisableTime
        input:
        - converted_time
        input_types:
        - time::ns
        output:
        - args[0]
        - args[1]
        require_det_id: true
        store_result_in_t: false
  command_name: compdisabletime
  function_alias: compdisabletime
  help: "[duration] [(optional unit) ns|us|ms|s]\n\t[Jungfrau] Time before end of\
    \ exposure when comparator is disabled. It is only possible for chipv1.1."
  infer_action: true
  template: true
confadc:
  actions:
    GET:
      args:
      - arg_types:
        - int
        - int
        argc: 2
        cast_input:
        - true
        - true
        check_det_id: false
        convert_det_id: true
        function: getADCConfiguration
        input:
        - args[0]
        - args[1]
        input_types:
        - int
        - int
        output:
        - OutStringHex(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        - int
        - int
        argc: 3
        cast_input:
        - true
        - true
        - true
        check_det_id: false
        convert_det_id: true
        function: setADCConfiguration
        input:
        - args[0]
        - args[1]
        - args[2]
        input_types:
        - int
        - int
        - int
        output:
        - '''['''
        - args[0]
        - '", "'
        - args[1]
        - '", "'
        - ToStringHex( StringTo<int>(args[2]))
        - '"]"'
        require_det_id: true
        store_result_in_t: false
  command_name: confadc
  function_alias: confadc
  help: "[chip index 0-9, -1 for all] [adc index 0-31, -1 for all] [7 bit configuration\
    \ value in hex]\n\t[Gotthard2] Sets  configuration for specific chip and adc,\
    \ but configures 1 chip (all adcs for that chip) at a time."
  infer_action: true
config:
  actions:
    PUT:
      args:
      - arg_types:
        - special::path
        argc: 1
        cast_input:
        - false
        check_det_id: true
        convert_det_id: true
        function: loadConfig
        input:
        - args[0]
        input_types:
        - std::string
        output:
        - args.front()
        require_det_id: false
        store_result_in_t: false
  command_name: config
  function_alias: config
  help: "\n\tFrees shared memory before loading configuration file. Set up once."
  infer_action: true
  template: true
configtransceiver:
  actions:
    PUT:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: configureTransceiver
        input: []
        input_types: []
        output:
        - '"successful"'
        require_det_id: true
        store_result_in_t: false
  command_name: configtransceiver
  function_alias: configtransceiver
  help: "\n\t[Xilinx Ctb] Waits for transceiver to be aligned. Chip had to be configured\
    \ (powered on) before this."
  infer_action: true
  template: true
counters:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: true
    PUT:
      args:
      - arg_types: []
        argc: -1
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: false
  command_name: counters
  function_alias: counters
  help: ''
  infer_action: true
  is_description: true
currentsource:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - bool
        argc: 1
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: false
      - arg_types:
        - bool
        - special::currentSourceFix
        - int
        argc: 3
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: false
      - arg_types:
        - bool
        - special::currentSourceFix
        - int
        - special::currentSourceLow
        argc: 4
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: false
  command_name: currentsource
  function_alias: currentsource
  help: ''
  infer_action: true
  is_description: true
dac:
  actions:
    GET:
      args:
      - arg_types:
        - defs::dacIndex
        argc: 1
        cast_input:
        - false
        - true
        check_det_id: false
        convert_det_id: true
        exceptions:
        - condition: is_int(args[0]) && det->getDetectorType().squash() != defs::CHIPTESTBOARD
            && det->getDetectorType().squash() != defs::XILINX_CHIPTESTBOARD
          message: '"Dac indices can only be used for chip test board. Use daclist
            to get list of dac names for current detector."'
        extra_variables:
        - name: dacIndex
          type: defs::dacIndex
          value: '((det->getDetectorType().squash() == defs::CHIPTESTBOARD || det->getDetectorType().squash()
            == defs::XILINX_CHIPTESTBOARD) && !is_int(args[0])) ? det->getDacIndex(args[0])
            : StringTo<defs::dacIndex>(args[0])'
        function: getDAC
        input:
        - dacIndex
        - '"0"'
        input_types:
        - defs::dacIndex
        - bool
        output:
        - args[0]
        - ''' '''
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
      - arg_types:
        - defs::dacIndex
        - special::mv
        argc: 2
        cast_input:
        - false
        - true
        check_det_id: false
        convert_det_id: true
        exceptions:
        - condition: is_int(args[0]) && det->getDetectorType().squash() != defs::CHIPTESTBOARD
            && det->getDetectorType().squash() != defs::XILINX_CHIPTESTBOARD
          message: '"Dac indices can only be used for chip test board. Use daclist
            to get list of dac names for current detector."'
        - condition: args[1] != "mv" && args[1] != "mV"
          message: '"Unknown argument " + args[1] + ". Did you mean mV?"'
        extra_variables:
        - name: dacIndex
          type: defs::dacIndex
          value: '((det->getDetectorType().squash() == defs::CHIPTESTBOARD || det->getDetectorType().squash()
            == defs::XILINX_CHIPTESTBOARD) && !is_int(args[0])) ? det->getDacIndex(args[0])
            : StringTo<defs::dacIndex>(args[0])'
        function: getDAC
        input:
        - dacIndex
        - '"1"'
        input_types:
        - defs::dacIndex
        - bool
        output:
        - args[0]
        - ''' '''
        - OutString(t)
        - '" mV"'
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - defs::dacIndex
        - int
        argc: 2
        cast_input:
        - false
        - true
        - true
        check_det_id: false
        convert_det_id: true
        exceptions:
        - condition: is_int(args[0]) && det->getDetectorType().squash() != defs::CHIPTESTBOARD
            && det->getDetectorType().squash() != defs::XILINX_CHIPTESTBOARD
          message: '"Dac indices can only be used for chip test board. Use daclist
            to get list of dac names for current detector."'
        extra_variables:
        - name: dacIndex
          type: defs::dacIndex
          value: '((det->getDetectorType().squash() == defs::CHIPTESTBOARD || det->getDetectorType().squash()
            == defs::XILINX_CHIPTESTBOARD) && !is_int(args[0])) ? det->getDacIndex(args[0])
            : StringTo<defs::dacIndex>(args[0])'
        function: setDAC
        input:
        - dacIndex
        - args[1]
        - '"0"'
        input_types:
        - defs::dacIndex
        - int
        - bool
        output:
        - args[0]
        - ''' '''
        - args[1]
        require_det_id: true
        store_result_in_t: false
      - arg_types:
        - defs::dacIndex
        - int
        - special::mv
        argc: 3
        cast_input:
        - false
        - true
        - true
        check_det_id: false
        convert_det_id: true
        exceptions:
        - condition: is_int(args[0]) && det->getDetectorType().squash() != defs::CHIPTESTBOARD
            && det->getDetectorType().squash() != defs::XILINX_CHIPTESTBOARD
          message: '"Dac indices can only be used for chip test board. Use daclist
            to get list of dac names for current detector."'
        extra_variables:
        - name: dacIndex
          type: defs::dacIndex
          value: '((det->getDetectorType().squash() == defs::CHIPTESTBOARD || det->getDetectorType().squash()
            == defs::XILINX_CHIPTESTBOARD) && !is_int(args[0])) ? det->getDacIndex(args[0])
            : StringTo<defs::dacIndex>(args[0])'
        function: setDAC
        input:
        - dacIndex
        - args[1]
        - '"1"'
        input_types:
        - defs::dacIndex
        - int
        - bool
        output:
        - args[0]
        - ''' '''
        - args[1]
        - '" mV"'
        require_det_id: true
        store_result_in_t: false
  command_name: dac
  function_alias: dac
  help: 'code: return GetHelpDacWrapper(cmd, args);

    '
  infer_action: true
dacindex:
  actions:
    GET:
      args:
      - arg_types:
        - std::string
        argc: 1
        cast_input:
        - false
        check_det_id: true
        convert_det_id: true
        exceptions:
        - condition: det->getDetectorType().squash(defs::GENERIC) != defs::CHIPTESTBOARD
            && det->getDetectorType().squash(defs::GENERIC) != defs::XILINX_CHIPTESTBOARD
          message: cmd + " only allowed for CTB."
        extra_variables:
        - name: index
          type: defs::dacIndex
          value: defs::DAC_0
        function: getDacIndex
        input:
        - args[0]
        input_types:
        - std::string
        output:
        - ToString(static_cast<int>(t) - index)
        require_det_id: false
        store_result_in_t: true
  command_name: dacindex
  function_alias: dacindex
  help: "[name] \n\t\t[Ctb][Xilinx_Ctb] Get the dac index for the given name."
  infer_action: true
  template: true
daclist:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: true
        convert_det_id: true
        exceptions:
        - condition: cmd != "daclist" && det_type != defs::CHIPTESTBOARD && det_type
            != defs::XILINX_CHIPTESTBOARD
          message: cmd + " only allowed for CTB."
        extra_variables:
        - name: det_type
          type: auto
          value: det->getDetectorType().squash(defs::GENERIC);
        function: getDacNames
        input: []
        input_types: []
        output:
        - ToString(t)
        require_det_id: false
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - std::string
        argc: -1
        cast_input:
        - false
        check_det_id: true
        convert_det_id: true
        exceptions:
        - condition: cmd != "daclist" && det_type != defs::CHIPTESTBOARD && det_type
            != defs::XILINX_CHIPTESTBOARD
          message: cmd + " only allowed for CTB."
        - condition: cmd == "daclist" && det_type != defs::CHIPTESTBOARD && det_type
            != defs::XILINX_CHIPTESTBOARD
          message: '"This detector already has fixed dac names. Cannot change them."'
        extra_variables:
        - name: det_type
          type: auto
          value: det->getDetectorType().squash(defs::GENERIC);
        function: setDacNames
        input:
        - args
        input_types:
        - std::string
        output:
        - ToString(args)
        require_det_id: false
        store_result_in_t: false
  command_name: daclist
  function_alias: daclist
  help: "[dacname1 dacname2 .. dacname18] \n\t\t[Ctb][Xilinx_Ctb] Set the list of\
    \ dac names for this detector.\n\t\t[All] Gets the list of dac names for every\
    \ dac for this detector."
  infer_action: true
  template: true
dacname:
  actions:
    GET:
      args:
      - arg_types:
        - defs::dacIndex
        argc: 1
        cast_input:
        - false
        check_det_id: true
        convert_det_id: true
        exceptions:
        - condition: det->getDetectorType().squash(defs::GENERIC) != defs::CHIPTESTBOARD
            && det->getDetectorType().squash(defs::GENERIC) != defs::XILINX_CHIPTESTBOARD
          message: cmd + " only allowed for CTB."
        extra_variables:
        - name: index
          type: defs::dacIndex
          value: defs::DAC_0
        function: getDacName
        input:
        - static_cast<defs::dacIndex>(StringTo<int>(args[0]) + index)
        input_types:
        - defs::dacIndex
        output:
        - args[0]
        - ''' '''
        - t
        require_det_id: false
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - defs::dacIndex
        - std::string
        argc: 2
        cast_input:
        - false
        - false
        check_det_id: true
        convert_det_id: true
        exceptions:
        - condition: det->getDetectorType().squash(defs::GENERIC) != defs::CHIPTESTBOARD
            && det->getDetectorType().squash(defs::GENERIC) != defs::XILINX_CHIPTESTBOARD
          message: cmd + " only allowed for CTB."
        extra_variables:
        - name: index
          type: defs::dacIndex
          value: defs::DAC_0
        function: setDacName
        input:
        - static_cast<defs::dacIndex>(StringTo<int>(args[0]) + index)
        - args[1]
        input_types:
        - defs::dacIndex
        - std::string
        output:
        - ToString(args)
        require_det_id: false
        store_result_in_t: false
  command_name: dacname
  function_alias: dacname
  help: "[0-17][name] \n\t\t[Ctb][Xilinx_Ctb] Set the dac at the given position to\
    \ the given name."
  infer_action: true
  template: true
dacvalues:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: true
      - arg_types:
        - special::mv
        argc: 1
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: true
  command_name: dacvalues
  function_alias: dacvalues
  help: ''
  infer_action: true
  is_description: true
datastream:
  actions:
    GET:
      args:
      - arg_types:
        - defs::portPosition
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: getDataStream
        input:
        - args[0]
        input_types:
        - defs::portPosition
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - defs::portPosition
        - bool
        argc: 2
        cast_input:
        - true
        - true
        check_det_id: false
        convert_det_id: true
        function: setDataStream
        input:
        - args[0]
        - args[1]
        input_types:
        - defs::portPosition
        - bool
        output:
        - ToString(args)
        require_det_id: true
        store_result_in_t: false
  command_name: datastream
  function_alias: datastream
  help: "[left|right] [0, 1]\n\t[Eiger] Enables or disables data streaming from left\
    \ or/and right side of detector for 10 GbE mode. 1 (enabled) by default."
  infer_action: true
dbitclk:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getDBITClock
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setDBITClock
        input:
        - args[0]
        input_types:
        - int
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: dbitclk
  function_alias: dbitclk
  help: "[n_clk in MHz]\n\t[Ctb] Clock for latching the digital bits in MHz."
  infer_action: true
  template: true
dbitphase:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        exceptions:
        - condition: det_type == defs::EIGER || det_type == defs::MYTHEN3 || det_type
            == defs::GOTTHARD2 || det_type == defs::MOENCH
          message: '"dbitphase not implemented for this detector"'
        extra_variables:
        - name: det_type
          type: auto
          value: det->getDetectorType().squash(defs::GENERIC);
        function: getDBITPhase
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
      - arg_types:
        - special::deg
        argc: 1
        cast_input: []
        check_det_id: false
        convert_det_id: true
        exceptions:
        - condition: det_type == defs::EIGER || det_type == defs::MYTHEN3 || det_type
            == defs::GOTTHARD2 || det_type == defs::MOENCH
          message: '"dbitphase not implemented for this detector"'
        - condition: args[0] != "deg"
          message: '"Unknown dbitphase argument " + args[0] + ". Did you mean deg?  "'
        extra_variables:
        - name: det_type
          type: auto
          value: det->getDetectorType().squash(defs::GENERIC);
        function: getDBITPhaseInDegrees
        input: []
        input_types: []
        output:
        - OutString(t)
        - '" deg"'
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        exceptions:
        - condition: det_type == defs::EIGER || det_type == defs::MYTHEN3 || det_type
            == defs::GOTTHARD2 || det_type == defs::MOENCH
          message: '"dbitphase not implemented for this detector"'
        extra_variables:
        - name: det_type
          type: auto
          value: det->getDetectorType().squash(defs::GENERIC);
        function: setDBITPhase
        input:
        - args[0]
        input_types:
        - int
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
      - arg_types:
        - int
        - special::deg
        argc: 2
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        exceptions:
        - condition: det_type == defs::EIGER || det_type == defs::MYTHEN3 || det_type
            == defs::GOTTHARD2 || det_type == defs::MOENCH
          message: '"dbitphase not implemented for this detector"'
        - condition: args[1] != "deg"
          message: '"Unknown dbitphase 2nd argument " + args[1] + ". Did you mean
            deg?  "'
        extra_variables:
        - name: det_type
          type: auto
          value: det->getDetectorType().squash(defs::GENERIC);
        function: setDBITPhaseInDegrees
        input:
        - args[0]
        input_types:
        - int
        output:
        - args[0]
        - ''' '''
        - args[1]
        require_det_id: true
        store_result_in_t: false
  command_name: dbitphase
  function_alias: dbitphase
  help: "[n_value] [(optional)deg]\n\t[Ctb][Jungfrau] Phase shift of clock to latch\
    \ digital bits. Absolute phase shift. If deg used, then shift in degrees. \n\t\
    [Ctb]Changing dbitclk also resets dbitphase and sets to previous values."
  infer_action: true
dbitpipeline:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getDBITPipeline
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setDBITPipeline
        input:
        - args[0]
        input_types:
        - int
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: dbitpipeline
  function_alias: dbitpipeline
  help: "[n_value]\n\t[Ctb][Gotthard2] Pipeline of the clock for latching digital\
    \ bits.\n\t[Gotthard2] Options: 0-7\n\t[Ctb] Options: 0-255"
  infer_action: true
  template: true
defaultdac:
  actions:
    GET:
      args:
      - arg_types:
        - defs::dacIndex
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: getDefaultDac
        input:
        - args[0]
        input_types:
        - defs::dacIndex
        output:
        - args[0]
        - ''' '''
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
      - arg_types:
        - defs::dacIndex
        - defs::detectorSettings
        argc: 2
        cast_input:
        - true
        - true
        check_det_id: false
        convert_det_id: true
        function: getDefaultDac
        input:
        - args[0]
        - args[1]
        input_types:
        - defs::dacIndex
        - defs::detectorSettings
        output:
        - args[0]
        - ''' '''
        - args[1]
        - ''' '''
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - defs::dacIndex
        - int
        argc: 2
        cast_input:
        - true
        - true
        check_det_id: false
        convert_det_id: true
        function: setDefaultDac
        input:
        - args[0]
        - args[1]
        input_types:
        - defs::dacIndex
        - int
        output:
        - args[0]
        - ''' '''
        - args[1]
        require_det_id: true
        store_result_in_t: false
      - arg_types:
        - defs::dacIndex
        - int
        - defs::detectorSettings
        argc: 3
        cast_input:
        - true
        - true
        - true
        check_det_id: false
        convert_det_id: true
        function: setDefaultDac
        input:
        - args[0]
        - args[1]
        - args[2]
        input_types:
        - defs::dacIndex
        - int
        - defs::detectorSettings
        output:
        - args[0]
        - ''' '''
        - args[2]
        - ''' '''
        - args[1]
        require_det_id: true
        store_result_in_t: false
  command_name: defaultdac
  function_alias: defaultdac
  help: "[dac name][value][(optional)setting]\n\tSets the default for that dac to\
    \ this value.\n\t[Jungfrau][Moench][Mythen3] When settings is provided, it sets\
    \ the default value only for that setting"
  infer_action: true
defaultpattern:
  actions:
    PUT:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: loadDefaultPattern
        input: []
        input_types: []
        output:
        - '"successful"'
        require_det_id: true
        store_result_in_t: false
  command_name: defaultpattern
  function_alias: defaultpattern
  help: "\n\t[Mythen3] Loads and runs default pattern in pattern generator. It is\
    \ to go back to initial settings."
  infer_action: true
  template: true
delay:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getDelayAfterTrigger
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
      - arg_types:
        - special::time_unit
        argc: 1
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getDelayAfterTrigger
        input: []
        input_types: []
        output:
        - OutString(t , args[0])
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - std::string
        argc: 1
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: setDelayAfterTrigger
        input:
        - converted_time
        input_types:
        - time::ns
        output:
        - args[0]
        require_det_id: true
        separate_time_units:
          input: args[0]
          output:
          - converted_time
          - unit
        store_result_in_t: false
      - arg_types:
        - int
        - special::time_unit
        argc: 2
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        convert_to_time:
          input:
          - args[0]
          - args[1]
          output: converted_time
        function: setDelayAfterTrigger
        input:
        - converted_time
        input_types:
        - time::ns
        output:
        - args[0]
        - args[1]
        require_det_id: true
        store_result_in_t: false
  command_name: delay
  function_alias: delay
  help: "[duration] [(optional unit) ns|us|ms|s]\n\t[Jungfrau][Moench][Gotthard][Mythen3][Gotthard2][Ctb][Moench][Xilinx\
    \ Ctb] Delay after trigger"
  infer_action: true
  template: true
delayl:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getDelayAfterTriggerLeft
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
      - arg_types:
        - special::time_unit
        argc: 1
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getDelayAfterTriggerLeft
        input: []
        input_types: []
        output:
        - OutString(t , args[0])
        require_det_id: true
        store_result_in_t: true
  command_name: delayl
  function_alias: delayl
  help: "\n\t[Gotthard][Jungfrau][Moench][Mythen3][Gotthard2][Ctb][Xilinx Ctb] Delay\
    \ Left in Acquisition. \n\t[Gotthard2] only in continuous mode."
  infer_action: true
  template: true
detectorserverversion:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getDetectorServerVersion
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
  command_name: detectorserverversion
  function_alias: detectorserverversion
  help: "\n\tOn-board detector server software version"
  infer_action: true
  template: true
detsize:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getDetectorSize
        input: []
        input_types: []
        output:
        - t
        require_det_id: false
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        - int
        argc: 2
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: setDetectorSize
        input:
        - defs::xy(StringTo<int>(args[0]),StringTo<int>(args[1]))
        input_types:
        - defs::xy
        output:
        - ToString(args)
        require_det_id: false
        store_result_in_t: false
  command_name: detsize
  function_alias: detsize
  help: "[nx] [ny]\n\tDetector size, ie. Number of channels in x and y dim. This is\
    \ used to calculate module coordinates included in UDP data. \n\tBy default, it\
    \ adds module in y dimension for 2d detectors and in x dimension for 1d detectors\
    \ packet header."
  infer_action: true
diodelay:
  actions:
    PUT:
      args:
      - arg_types:
        - uint64_t
        - int
        argc: 2
        cast_input:
        - true
        - true
        check_det_id: false
        convert_det_id: true
        function: setDigitalIODelay
        input:
        - args[0]
        - args[1]
        input_types:
        - uint64_t
        - int
        output:
        - ToString(args)
        require_det_id: true
        store_result_in_t: false
  command_name: diodelay
  function_alias: diodelay
  help: "[0-775]\n\t[Ctb] Delay for diode. Delay is in ps and max of 775 ps. Resolution\
    \ is 25 ps."
  infer_action: true
dpulse:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getDigitalPulsing
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - bool
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setDigitalPulsing
        input:
        - args[0]
        input_types:
        - bool
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: dpulse
  function_alias: dpulse
  help: "[0, 1]\n\t[Mythen3] Enables or disables digital pulsing. Default is disabled"
  infer_action: true
  template: true
dr:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getDynamicRange
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        argc: 1
        cast_input:
        - true
        check_det_id: true
        convert_det_id: true
        function: setDynamicRange
        input:
        - args[0]
        input_types:
        - int
        output:
        - args.front()
        require_det_id: false
        store_result_in_t: false
  command_name: dr
  function_alias: dr
  help: "[value]\n\tDynamic Range or number of bits per pixel in detector.\n\t[Eiger]\
    \ Options: 4, 8, 12, 16, 32. If set to 32, also sets clkdivider to 2, else to\
    \ 0.\n\t[Mythen3] Options: 8, 16, 32\n\t[Jungfrau][Moench][Gotthard][Ctb][Mythen3][Gotthard2][Xilinx\
    \ Ctb] 16"
  infer_action: true
  template: true
drlist:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getDynamicRangeList
        input: []
        input_types: []
        output:
        - ToString(t)
        require_det_id: false
        store_result_in_t: true
  command_name: drlist
  function_alias: drlist
  help: "\n\tGets the list of dynamic ranges for this detector."
  infer_action: true
  template: true
dsamples:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getNumberOfDigitalSamples
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setNumberOfDigitalSamples
        input:
        - args[0]
        input_types:
        - int
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: dsamples
  function_alias: dsamples
  help: "[n_value]\n\t[Ctb] Number of digital samples expected."
  infer_action: true
  template: true
execcommand:
  actions:
    PUT:
      args:
      - arg_types: []
        argc: -1
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: false
  command_name: execcommand
  function_alias: execcommand
  help: ''
  infer_action: true
  is_description: true
exptime:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getExptime
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
      - arg_types:
        - special::time_unit
        argc: 1
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getExptime
        input: []
        input_types: []
        output:
        - OutString(t , args[0])
        require_det_id: true
        store_result_in_t: true
      detectors:
        MYTHEN3:
        - arg_types: []
          argc: 0
          cast_input: []
          check_det_id: false
          convert_det_id: true
          function: getExptimeForAllGates
          input: []
          input_types: []
          output:
          - OutString(t)
          require_det_id: true
          store_result_in_t: true
        - arg_types:
          - special::time_unit
          argc: 1
          cast_input: []
          check_det_id: false
          convert_det_id: true
          function: getExptimeForAllGates
          input: []
          input_types: []
          output:
          - OutString(t , args[0])
          require_det_id: true
          store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - std::string
        argc: 1
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: setExptime
        input:
        - converted_time
        input_types:
        - time::ns
        output:
        - args[0]
        require_det_id: true
        separate_time_units:
          input: args[0]
          output:
          - converted_time
          - unit
        store_result_in_t: false
      - arg_types:
        - int
        - special::time_unit
        argc: 2
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        convert_to_time:
          input:
          - args[0]
          - args[1]
          output: converted_time
        function: setExptime
        input:
        - converted_time
        input_types:
        - time::ns
        output:
        - args[0]
        - args[1]
        require_det_id: true
        store_result_in_t: false
  command_name: exptime
  function_alias: exptime
  help: "[duration] [(optional unit) ns|us|ms|s]\n\t[Eiger][Jungfrau][Moench][Gotthard][Gotthard2][Ctb][Xilinx\
    \ Ctb] Exposure time\n\t[Mythen3] Exposure time of all gate signals in auto and\
    \ trigger mode (internal gating). To specify gate index, use exptime1, exptime2,\
    \ exptime3."
  infer_action: true
  template: true
exptime1:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        extra_variables:
        - name: gateIndex
          type: int
          value: 0
        function: getExptime
        input:
        - gateIndex
        input_types:
        - int
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
      - arg_types:
        - special::time_unit
        argc: 1
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        extra_variables:
        - name: gateIndex
          type: int
          value: 0
        function: getExptime
        input:
        - gateIndex
        input_types:
        - int
        output:
        - OutString(t , args[0])
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - std::string
        argc: 1
        cast_input:
        - false
        - false
        check_det_id: false
        convert_det_id: true
        extra_variables:
        - name: gateIndex
          type: int
          value: 0
        function: setExptime
        input:
        - gateIndex
        - converted_time
        input_types:
        - int
        - time::ns
        output:
        - args[0]
        require_det_id: true
        separate_time_units:
          input: args[0]
          output:
          - converted_time
          - unit
        store_result_in_t: false
      - arg_types:
        - int
        - special::time_unit
        argc: 2
        cast_input:
        - false
        - false
        check_det_id: false
        convert_det_id: true
        convert_to_time:
          input:
          - args[0]
          - args[1]
          output: converted_time
        extra_variables:
        - name: gateIndex
          type: int
          value: 0
        function: setExptime
        input:
        - gateIndex
        - converted_time
        input_types:
        - int
        - time::ns
        output:
        - args[0]
        - args[1]
        require_det_id: true
        store_result_in_t: false
  command_name: exptime1
  function_alias: exptime1
  help: "[n_value]\n\t[Mythen3] Exposure time of gate signal 1 in auto and trigger\
    \ mode (internal gating)."
  infer_action: true
  template: true
exptime2:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        extra_variables:
        - name: gateIndex
          type: int
          value: 1
        function: getExptime
        input:
        - gateIndex
        input_types:
        - int
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
      - arg_types:
        - special::time_unit
        argc: 1
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        extra_variables:
        - name: gateIndex
          type: int
          value: 1
        function: getExptime
        input:
        - gateIndex
        input_types:
        - int
        output:
        - OutString(t , args[0])
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - std::string
        argc: 1
        cast_input:
        - false
        - false
        check_det_id: false
        convert_det_id: true
        extra_variables:
        - name: gateIndex
          type: int
          value: 1
        function: setExptime
        input:
        - gateIndex
        - converted_time
        input_types:
        - int
        - time::ns
        output:
        - args[0]
        require_det_id: true
        separate_time_units:
          input: args[0]
          output:
          - converted_time
          - unit
        store_result_in_t: false
      - arg_types:
        - int
        - special::time_unit
        argc: 2
        cast_input:
        - false
        - false
        check_det_id: false
        convert_det_id: true
        convert_to_time:
          input:
          - args[0]
          - args[1]
          output: converted_time
        extra_variables:
        - name: gateIndex
          type: int
          value: 1
        function: setExptime
        input:
        - gateIndex
        - converted_time
        input_types:
        - int
        - time::ns
        output:
        - args[0]
        - args[1]
        require_det_id: true
        store_result_in_t: false
  command_name: exptime2
  function_alias: exptime2
  help: "[n_value]\n\t[Mythen3] Exposure time of gate signal 2 in auto and trigger\
    \ mode (internal gating)."
  infer_action: true
  template: true
exptime3:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        extra_variables:
        - name: gateIndex
          type: int
          value: 2
        function: getExptime
        input:
        - gateIndex
        input_types:
        - int
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
      - arg_types:
        - special::time_unit
        argc: 1
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        extra_variables:
        - name: gateIndex
          type: int
          value: 2
        function: getExptime
        input:
        - gateIndex
        input_types:
        - int
        output:
        - OutString(t , args[0])
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - std::string
        argc: 1
        cast_input:
        - false
        - false
        check_det_id: false
        convert_det_id: true
        extra_variables:
        - name: gateIndex
          type: int
          value: 2
        function: setExptime
        input:
        - gateIndex
        - converted_time
        input_types:
        - int
        - time::ns
        output:
        - args[0]
        require_det_id: true
        separate_time_units:
          input: args[0]
          output:
          - converted_time
          - unit
        store_result_in_t: false
      - arg_types:
        - int
        - special::time_unit
        argc: 2
        cast_input:
        - false
        - false
        check_det_id: false
        convert_det_id: true
        convert_to_time:
          input:
          - args[0]
          - args[1]
          output: converted_time
        extra_variables:
        - name: gateIndex
          type: int
          value: 2
        function: setExptime
        input:
        - gateIndex
        - converted_time
        input_types:
        - int
        - time::ns
        output:
        - args[0]
        - args[1]
        require_det_id: true
        store_result_in_t: false
  command_name: exptime3
  function_alias: exptime3
  help: "[n_value]\n\t[Mythen3] Exposure time of gate signal 3 in auto and trigger\
    \ mode (internal gating)."
  infer_action: true
  template: true
exptimel:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getExptimeLeft
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
      - arg_types:
        - special::time_unit
        argc: 1
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getExptimeLeft
        input: []
        input_types: []
        output:
        - OutString(t , args[0])
        require_det_id: true
        store_result_in_t: true
  command_name: exptimel
  function_alias: exptimel
  help: "[(optional unit) ns|us|ms|s]\n\t[Gotthard] Exposure time left for current\
    \ frame. "
  infer_action: true
  template: true
extrastoragecells:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getNumberOfAdditionalStorageCells
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        argc: 1
        cast_input:
        - true
        check_det_id: true
        convert_det_id: true
        function: setNumberOfAdditionalStorageCells
        input:
        - args[0]
        input_types:
        - int
        output:
        - args.front()
        require_det_id: false
        store_result_in_t: false
  command_name: extrastoragecells
  function_alias: extrastoragecells
  help: "[0-15]\n\t[Jungfrau] Only for chipv1.0. Number of additional storage cells.\
    \ Default is 0. For advanced users only. \n\tThe #images = #frames x #triggers\
    \ x (#extrastoragecells + 1)."
  infer_action: true
  template: true
extsampling:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getExternalSampling
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - bool
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setExternalSampling
        input:
        - args[0]
        input_types:
        - bool
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: extsampling
  function_alias: extsampling
  help: "[0, 1]\n\t[Ctb] Enable for external sampling signal for digital data to signal\
    \ by extsampling src command. For advanced users only."
  infer_action: true
  template: true
extsamplingsrc:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getExternalSamplingSource
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setExternalSamplingSource
        input:
        - args[0]
        input_types:
        - int
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: extsamplingsrc
  function_alias: extsamplingsrc
  help: "[0-63]\n\t[Ctb] Sampling source signal for digital data. For advanced users\
    \ only."
  infer_action: true
  template: true
extsig:
  actions:
    GET:
      args:
      - arg_types:
        - int
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: getExternalSignalFlags
        input:
        - args[0]
        input_types:
        - int
        output:
        - args[0]
        - ''' '''
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        - defs::externalSignalFlag
        argc: 2
        cast_input:
        - true
        - true
        check_det_id: false
        convert_det_id: true
        function: setExternalSignalFlags
        input:
        - args[0]
        - args[1]
        input_types:
        - int
        - defs::externalSignalFlag
        output:
        - args[0]
        - ''' '''
        - args[1]
        require_det_id: true
        store_result_in_t: false
  command_name: extsig
  function_alias: extsig
  help: "[n_signal] [signal_type]\n\t[Gotthard][Mythen3] External signal mode for\
    \ trigger timing mode.\n\t[Gotthard] [0] [trigger_in_rising_edge|trigger_in_falling_edge]\n\
    \t[Mythen3] [0-7] [trigger_in_rising_edge|trigger_in_falling_edge|inversion_on|inversion_off]\n\
    \t where 0 is master input trigger signal, 1-3 is master input gate signals, 4\
    \ is busy out signal and 5-7 is master output gate signals."
  infer_action: true
fformat:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getFileFormat
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - defs::fileFormat
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setFileFormat
        input:
        - args[0]
        input_types:
        - defs::fileFormat
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: fformat
  function_alias: fformat
  help: "[binary|hdf5]\n\tFile format of data file. For HDF5, package must be compiled\
    \ with HDF5 flags. Default is binary."
  infer_action: true
  template: true
filtercells:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getNumberOfFilterCells
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setNumberOfFilterCells
        input:
        - args[0]
        input_types:
        - int
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: filtercells
  function_alias: filtercells
  help: "[0-12]\n\t[Jungfrau] Set Filter Cell. Only for chipv1.1. Advanced user Command"
  infer_action: true
  template: true
filterresistor:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getFilterResistor
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setFilterResistor
        input:
        - args[0]
        input_types:
        - int
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: filterresistor
  function_alias: filterresistor
  help: "[value] [Gotthard2][Jungfrau] Set filter resistor. Increasing values for\
    \ increasing resistance.\n\t[Gotthard2] Options: [0|1|2|3]. Default is 0.\n\t\
    [Jungfrau] Options: [0|1]. Default is 1."
  infer_action: true
  template: true
findex:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getAcquisitionIndex
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - uint64_t
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setAcquisitionIndex
        input:
        - args[0]
        input_types:
        - uint64_t
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: findex
  function_alias: findex
  help: "[n_value]\n\tFile or Acquisition index."
  infer_action: true
  template: true
firmwaretest:
  actions:
    PUT:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: executeFirmwareTest
        input: []
        input_types: []
        output:
        - '"successful"'
        require_det_id: true
        store_result_in_t: false
  command_name: firmwaretest
  function_alias: firmwaretest
  help: "\n\t[Jungfrau][Moench][Gotthard][Mythen3][Gotthard2][Ctb][Xilinx Ctb] Firmware\
    \ test, ie. reads a read fixed pattern from a register."
  infer_action: true
  template: true
firmwareversion:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getFirmwareVersion
        input: []
        input_types: []
        output:
        - OutStringHex(t)
        require_det_id: true
        store_result_in_t: true
      detectors:
        EIGER:
        - arg_types: []
          argc: 0
          cast_input: []
          check_det_id: false
          convert_det_id: true
          function: getFirmwareVersion
          input: []
          input_types: []
          output:
          - OutString(t)
          require_det_id: true
          store_result_in_t: true
  command_name: firmwareversion
  function_alias: firmwareversion
  help: "\n\tFirmware version of detector in format [0xYYMMDD] or an increasing 2\
    \ digit number for Eiger."
  infer_action: true
fliprows:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getFlipRows
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - bool
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setFlipRows
        input:
        - args[0]
        input_types:
        - bool
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: fliprows
  function_alias: fliprows
  help: "[0, 1]\n\t[Eiger] flips rows paramater sent to slsreceiver to stream as json\
    \ parameter to flip rows in gui \n\t[Jungfrau][Moench] flips rows in the detector\
    \ itself. For bottom module and number of interfaces must be set to 2. slsReceiver\
    \ and slsDetectorGui does not handle."
  infer_action: true
  template: true
flowcontrol10g:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getTenGigaFlowControl
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - bool
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setTenGigaFlowControl
        input:
        - args[0]
        input_types:
        - bool
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: flowcontrol10g
  function_alias: flowcontrol10g
  help: "[0, 1]\n\t[Eiger][Jungfrau][Moench] 10GbE Flow Control."
  infer_action: true
  template: true
fmaster:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: true
        convert_det_id: true
        function: getMasterFileWrite
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: false
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - bool
        argc: 1
        cast_input:
        - true
        check_det_id: true
        convert_det_id: true
        function: setMasterFileWrite
        input:
        - args[0]
        input_types:
        - bool
        output:
        - args.front()
        require_det_id: false
        store_result_in_t: false
  command_name: fmaster
  function_alias: fmaster
  help: "[0, 1]\n\tEnable or disable receiver master file. Default is 1."
  infer_action: true
  template: true
fname:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getFileNamePrefix
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - std::string
        argc: 1
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: setFileNamePrefix
        input:
        - args[0]
        input_types:
        - std::string
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: fname
  function_alias: fname
  help: "[name]\n\tFile name prefix for output data file. Default is run. File name:\
    \ [file name prefix]_d[detector index]_f[sub file index]_[acquisition/file index].raw."
  infer_action: true
  template: true
foverwrite:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getFileOverWrite
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - bool
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setFileOverWrite
        input:
        - args[0]
        input_types:
        - bool
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: foverwrite
  function_alias: foverwrite
  help: "[0, 1]\n\tEnable or disable file overwriting. Default is 1."
  infer_action: true
  template: true
fpath:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getFilePath
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - special::path
        argc: 1
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: setFilePath
        input:
        - args[0]
        input_types:
        - std::string
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: fpath
  function_alias: fpath
  help: "[path]\n\tDirectory where output data files are written in receiver. Default\
    \ is '/'. \n\tIf path does not exist and fwrite enabled, it will try to create\
    \ it at start of acquisition."
  infer_action: true
  template: true
framecounter:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getNumberOfFramesFromStart
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
  command_name: framecounter
  function_alias: framecounter
  help: "\n\t[Jungfrau][Moench][Mythen3][Gotthard2][Ctb][Xilinx Ctb] Number of frames\
    \ from start run control.\n\t[Gotthard2] only in continuous mode."
  infer_action: true
  template: true
frames:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getNumberOfFrames
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int64_t
        argc: 1
        cast_input:
        - true
        check_det_id: true
        convert_det_id: true
        function: setNumberOfFrames
        input:
        - args[0]
        input_types:
        - int64_t
        output:
        - args.front()
        require_det_id: false
        store_result_in_t: false
  command_name: frames
  function_alias: frames
  help: "[n_frames]\n\tNumber of frames per acquisition. In trigger mode, number of\
    \ frames per trigger. \n\tCannot be set in modular level. \n\tIn scan mode, number\
    \ of frames is set to number of steps.\n\t[Gotthard2] Burst mode has a maximum\
    \ of 2720 frames."
  infer_action: true
  template: true
framesl:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getNumberOfFramesLeft
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
  command_name: framesl
  function_alias: framesl
  help: "\n\t[Gotthard][Jungfrau][Moench][Mythen3][Gotthard2][Ctb][Xilinx Ctb] Number\
    \ of frames left in acquisition. \n\t[Gotthard2] only in continuous auto mode."
  infer_action: true
  template: true
frametime:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getMeasurementTime
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
      - arg_types:
        - special::time_unit
        argc: 1
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getMeasurementTime
        input: []
        input_types: []
        output:
        - OutString(t , args[0])
        require_det_id: true
        store_result_in_t: true
  command_name: frametime
  function_alias: frametime
  help: "[(optional unit) ns|us|ms|s]\n\t[Jungfrau][Moench][Mythen3][Gotthard2][Ctb][Xilinx\
    \ Ctb] Timestamp at a frame start.\n\t[Gotthard2] not in burst and auto mode."
  infer_action: true
  template: true
free:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: true
    PUT:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: false
  command_name: free
  function_alias: free
  help: ''
  infer_action: true
  is_description: true
fwrite:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getFileWrite
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - bool
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setFileWrite
        input:
        - args[0]
        input_types:
        - bool
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: fwrite
  function_alias: fwrite
  help: "[0, 1]\n\tEnable or disable receiver file write. Default is 0."
  infer_action: true
  template: true
gaincaps:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - defs::defs::M3_GainCaps
        argc: -1
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: false
  command_name: gaincaps
  function_alias: gaincaps
  help: ''
  infer_action: true
  is_description: true
gainmode:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getGainMode
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - defs::gainMode
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setGainMode
        input:
        - args[0]
        input_types:
        - defs::gainMode
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: gainmode
  function_alias: gainmode
  help: "[dynamic|forceswitchg1|forceswitchg2|fixg1|fixg2|fixg0]\n\t[Jungfrau] Gain\
    \ mode.\n\tCAUTION: Do not use fixg0 without caution, you can damage the detector!!!"
  infer_action: true
  template: true
gappixels:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: true
        convert_det_id: true
        function: getGapPixelsinCallback
        input: []
        input_types: []
        output:
        - t
        require_det_id: false
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - bool
        argc: 1
        cast_input:
        - true
        check_det_id: true
        convert_det_id: true
        function: setGapPixelsinCallback
        input:
        - args[0]
        input_types:
        - bool
        output:
        - args.front()
        require_det_id: false
        store_result_in_t: false
  command_name: gappixels
  function_alias: gappixels
  help: "[0, 1]\n\t[Eiger][Jungfrau][Moench] Include Gap pixels in client data call\
    \ back in Detecor api. Will not be in detector streaming, receiver file or streaming.\
    \ Default is 0. "
  infer_action: true
gatedelay:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getGateDelayForAllGates
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
      - arg_types:
        - special::time_unit
        argc: 1
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getGateDelayForAllGates
        input: []
        input_types: []
        output:
        - OutString(t, args[0])
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - std::string
        argc: 1
        cast_input:
        - false
        - false
        check_det_id: false
        convert_det_id: true
        extra_variables:
        - name: gateIndex
          type: int
          value: -1
        function: setGateDelay
        input:
        - gateIndex
        - converted_time
        input_types:
        - int
        - time::ns
        output:
        - args[0]
        require_det_id: true
        separate_time_units:
          input: args[0]
          output:
          - converted_time
          - unit
        store_result_in_t: false
      - arg_types:
        - int
        - special::time_unit
        argc: 2
        cast_input:
        - false
        - false
        check_det_id: false
        convert_det_id: true
        convert_to_time:
          input:
          - args[0]
          - args[1]
          output: converted_time
        extra_variables:
        - name: gateIndex
          type: int
          value: -1
        function: setGateDelay
        input:
        - gateIndex
        - converted_time
        input_types:
        - int
        - time::ns
        output:
        - args[0]
        - args[1]
        require_det_id: true
        store_result_in_t: false
  command_name: gatedelay
  function_alias: gatedelay
  help: "[duration] [(optional unit) ns|us|ms|s]\n\t[Mythen3] Gate Delay of all gate\
    \ signals in auto and trigger mode (internal gating)."
  infer_action: true
gatedelay1:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        extra_variables:
        - name: gateIndex
          type: int
          value: 0
        function: getGateDelay
        input:
        - gateIndex
        input_types:
        - int
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
      - arg_types:
        - special::time_unit
        argc: 1
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        extra_variables:
        - name: gateIndex
          type: int
          value: 0
        function: getGateDelay
        input:
        - gateIndex
        input_types:
        - int
        output:
        - OutString(t, args[0])
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - std::string
        argc: 1
        cast_input:
        - false
        - false
        check_det_id: false
        convert_det_id: true
        extra_variables:
        - name: gateIndex
          type: int
          value: 0
        function: setGateDelay
        input:
        - gateIndex
        - converted_time
        input_types:
        - int
        - time::ns
        output:
        - args[0]
        require_det_id: true
        separate_time_units:
          input: args[0]
          output:
          - converted_time
          - unit
        store_result_in_t: false
      - arg_types:
        - int
        - special::time_unit
        argc: 2
        cast_input:
        - false
        - false
        check_det_id: false
        convert_det_id: true
        convert_to_time:
          input:
          - args[0]
          - args[1]
          output: converted_time
        extra_variables:
        - name: gateIndex
          type: int
          value: 0
        function: setGateDelay
        input:
        - gateIndex
        - converted_time
        input_types:
        - int
        - time::ns
        output:
        - args[0]
        - args[1]
        require_det_id: true
        store_result_in_t: false
  command_name: gatedelay1
  function_alias: gatedelay1
  help: "[duration] [(optional unit) ns|us|ms|s]\n\t[Mythen3] Gate Delay of gate signal\
    \ 1 in auto and trigger mode (internal gating)."
  infer_action: true
gatedelay2:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        extra_variables:
        - name: gateIndex
          type: int
          value: 1
        function: getGateDelay
        input:
        - gateIndex
        input_types:
        - int
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
      - arg_types:
        - special::time_unit
        argc: 1
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        extra_variables:
        - name: gateIndex
          type: int
          value: 1
        function: getGateDelay
        input:
        - gateIndex
        input_types:
        - int
        output:
        - OutString(t, args[0])
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - std::string
        argc: 1
        cast_input:
        - false
        - false
        check_det_id: false
        convert_det_id: true
        extra_variables:
        - name: gateIndex
          type: int
          value: 1
        function: setGateDelay
        input:
        - gateIndex
        - converted_time
        input_types:
        - int
        - time::ns
        output:
        - args[0]
        require_det_id: true
        separate_time_units:
          input: args[0]
          output:
          - converted_time
          - unit
        store_result_in_t: false
      - arg_types:
        - int
        - special::time_unit
        argc: 2
        cast_input:
        - false
        - false
        check_det_id: false
        convert_det_id: true
        convert_to_time:
          input:
          - args[0]
          - args[1]
          output: converted_time
        extra_variables:
        - name: gateIndex
          type: int
          value: 1
        function: setGateDelay
        input:
        - gateIndex
        - converted_time
        input_types:
        - int
        - time::ns
        output:
        - args[0]
        - args[1]
        require_det_id: true
        store_result_in_t: false
  command_name: gatedelay2
  function_alias: gatedelay2
  help: "[duration] [(optional unit) ns|us|ms|s]\n\t[Mythen3] Gate Delay of gate signal\
    \ 2 in auto and trigger mode (internal gating)."
  infer_action: true
gatedelay3:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        extra_variables:
        - name: gateIndex
          type: int
          value: 2
        function: getGateDelay
        input:
        - gateIndex
        input_types:
        - int
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
      - arg_types:
        - special::time_unit
        argc: 1
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        extra_variables:
        - name: gateIndex
          type: int
          value: 2
        function: getGateDelay
        input:
        - gateIndex
        input_types:
        - int
        output:
        - OutString(t, args[0])
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - std::string
        argc: 1
        cast_input:
        - false
        - false
        check_det_id: false
        convert_det_id: true
        extra_variables:
        - name: gateIndex
          type: int
          value: 2
        function: setGateDelay
        input:
        - gateIndex
        - converted_time
        input_types:
        - int
        - time::ns
        output:
        - args[0]
        require_det_id: true
        separate_time_units:
          input: args[0]
          output:
          - converted_time
          - unit
        store_result_in_t: false
      - arg_types:
        - int
        - special::time_unit
        argc: 2
        cast_input:
        - false
        - false
        check_det_id: false
        convert_det_id: true
        convert_to_time:
          input:
          - args[0]
          - args[1]
          output: converted_time
        extra_variables:
        - name: gateIndex
          type: int
          value: 2
        function: setGateDelay
        input:
        - gateIndex
        - converted_time
        input_types:
        - int
        - time::ns
        output:
        - args[0]
        - args[1]
        require_det_id: true
        store_result_in_t: false
  command_name: gatedelay3
  function_alias: gatedelay3
  help: "[duration] [(optional unit) ns|us|ms|s]\n\t[Mythen3] Gate Delay of gate signal\
    \ 3 in auto and trigger mode (internal gating)."
  infer_action: true
gates:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getNumberOfGates
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setNumberOfGates
        input:
        - args[0]
        input_types:
        - int
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: gates
  function_alias: gates
  help: "[n_gates]\n\t[Mythen3] Number of external gates in gating or trigger_gating\
    \ mode (external gating)."
  infer_action: true
  template: true
getbit:
  actions:
    GET:
      args:
      - arg_types:
        - uint32_t
        - int
        argc: 2
        cast_input:
        - true
        - true
        check_det_id: false
        convert_det_id: true
        exceptions:
        - condition: StringTo<int>(args[1]) < 0 || StringTo<int>(args[1]) > 31
          message: '"Bit number out of range: " + args[1]'
        function: getBit
        input:
        - args[0]
        - args[1]
        input_types:
        - uint32_t
        - int
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
  command_name: getbit
  function_alias: getbit
  help: "[reg address in hex] [bit index]\n\tGets bit in address."
  infer_action: true
hardwareversion:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getHardwareVersion
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
  command_name: hardwareversion
  function_alias: hardwareversion
  help: "\n\tHardware version of detector. \n\t[Eiger] Hardware version of front FPGA\
    \ on detector."
  infer_action: true
  template: true
highvoltage:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getHighVoltage
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setHighVoltage
        input:
        - args[0]
        input_types:
        - int
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: highvoltage
  function_alias: highvoltage
  help: "[n_value]\n\tHigh voltage to the sensor in Voltage. \n\t[Gotthard] [0|90|110|120|150|180|200]\
    \ \n\t[Eiger][Mythen3][Gotthard2] 0-200 \n\t[Jungfrau][Moench][Ctb] [0|60-200]"
  infer_action: true
  template: true
hostname:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - std::string
        argc: -1
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: false
  command_name: hostname
  function_alias: hostname
  help: ''
  infer_action: true
  is_description: true
im_a:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: getMeasuredCurrent
        input:
        - defs::I_POWER_A
        input_types:
        - int
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
  command_name: im_a
  function_alias: im_a
  help: "\n\t[Ctb] Measured current of power supply a in mA."
  infer_action: true
  template: true
im_b:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: getMeasuredCurrent
        input:
        - defs::I_POWER_B
        input_types:
        - int
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
  command_name: im_b
  function_alias: im_b
  help: "\n\t[Ctb] Measured current of power supply b in mA."
  infer_action: true
  template: true
im_c:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: getMeasuredCurrent
        input:
        - defs::I_POWER_C
        input_types:
        - int
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
  command_name: im_c
  function_alias: im_c
  help: "\n\t[Ctb] Measured current of power supply c in mA."
  infer_action: true
  template: true
im_d:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: getMeasuredCurrent
        input:
        - defs::I_POWER_D
        input_types:
        - int
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
  command_name: im_d
  function_alias: im_d
  help: "\n\t[Ctb] Measured current of power supply d in mA."
  infer_action: true
  template: true
im_io:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: getMeasuredCurrent
        input:
        - defs::I_POWER_IO
        input_types:
        - int
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
  command_name: im_io
  function_alias: im_io
  help: "\n\t[Ctb] Measured current of power supply io in mA."
  infer_action: true
  template: true
imagetest:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getImageTestMode
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - bool
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setImageTestMode
        input:
        - args[0]
        input_types:
        - bool
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: imagetest
  function_alias: imagetest
  help: "[0, 1]\n\t[Gotthard] 1 adds channel intensity with precalculated values when\
    \ taking an acquisition. Default is 0.\n\t[Eiger][Jungfrau][Moench] Only for Virtual\
    \ servers. If 0, each pixel intensity incremented by 1. If 1, all pixels almost\
    \ saturated."
  infer_action: true
  template: true
initialchecks:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: true
        convert_det_id: true
        function: getInitialChecks
        input: []
        input_types: []
        output:
        - t
        require_det_id: false
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - bool
        argc: 1
        cast_input:
        - true
        check_det_id: true
        convert_det_id: true
        function: setInitialChecks
        input:
        - args[0]
        input_types:
        - bool
        output:
        - args.front()
        require_det_id: false
        store_result_in_t: false
  command_name: initialchecks
  function_alias: initialchecks
  help: "[0, 1]\n\t[Mythen3][Gotthard2] Enable or disable intial compatibility and\
    \ other checks at detector start up. It is enabled by default. Must come before\
    \ 'hostname' command to take effect. Can be used to reprogram fpga when current\
    \ firmware is incompatible.\n\tAdvanced User function!"
  infer_action: true
inj_ch:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getInjectChannel
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        - int
        argc: 2
        cast_input:
        - true
        - true
        check_det_id: false
        convert_det_id: true
        function: setInjectChannel
        input:
        - args[0]
        - args[1]
        input_types:
        - int
        - int
        output:
        - ToString(args)
        require_det_id: true
        store_result_in_t: false
  command_name: inj_ch
  function_alias: inj_ch
  help: "[offset] [increment]\n\t[Gotthard2] Inject channels with current source for\
    \ calibration. Offset is starting channel that is injected, increment determines\
    \ succeeding channels to be injected."
  infer_action: true
interpolation:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getInterpolation
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - bool
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setInterpolation
        input:
        - args[0]
        input_types:
        - bool
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: interpolation
  function_alias: interpolation
  help: "[0, 1]\n\t[Mythen3] Enables or disables interpolation. Default is disabled.\
    \  Interpolation mode enables all counters and disables vth3. Disabling sets back\
    \ counter mask and vth3."
  infer_action: true
  template: true
interruptsubframe:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getInterruptSubframe
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - bool
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setInterruptSubframe
        input:
        - args[0]
        input_types:
        - bool
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: interruptsubframe
  function_alias: interruptsubframe
  help: "[0, 1]\n\t[Eiger] 1 interrupts last subframe at required exposure time. 0\
    \ will wait for last sub frame to finish exposing. 0 is default."
  infer_action: true
  template: true
kernelversion:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getKernelVersion
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
  command_name: kernelversion
  function_alias: kernelversion
  help: "\n\tGet kernel version on the detector including time and date."
  infer_action: true
  template: true
lastclient:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getLastClientIP
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
  command_name: lastclient
  function_alias: lastclient
  help: "\n\tClient IP Address that last communicated with the detector."
  infer_action: true
  template: true
led:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getLEDEnable
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - bool
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setLEDEnable
        input:
        - args[0]
        input_types:
        - bool
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: led
  function_alias: led
  help: "[0, 1]\n\t[Ctb] Switches on/off all LEDs."
  infer_action: true
  template: true
lock:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getDetectorLock
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - bool
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setDetectorLock
        input:
        - args[0]
        input_types:
        - bool
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: lock
  function_alias: lock
  help: "[0, 1]\n\tLock detector to one IP, 1: locks. Default is unlocked"
  infer_action: true
  template: true
master:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getMaster
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - bool
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: false
        function: setMaster
        input:
        - args[0]
        input_types:
        - bool
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: master
  function_alias: master
  help: "[0, 1]\n\t[Eiger][Gotthard2][Jungfrau][Moench] Sets (half) module to master\
    \ and other(s) to slaves.\n\t[Gotthard][Gotthard2][Mythen3][Eiger][Jungfrau][Moench]\
    \ Gets if the current (half) module is master."
  infer_action: true
  template: true
maxadcphaseshift:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getMaxADCPhaseShift
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
  command_name: maxadcphaseshift
  function_alias: maxadcphaseshift
  help: "\n\t[Jungfrau][Moench][Ctb] Absolute maximum Phase shift of ADC clock."
  infer_action: true
  template: true
maxclkphaseshift:
  actions:
    GET:
      args:
      - arg_types:
        - int
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        exceptions:
        - condition: type != defs::GOTTHARD2 && type != defs::MYTHEN3
          message: '"maxclkphaseshift not implemented for this detector."'
        extra_variables:
        - name: type
          type: defs::detectorType
          value: det->getDetectorType().squash(defs::GENERIC);
        function: getMaxClockPhaseShift
        input:
        - args[0]
        input_types:
        - int
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
  command_name: maxclkphaseshift
  function_alias: maxclkphaseshift
  help: "[n_clock]\n\t[Gotthard2][Mythen3] Absolute Maximum Phase shift of clock n_clock.n\t\
    [Gotthard2] Clock index range: 0-5\n\t[Mythen3] Clock index range: 0"
  infer_action: true
maxdbitphaseshift:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getMaxDBITPhaseShift
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
  command_name: maxdbitphaseshift
  function_alias: maxdbitphaseshift
  help: "\n\t[Ctb][Jungfrau] Absolute maximum Phase shift of of the clock to latch\
    \ digital bits."
  infer_action: true
  template: true
measuredperiod:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getMeasuredPeriod
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
      - arg_types:
        - special::time_unit
        argc: 1
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getMeasuredPeriod
        input: []
        input_types: []
        output:
        - OutString(t , args[0])
        require_det_id: true
        store_result_in_t: true
  command_name: measuredperiod
  function_alias: measuredperiod
  help: "[(optional unit) ns|us|ms|s]\n\t[Eiger] Measured frame period between last\
    \ frame and previous one. Can be measured with minimum 2 frames in an acquisition."
  infer_action: true
  template: true
measuredsubperiod:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getMeasuredSubFramePeriod
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
      - arg_types:
        - special::time_unit
        argc: 1
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getMeasuredSubFramePeriod
        input: []
        input_types: []
        output:
        - OutString(t , args[0])
        require_det_id: true
        store_result_in_t: true
  command_name: measuredsubperiod
  function_alias: measuredsubperiod
  help: "[(optional unit) ns|us|ms|s]\n\t[Eiger] Measured sub frame period between\
    \ last sub frame and previous one."
  infer_action: true
  template: true
moduleid:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getModuleId
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
  command_name: moduleid
  function_alias: moduleid
  help: "\n\t[Gotthard2][Eiger][Mythen3][Jungfrau][Moench] 16 bit value (ideally unique)\
    \ that is streamed out in the UDP header of the detector. Picked up from a file\
    \ on the module."
  infer_action: true
  template: true
nextframenumber:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getNextFrameNumber
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - uint64_t
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setNextFrameNumber
        input:
        - args[0]
        input_types:
        - uint64_t
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: nextframenumber
  function_alias: nextframenumber
  help: "[n_value]\n\t[Eiger][Jungfrau][Moench][Ctb][Xilinx Ctb][Gotthard2] Next frame\
    \ number. Stopping acquisition might result in different frame numbers for different\
    \ modules. So, after stopping, next frame number (max + 1) is set for all the\
    \ modules afterwards."
  infer_action: true
  template: true
nmod:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: size
        input: []
        input_types: []
        output:
        - ToString(t)
        require_det_id: false
        store_result_in_t: true
  command_name: nmod
  function_alias: nmod
  help: "\n\tNumber of modules in shared memory."
  infer_action: true
  template: true
numinterfaces:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getNumberofUDPInterfaces
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setNumberofUDPInterfaces
        input:
        - args[0]
        input_types:
        - int
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: numinterfaces
  function_alias: numinterfaces
  help: "[1, 2]\n\t[Jungfrau][Moench] Number of udp interfaces to stream data from\
    \ detector. Default: 1.\n\tAlso enables second interface in receiver for listening\
    \ (Writes a file per interface if writing enabled).\n\tAlso restarts client and\
    \ receiver zmq sockets if zmq streaming enabled.\n\t[Eiger] Only gets with result\
    \ 2."
  infer_action: true
  template: true
overflow:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getOverFlowMode
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - bool
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setOverFlowMode
        input:
        - args[0]
        input_types:
        - bool
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: overflow
  function_alias: overflow
  help: "[0, 1]\n\t[Eiger] Enable or disable show overflow flag in 32 bit mode. Default\
    \ is disabled."
  infer_action: true
  template: true
packageversion:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getPackageVersion
        input: []
        input_types: []
        output:
        - t
        require_det_id: false
        store_result_in_t: true
  command_name: packageversion
  function_alias: packageversion
  help: "\n\tPackage version."
  infer_action: true
parallel:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getParallelMode
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - bool
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setParallelMode
        input:
        - args[0]
        input_types:
        - bool
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: parallel
  function_alias: parallel
  help: "[0, 1]\n\t[Eiger][Mythen3][Gotthard2][Moench] Enable or disable parallel\
    \ mode.\n\t[Mythen3] If exptime is too short, the acquisition will return ERROR\
    \ status and take fewer frames than expected.\n\t[Mythen3][Eiger][Moench] Default:\
    \ Non parallel.\n\t[Gotthard2] Default: Parallel. Non parallel mode works only\
    \ in continuous mode."
  infer_action: true
  template: true
parameters:
  actions:
    PUT:
      args:
      - arg_types:
        - special::path
        argc: 1
        cast_input:
        - false
        check_det_id: true
        convert_det_id: true
        function: loadParameters
        input:
        - args[0]
        input_types:
        - std::string
        output:
        - args.front()
        require_det_id: false
        store_result_in_t: false
  command_name: parameters
  function_alias: parameters
  help: "\n\tSets detector measurement parameters to those contained in fname. Set\
    \ up per measurement."
  infer_action: true
  template: true
partialreset:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getPartialReset
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - bool
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setPartialReset
        input:
        - args[0]
        input_types:
        - bool
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: partialreset
  function_alias: partialreset
  help: "[0, 1]\n\t[Eiger] Sets up detector to do partial or complete reset at start\
    \ of acquisition. 0 complete reset, 1 partial reset. Default is complete reset.\
    \ Advanced function!"
  infer_action: true
  template: true
patfname:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getPatterFileName
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
  command_name: patfname
  function_alias: patfname
  help: "\n\t[Ctb][Mythen3][Xilinx Ctb] Gets the pattern file name including path\
    \ of the last pattern uploaded. Returns an empty if nothing was uploaded or via\
    \ a server default file"
  infer_action: true
  template: true
patioctrl:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getPatternIOControl
        input: []
        input_types: []
        output:
        - OutStringHex(t, 16)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - uint64_t
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setPatternIOControl
        input:
        - args[0]
        input_types:
        - uint64_t
        output:
        - ToStringHex(arg0, 16)
        require_det_id: true
        store_result_in_t: false
  command_name: patioctrl
  function_alias: patioctrl
  help: "[64 bit mask]\n\t[Ctb] 64 bit mask defining input (0) and output (1) signals."
  infer_action: true
  template: true
patlimits:
  actions:
    GET:
      args:
      - arg_types:
        - int
        argc: -1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: getPatternLoopAddresses
        input:
        - '"-1"'
        input_types:
        - int
        output:
        - OutStringHex(t, 4)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        - int
        - int
        argc: -1
        cast_input:
        - true
        - true
        - true
        check_det_id: false
        convert_det_id: true
        function: setPatternLoopAddresses
        input:
        - '"-1"'
        - args[0]
        - args[1]
        input_types:
        - int
        - int
        - int
        output:
        - '''['''
        - ToStringHex(arg1, 4)
        - '", "'
        - ToStringHex(arg2, 4)
        - ''']'''
        require_det_id: true
        store_result_in_t: false
  command_name: patlimits
  function_alias: patlimits
  help: "[start addr] [stop addr] \n\t[Ctb][Mythen3][Xilinx Ctb] Limits of complete\
    \ pattern"
  infer_action: true
patloop:
  actions:
    GET:
      args:
      - arg_types:
        - int
        argc: -1
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: getPatternLoopAddresses
        input:
        - level
        input_types:
        - int
        output:
        - level
        - ''' '''
        - OutStringHex(t, 4)
        pattern_command:
          command_name: patloop
          nGetArgs: 0
          nPutArgs: 2
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        - int
        - int
        argc: -1
        cast_input:
        - false
        - false
        - false
        check_det_id: false
        convert_det_id: true
        extra_variables:
        - name: start
          type: int
          value: StringTo<int>(args[iArg++])
        - name: stop
          type: int
          value: StringTo<int>(args[iArg++])
        function: setPatternLoopAddresses
        input:
        - level
        - start
        - stop
        input_types:
        - int
        - int
        - int
        output:
        - level
        - ''' '''
        - '''['''
        - ToStringHex(start, 4)
        - '", "'
        - ToStringHex(stop, 4)
        - ''']'''
        pattern_command:
          command_name: patloop
          nGetArgs: 0
          nPutArgs: 2
        require_det_id: true
        store_result_in_t: false
  command_name: patloop
  function_alias: patloop
  help: "[0-6] [start addr] [stop addr] \n\t[Ctb][Mythen3][Xilinx Ctb] Limits of the\
    \ loop level provided.\n\t[Mythen3] Level options: 0-3 only."
  infer_action: true
patloop0:
  actions:
    GET:
      args:
      - arg_types:
        - int
        argc: -1
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: getPatternLoopAddresses
        input:
        - level
        input_types:
        - int
        output:
        - OutStringHex(t, 4)
        pattern_command:
          command_name: patloop
          nGetArgs: 0
          nPutArgs: 2
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        - int
        - int
        argc: -1
        cast_input:
        - false
        - false
        - false
        check_det_id: false
        convert_det_id: true
        extra_variables:
        - name: start
          type: int
          value: StringTo<int>(args[iArg++])
        - name: stop
          type: int
          value: StringTo<int>(args[iArg++])
        function: setPatternLoopAddresses
        input:
        - level
        - start
        - stop
        input_types:
        - int
        - int
        - int
        output:
        - '''['''
        - ToStringHex(start, 4)
        - '", "'
        - ToStringHex(stop, 4)
        - ''']'''
        pattern_command:
          command_name: patloop
          nGetArgs: 0
          nPutArgs: 2
        require_det_id: true
        store_result_in_t: false
  command_name: patloop0
  function_alias: patloop0
  help: "\n\tDeprecated command. Use patloop."
  infer_action: true
patloop1:
  actions:
    GET:
      args:
      - arg_types:
        - int
        argc: -1
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: getPatternLoopAddresses
        input:
        - level
        input_types:
        - int
        output:
        - OutStringHex(t, 4)
        pattern_command:
          command_name: patloop
          nGetArgs: 0
          nPutArgs: 2
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        - int
        - int
        argc: -1
        cast_input:
        - false
        - false
        - false
        check_det_id: false
        convert_det_id: true
        extra_variables:
        - name: start
          type: int
          value: StringTo<int>(args[iArg++])
        - name: stop
          type: int
          value: StringTo<int>(args[iArg++])
        function: setPatternLoopAddresses
        input:
        - level
        - start
        - stop
        input_types:
        - int
        - int
        - int
        output:
        - '''['''
        - ToStringHex(start, 4)
        - '", "'
        - ToStringHex(stop, 4)
        - ''']'''
        pattern_command:
          command_name: patloop
          nGetArgs: 0
          nPutArgs: 2
        require_det_id: true
        store_result_in_t: false
  command_name: patloop1
  function_alias: patloop1
  help: "\n\tDeprecated command. Use patloop."
  infer_action: true
patloop2:
  actions:
    GET:
      args:
      - arg_types:
        - int
        argc: -1
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: getPatternLoopAddresses
        input:
        - level
        input_types:
        - int
        output:
        - OutStringHex(t, 4)
        pattern_command:
          command_name: patloop
          nGetArgs: 0
          nPutArgs: 2
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        - int
        - int
        argc: -1
        cast_input:
        - false
        - false
        - false
        check_det_id: false
        convert_det_id: true
        extra_variables:
        - name: start
          type: int
          value: StringTo<int>(args[iArg++])
        - name: stop
          type: int
          value: StringTo<int>(args[iArg++])
        function: setPatternLoopAddresses
        input:
        - level
        - start
        - stop
        input_types:
        - int
        - int
        - int
        output:
        - '''['''
        - ToStringHex(start, 4)
        - '", "'
        - ToStringHex(stop, 4)
        - ''']'''
        pattern_command:
          command_name: patloop
          nGetArgs: 0
          nPutArgs: 2
        require_det_id: true
        store_result_in_t: false
  command_name: patloop2
  function_alias: patloop2
  help: "\n\tDeprecated command. Use patloop."
  infer_action: true
patmask:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getPatternMask
        input: []
        input_types: []
        output:
        - OutStringHex(t, 16)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - uint64_t
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setPatternMask
        input:
        - args[0]
        input_types:
        - uint64_t
        output:
        - ToStringHex(arg0, 16)
        require_det_id: true
        store_result_in_t: false
  command_name: patmask
  function_alias: patmask
  help: "[64 bit mask]\n\t[Ctb][Mythen3][Xilinx Ctb] Selects the bits that will have\
    \ a pattern mask applied to the selected patmask for every pattern."
  infer_action: true
  template: true
patnloop:
  actions:
    GET:
      args:
      - arg_types:
        - int
        argc: -1
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: getPatternLoopCycles
        input:
        - level
        input_types:
        - int
        output:
        - level
        - ''' '''
        - OutString(t)
        pattern_command:
          command_name: patnloop
          nGetArgs: 0
          nPutArgs: 1
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        - int
        argc: -1
        cast_input:
        - false
        - true
        check_det_id: false
        convert_det_id: true
        extra_variables:
        - name: nloops
          type: std::string
          value: args[iArg++]
        function: setPatternLoopCycles
        input:
        - level
        - nloops
        input_types:
        - int
        - int
        output:
        - level
        - ''' '''
        - nloops
        pattern_command:
          command_name: patnloop
          nGetArgs: 0
          nPutArgs: 1
        require_det_id: true
        store_result_in_t: false
  command_name: patnloop
  function_alias: patnloop
  help: "[0-6] [n_cycles] \n\t[Ctb][Mythen3][Xilinx Ctb] Number of cycles of the loop\
    \ level provided.\n\t[Mythen3] Level options: 0-3 only."
  infer_action: true
patnloop0:
  actions:
    GET:
      args:
      - arg_types:
        - int
        argc: -1
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: getPatternLoopCycles
        input:
        - level
        input_types:
        - int
        output:
        - OutString(t)
        pattern_command:
          command_name: patnloop
          nGetArgs: 0
          nPutArgs: 1
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        - int
        argc: -1
        cast_input:
        - false
        - true
        check_det_id: false
        convert_det_id: true
        extra_variables:
        - name: nloops
          type: std::string
          value: args[iArg++]
        function: setPatternLoopCycles
        input:
        - level
        - nloops
        input_types:
        - int
        - int
        output:
        - nloops
        pattern_command:
          command_name: patnloop
          nGetArgs: 0
          nPutArgs: 1
        require_det_id: true
        store_result_in_t: false
  command_name: patnloop0
  function_alias: patnloop0
  help: "\n\tDeprecated command. Use patnloop."
  infer_action: true
patnloop1:
  actions:
    GET:
      args:
      - arg_types:
        - int
        argc: -1
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: getPatternLoopCycles
        input:
        - level
        input_types:
        - int
        output:
        - OutString(t)
        pattern_command:
          command_name: patnloop
          nGetArgs: 0
          nPutArgs: 1
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        - int
        argc: -1
        cast_input:
        - false
        - true
        check_det_id: false
        convert_det_id: true
        extra_variables:
        - name: nloops
          type: std::string
          value: args[iArg++]
        function: setPatternLoopCycles
        input:
        - level
        - nloops
        input_types:
        - int
        - int
        output:
        - nloops
        pattern_command:
          command_name: patnloop
          nGetArgs: 0
          nPutArgs: 1
        require_det_id: true
        store_result_in_t: false
  command_name: patnloop1
  function_alias: patnloop1
  help: "\n\tDeprecated command. Use patnloop."
  infer_action: true
patnloop2:
  actions:
    GET:
      args:
      - arg_types:
        - int
        argc: -1
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: getPatternLoopCycles
        input:
        - level
        input_types:
        - int
        output:
        - OutString(t)
        pattern_command:
          command_name: patnloop
          nGetArgs: 0
          nPutArgs: 1
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        - int
        argc: -1
        cast_input:
        - false
        - true
        check_det_id: false
        convert_det_id: true
        extra_variables:
        - name: nloops
          type: std::string
          value: args[iArg++]
        function: setPatternLoopCycles
        input:
        - level
        - nloops
        input_types:
        - int
        - int
        output:
        - nloops
        pattern_command:
          command_name: patnloop
          nGetArgs: 0
          nPutArgs: 1
        require_det_id: true
        store_result_in_t: false
  command_name: patnloop2
  function_alias: patnloop2
  help: "\n\tDeprecated command. Use patnloop."
  infer_action: true
patsetbit:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getPatternBitMask
        input: []
        input_types: []
        output:
        - OutStringHex(t, 16)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - uint64_t
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setPatternBitMask
        input:
        - args[0]
        input_types:
        - uint64_t
        output:
        - ToStringHex(arg0, 16)
        require_det_id: true
        store_result_in_t: false
  command_name: patsetbit
  function_alias: patsetbit
  help: "[64 bit mask]\n\t[Ctb][Mythen3][Xilinx Ctb] Sets the mask applied to every\
    \ pattern to the selected bits."
  infer_action: true
  template: true
patternX:
  actions:
    PUT:
      args:
      - arg_types:
        - std::string
        argc: 1
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: setPattern
        input:
        - args[0]
        input_types:
        - std::string
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: pattern
  function_alias: pattern
  help: "[fname]\n\t[Mythen3][Ctb][Xilinx Ctb] Loads ASCII pattern file directly to\
    \ server (instead of executing line by line)"
  infer_action: true
patternstart:
  actions:
    PUT:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: startPattern
        input: []
        input_types: []
        output:
        - '"successful"'
        require_det_id: true
        store_result_in_t: false
  command_name: patternstart
  function_alias: patternstart
  help: "\n\t[Mythen3] Starts Pattern"
  infer_action: true
  template: true
patwait:
  actions:
    GET:
      args:
      - arg_types:
        - int
        argc: -1
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: getPatternWaitAddr
        input:
        - level
        input_types:
        - int
        output:
        - level
        - ''' '''
        - OutStringHex(t, 4)
        pattern_command:
          command_name: patwait
          nGetArgs: 0
          nPutArgs: 1
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        - int
        argc: -1
        cast_input:
        - false
        - false
        check_det_id: false
        convert_det_id: true
        extra_variables:
        - name: addr
          type: int
          value: StringTo<int>(args[iArg++])
        function: setPatternWaitAddr
        input:
        - level
        - addr
        input_types:
        - int
        - int
        output:
        - level
        - ''' '''
        - ToStringHex(addr, 4)
        pattern_command:
          command_name: patwait
          nGetArgs: 0
          nPutArgs: 1
        require_det_id: true
        store_result_in_t: false
  command_name: patwait
  function_alias: patwait
  help: "[0-6] [addr] \n\t[Ctb][Mythen3][Xilinx Ctb] Wait address for loop level provided.\
    \ \n\t[Mythen3] Level options: 0-3 only."
  infer_action: true
patwait0:
  actions:
    GET:
      args:
      - arg_types:
        - int
        argc: -1
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: getPatternWaitAddr
        input:
        - level
        input_types:
        - int
        output:
        - OutStringHex(t, 4)
        pattern_command:
          command_name: patwait
          nGetArgs: 0
          nPutArgs: 1
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        - int
        argc: -1
        cast_input:
        - false
        - false
        check_det_id: false
        convert_det_id: true
        extra_variables:
        - name: addr
          type: int
          value: StringTo<int>(args[iArg++])
        function: setPatternWaitAddr
        input:
        - level
        - addr
        input_types:
        - int
        - int
        output:
        - ToStringHex(addr, 4)
        pattern_command:
          command_name: patwait
          nGetArgs: 0
          nPutArgs: 1
        require_det_id: true
        store_result_in_t: false
  command_name: patwait0
  function_alias: patwait0
  help: "\n\tDeprecated command. Use patwait."
  infer_action: true
patwait1:
  actions:
    GET:
      args:
      - arg_types:
        - int
        argc: -1
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: getPatternWaitAddr
        input:
        - level
        input_types:
        - int
        output:
        - OutStringHex(t, 4)
        pattern_command:
          command_name: patwait
          nGetArgs: 0
          nPutArgs: 1
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        - int
        argc: -1
        cast_input:
        - false
        - false
        check_det_id: false
        convert_det_id: true
        extra_variables:
        - name: addr
          type: int
          value: StringTo<int>(args[iArg++])
        function: setPatternWaitAddr
        input:
        - level
        - addr
        input_types:
        - int
        - int
        output:
        - ToStringHex(addr, 4)
        pattern_command:
          command_name: patwait
          nGetArgs: 0
          nPutArgs: 1
        require_det_id: true
        store_result_in_t: false
  command_name: patwait1
  function_alias: patwait1
  help: "\n\tDeprecated command. Use patwait."
  infer_action: true
patwait2:
  actions:
    GET:
      args:
      - arg_types:
        - int
        argc: -1
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: getPatternWaitAddr
        input:
        - level
        input_types:
        - int
        output:
        - OutStringHex(t, 4)
        pattern_command:
          command_name: patwait
          nGetArgs: 0
          nPutArgs: 1
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        - int
        argc: -1
        cast_input:
        - false
        - false
        check_det_id: false
        convert_det_id: true
        extra_variables:
        - name: addr
          type: int
          value: StringTo<int>(args[iArg++])
        function: setPatternWaitAddr
        input:
        - level
        - addr
        input_types:
        - int
        - int
        output:
        - ToStringHex(addr, 4)
        pattern_command:
          command_name: patwait
          nGetArgs: 0
          nPutArgs: 1
        require_det_id: true
        store_result_in_t: false
  command_name: patwait2
  function_alias: patwait2
  help: "\n\tDeprecated command. Use patwait."
  infer_action: true
patwaittime:
  actions:
    GET:
      args:
      - arg_types:
        - int
        argc: -1
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: getPatternWaitTime
        input:
        - level
        input_types:
        - int
        output:
        - level
        - ''' '''
        - OutString(t)
        pattern_command:
          command_name: patwaittime
          nGetArgs: 0
          nPutArgs: 1
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        - int
        argc: -1
        cast_input:
        - false
        - false
        check_det_id: false
        convert_det_id: true
        extra_variables:
        - name: waittime
          type: uint64_t
          value: StringTo<uint64_t>(args[iArg++])
        function: setPatternWaitTime
        input:
        - level
        - waittime
        input_types:
        - int
        - int
        output:
        - level
        - ''' '''
        - waittime
        pattern_command:
          command_name: patwaittime
          nGetArgs: 0
          nPutArgs: 1
        require_det_id: true
        store_result_in_t: false
  command_name: patwaittime
  function_alias: patwaittime
  help: "[0-6] [n_clk] \n\t[Ctb][Mythen3][Xilinx Ctb] Wait time in clock cycles for\
    \ the loop provided.\n\t[Mythen3] Level options: 0-3 only."
  infer_action: true
patwaittime0:
  actions:
    GET:
      args:
      - arg_types:
        - int
        argc: -1
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: getPatternWaitTime
        input:
        - level
        input_types:
        - int
        output:
        - OutString(t)
        pattern_command:
          command_name: patwaittime
          nGetArgs: 0
          nPutArgs: 1
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        - int
        argc: -1
        cast_input:
        - false
        - false
        check_det_id: false
        convert_det_id: true
        extra_variables:
        - name: waittime
          type: uint64_t
          value: StringTo<uint64_t>(args[iArg++])
        function: setPatternWaitTime
        input:
        - level
        - waittime
        input_types:
        - int
        - int
        output:
        - waittime
        pattern_command:
          command_name: patwaittime
          nGetArgs: 0
          nPutArgs: 1
        require_det_id: true
        store_result_in_t: false
  command_name: patwaittime0
  function_alias: patwaittime0
  help: "\n\tDeprecated command. Use patwaittime."
  infer_action: true
patwaittime1:
  actions:
    GET:
      args:
      - arg_types:
        - int
        argc: -1
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: getPatternWaitTime
        input:
        - level
        input_types:
        - int
        output:
        - OutString(t)
        pattern_command:
          command_name: patwaittime
          nGetArgs: 0
          nPutArgs: 1
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        - int
        argc: -1
        cast_input:
        - false
        - false
        check_det_id: false
        convert_det_id: true
        extra_variables:
        - name: waittime
          type: uint64_t
          value: StringTo<uint64_t>(args[iArg++])
        function: setPatternWaitTime
        input:
        - level
        - waittime
        input_types:
        - int
        - int
        output:
        - waittime
        pattern_command:
          command_name: patwaittime
          nGetArgs: 0
          nPutArgs: 1
        require_det_id: true
        store_result_in_t: false
  command_name: patwaittime1
  function_alias: patwaittime1
  help: "\n\tDeprecated command. Use patwaittime."
  infer_action: true
patwaittime2:
  actions:
    GET:
      args:
      - arg_types:
        - int
        argc: -1
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: getPatternWaitTime
        input:
        - level
        input_types:
        - int
        output:
        - OutString(t)
        pattern_command:
          command_name: patwaittime
          nGetArgs: 0
          nPutArgs: 1
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        - int
        argc: -1
        cast_input:
        - false
        - false
        check_det_id: false
        convert_det_id: true
        extra_variables:
        - name: waittime
          type: uint64_t
          value: StringTo<uint64_t>(args[iArg++])
        function: setPatternWaitTime
        input:
        - level
        - waittime
        input_types:
        - int
        - int
        output:
        - waittime
        pattern_command:
          command_name: patwaittime
          nGetArgs: 0
          nPutArgs: 1
        require_det_id: true
        store_result_in_t: false
  command_name: patwaittime2
  function_alias: patwaittime2
  help: "\n\tDeprecated command. Use patwaittime."
  infer_action: true
patword:
  actions:
    GET:
      args:
      - arg_types:
        - int
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: getPatternWord
        input:
        - args[0]
        input_types:
        - int
        output:
        - '''['''
        - ToStringHex(arg0, 4)
        - '", "'
        - OutStringHex(t, 16)
        - '"]"'
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        - uint64_t
        argc: 2
        cast_input:
        - true
        - true
        check_det_id: false
        convert_det_id: true
        function: setPatternWord
        input:
        - args[0]
        - args[1]
        input_types:
        - int
        - uint64_t
        output:
        - '''['''
        - ToStringHex(arg0, 4)
        - '", "'
        - ToStringHex(arg1, 16)
        - '"]"'
        require_det_id: true
        store_result_in_t: false
  command_name: patword
  function_alias: patword
  help: "[step or address] [64 bit mask]\n\t[Ctb][Mythen3][Xilinx Ctb] 64 bit pattern\
    \ at address of pattern memory.\n\t[Ctb] read is same as executing pattern"
  infer_action: true
pedestalmode:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getPedestalMode
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - special::pedestal_parameters
        argc: 1
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        exceptions:
        - condition: args[0] != "0"
          message: '"Unknown argument " + args[0] + ". Did you mean 0 to disable pedestal
            mode?"'
        function: setPedestalMode
        input:
        - defs::pedestalParameters()
        input_types:
        - defs::pedestalParameters
        output:
        - ToString(args)
        require_det_id: false
        store_result_in_t: false
      - arg_types:
        - uint8_t
        - uint16_t
        argc: 2
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: setPedestalMode
        input:
        - defs::pedestalParameters(StringTo<uint8_t>(args[0]), StringTo<uint16_t>(args[1]))
        input_types:
        - defs::pedestalParameters
        output:
        - ToString(args)
        require_det_id: false
        store_result_in_t: false
  command_name: pedestalmode
  function_alias: pedestalmode
  help: " [frames<uint8_t>] [loops<uint16_t>]\n\t\t[Jungfrau] Enable pedestal mode.\
    \ \n\t\tThe number of frames or triggers is overwritten by: \n\t\t(#pedestal_frames\
    \ x #pedestal_loops x 2). \n\t\tIn auto timing mode or in trigger mode with #frames\
    \ > 1, \n\t\t#frames is overwritten and #triggers = 1, \n\t\telse #triggers is\
    \ overwritten and #frames = 1. \n\t\tOne cannot set #frames, #triggers or timing\
    \ mode in pedestal mode (exception thrown).\n\tpedestalmode [0]\n\t\t[Jungfrau]\
    \ Disable pedestal mode.\n\t\tDisabling pedestal mode will set back the normal\
    \ mode values of #frames and #triggers."
  infer_action: true
period:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getPeriod
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
      - arg_types:
        - special::time_unit
        argc: 1
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getPeriod
        input: []
        input_types: []
        output:
        - OutString(t , args[0])
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - std::string
        argc: 1
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: setPeriod
        input:
        - converted_time
        input_types:
        - time::ns
        output:
        - args[0]
        require_det_id: true
        separate_time_units:
          input: args[0]
          output:
          - converted_time
          - unit
        store_result_in_t: false
      - arg_types:
        - int
        - special::time_unit
        argc: 2
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        convert_to_time:
          input:
          - args[0]
          - args[1]
          output: converted_time
        function: setPeriod
        input:
        - converted_time
        input_types:
        - time::ns
        output:
        - args[0]
        - args[1]
        require_det_id: true
        store_result_in_t: false
  command_name: period
  function_alias: period
  help: "[duration] [(optional unit) ns|us|ms|s]\n\tPeriod between frames"
  infer_action: true
  template: true
periodl:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getPeriodLeft
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
      - arg_types:
        - special::time_unit
        argc: 1
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getPeriodLeft
        input: []
        input_types: []
        output:
        - OutString(t , args[0])
        require_det_id: true
        store_result_in_t: true
  command_name: periodl
  function_alias: periodl
  help: "\n\t[Gotthard][Jungfrau][Moench][Ctb][Mythen3][Gotthard2][Xilinx Ctb] Period\
    \ left for current frame. \n\t[Gotthard2] only in continuous mode."
  infer_action: true
  template: true
polarity:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getPolarity
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - defs::polarity
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setPolarity
        input:
        - args[0]
        input_types:
        - defs::polarity
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: polarity
  function_alias: polarity
  help: "[pos|neg]\n\t[Mythen3] Sets negative or positive polarity. Default is positive"
  infer_action: true
  template: true
port:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getControlPort
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - uint16_t
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setControlPort
        input:
        - args[0]
        input_types:
        - uint16_t
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: port
  function_alias: port
  help: "[n]\n\tPort number of the control server on detector for detector-client\
    \ tcp interface. Default is 1952. Normally unchanged. Set different ports for\
    \ virtual servers on same pc."
  infer_action: true
  template: true
powerchip:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getPowerChip
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - bool
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setPowerChip
        input:
        - args[0]
        input_types:
        - bool
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: powerchip
  function_alias: powerchip
  help: "[0, 1]\n\t[Jungfrau][Moench][Mythen3][Gotthard2][Xilinx Ctb] Power the chip.\
    \ \n\t[Jungfrau][Moench] Default is 0. Get will return power status. Can be off\
    \ if temperature event occured (temperature over temp_threshold with temp_control\
    \ enabled. Will configure chip (only chip v1.1)\n\t[Mythen3][Gotthard2] Default\
    \ is 1. If module not connected or wrong module, powerchip will fail.\n\t[Xilinx\
    \ Ctb] Default is 0. Also configures the chip if powered on."
  infer_action: true
  template: true
powerindex:
  actions:
    GET:
      args:
      - arg_types:
        - std::string
        argc: 1
        cast_input:
        - false
        check_det_id: true
        convert_det_id: true
        exceptions:
        - condition: det->getDetectorType().squash(defs::GENERIC) != defs::CHIPTESTBOARD
            && det->getDetectorType().squash(defs::GENERIC) != defs::XILINX_CHIPTESTBOARD
          message: cmd + " only allowed for CTB."
        extra_variables:
        - name: index
          type: defs::dacIndex
          value: defs::V_POWER_A
        function: getPowerIndex
        input:
        - args[0]
        input_types:
        - std::string
        output:
        - ToString(static_cast<int>(t) - index)
        require_det_id: false
        store_result_in_t: true
  command_name: powerindex
  function_alias: powerindex
  help: "[name] \n\t\t[Ctb][Xilinx_Ctb] Get the power index for the given name."
  infer_action: true
  template: true
powerlist:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: true
        convert_det_id: true
        exceptions:
        - condition: cmd != "daclist" && det_type != defs::CHIPTESTBOARD && det_type
            != defs::XILINX_CHIPTESTBOARD
          message: cmd + " only allowed for CTB."
        extra_variables:
        - name: det_type
          type: auto
          value: det->getDetectorType().squash(defs::GENERIC);
        function: getPowerNames
        input: []
        input_types: []
        output:
        - ToString(t)
        require_det_id: false
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - std::string
        argc: -1
        cast_input:
        - false
        check_det_id: true
        convert_det_id: true
        exceptions:
        - condition: cmd != "daclist" && det_type != defs::CHIPTESTBOARD && det_type
            != defs::XILINX_CHIPTESTBOARD
          message: cmd + " only allowed for CTB."
        - condition: cmd == "daclist" && det_type != defs::CHIPTESTBOARD && det_type
            != defs::XILINX_CHIPTESTBOARD
          message: '"This detector already has fixed dac names. Cannot change them."'
        extra_variables:
        - name: det_type
          type: auto
          value: det->getDetectorType().squash(defs::GENERIC);
        function: setPowerNames
        input:
        - args
        input_types:
        - std::string
        output:
        - ToString(args)
        require_det_id: false
        store_result_in_t: false
  command_name: powerlist
  function_alias: powerlist
  help: "[powername1 powername2 .. powername4] \n\t\t[Ctb][Xilinx_Ctb] Set the list\
    \ of power names for this board."
  infer_action: true
  template: true
powername:
  actions:
    GET:
      args:
      - arg_types:
        - defs::dacIndex
        argc: 1
        cast_input:
        - false
        check_det_id: true
        convert_det_id: true
        exceptions:
        - condition: det->getDetectorType().squash(defs::GENERIC) != defs::CHIPTESTBOARD
            && det->getDetectorType().squash(defs::GENERIC) != defs::XILINX_CHIPTESTBOARD
          message: cmd + " only allowed for CTB."
        extra_variables:
        - name: index
          type: defs::dacIndex
          value: defs::V_POWER_A
        function: getPowerName
        input:
        - static_cast<defs::dacIndex>(StringTo<int>(args[0]) + index)
        input_types:
        - defs::dacIndex
        output:
        - args[0]
        - ''' '''
        - t
        require_det_id: false
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - defs::dacIndex
        - std::string
        argc: 2
        cast_input:
        - false
        - false
        check_det_id: true
        convert_det_id: true
        exceptions:
        - condition: det->getDetectorType().squash(defs::GENERIC) != defs::CHIPTESTBOARD
            && det->getDetectorType().squash(defs::GENERIC) != defs::XILINX_CHIPTESTBOARD
          message: cmd + " only allowed for CTB."
        extra_variables:
        - name: index
          type: defs::dacIndex
          value: defs::V_POWER_A
        function: setPowerName
        input:
        - static_cast<defs::dacIndex>(StringTo<int>(args[0]) + index)
        - args[1]
        input_types:
        - defs::dacIndex
        - std::string
        output:
        - ToString(args)
        require_det_id: false
        store_result_in_t: false
  command_name: powername
  function_alias: powername
  help: "[0-4][name] \n\t\t[Ctb][Xilinx_Ctb] Set the power at the given position to\
    \ the given name."
  infer_action: true
  template: true
powervalues:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        ctb_output_list:
          GETFCN: getPower
          GETFCNLIST: getPowerList
          GETFCNNAME: getPowerNames
          printable_name: '*name_it++'
          suffix: mV
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: true
  command_name: powervalues
  function_alias: powervalues
  help: "[name] \n\t\t[Ctb][Xilinx_Ctb] Get values of all powers."
  infer_action: true
programfpga:
  actions:
    PUT:
      args:
      - arg_types:
        - special::path
        argc: 1
        cast_input:
        - false
        - true
        check_det_id: false
        convert_det_id: true
        function: programFPGA
        input:
        - args[0]
        - '"0"'
        input_types:
        - std::string
        - bool
        output:
        - '"successful"'
        require_det_id: true
        store_result_in_t: false
      - arg_types:
        - special::path
        - special::force-delete-normal-file
        argc: 2
        cast_input:
        - false
        - true
        check_det_id: false
        convert_det_id: true
        exceptions:
        - condition: args[1] != "--force-delete-normal-file"
          message: '"Could not scan second argument. Did you mean --force-delete-normal-file?"'
        function: programFPGA
        input:
        - args[0]
        - '"1"'
        input_types:
        - std::string
        - bool
        output:
        - '"successful"'
        require_det_id: true
        store_result_in_t: false
  command_name: programfpga
  function_alias: programfpga
  help: "[fname.pof | fname.rbf (full path)][(opitonal)--force-delete-normal-file]\n\
    \t[Jungfrau][Moench][Ctb] Programs FPGA from pof file (full path). Then, detector\
    \ controller is rebooted. \n\t\tUse --force-delete-normal-file argument, if normal\
    \ file found in device tree, it must be deleted, a new device drive created and\
    \ programming continued.\n\t[Mythen3][Gotthard2] Programs FPGA from rbf file (full\
    \ path). Then, detector controller is rebooted."
  infer_action: true
pulse:
  actions:
    PUT:
      args:
      - arg_types:
        - int
        - int
        - int
        argc: 3
        cast_input:
        - true
        - false
        check_det_id: false
        convert_det_id: true
        extra_variables:
        - name: c
          type: defs::xy
          value: defs::xy(StringTo<int>(args[1]), StringTo<int>(args[2]))
        function: pulsePixel
        input:
        - args[0]
        - c
        input_types:
        - int
        - defs::xy
        output:
        - ToString(args)
        require_det_id: true
        store_result_in_t: false
  command_name: pulse
  function_alias: pulse
  help: "[n_times] [x] [y]\n\t[Eiger] Pulse pixel n number of times at coordinates\
    \ (x, y). Advanced User!"
  infer_action: true
  template: true
pulsechip:
  actions:
    PUT:
      args:
      - arg_types:
        - int
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: pulseChip
        input:
        - args[0]
        input_types:
        - int
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: pulsechip
  function_alias: pulsechip
  help: "[n_times] \n\t[Eiger] Pulse chip n times. If n is -1, resets to normal mode\
    \ (reset chip completely at start of acquisition, where partialreset = 0). Advanced\
    \ User!"
  infer_action: true
pulsenmove:
  actions:
    PUT:
      args:
      - arg_types:
        - int
        - int
        - int
        argc: 3
        cast_input:
        - true
        - false
        check_det_id: false
        convert_det_id: true
        extra_variables:
        - name: c
          type: defs::xy
          value: defs::xy(StringTo<int>(args[1]), StringTo<int>(args[2]))
        function: pulsePixelNMove
        input:
        - args[0]
        - c
        input_types:
        - int
        - defs::xy
        output:
        - ToString(args)
        require_det_id: true
        store_result_in_t: false
  command_name: pulsenmove
  function_alias: pulsenmove
  help: "[n_times] [x] [y]\n\t[Eiger] Pulse pixel n number of times and moves relatively\
    \ by (x, y). Advanced User!"
  infer_action: true
  template: true
pumpprobe:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getPumpProbe
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - bool
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setPumpProbe
        input:
        - args[0]
        input_types:
        - bool
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: pumpprobe
  function_alias: pumpprobe
  help: "[0, 1]\n\t[Mythen3] Enables or disables pump probe mode. Default is disabled.\
    \ Pump probe mode only enables vth2. Disabling sets back to previous value."
  infer_action: true
  template: true
quad:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getQuad
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - bool
        argc: 1
        cast_input:
        - true
        check_det_id: true
        convert_det_id: true
        function: setQuad
        input:
        - args[0]
        input_types:
        - bool
        output:
        - args.front()
        require_det_id: false
        store_result_in_t: false
  command_name: quad
  function_alias: quad
  help: "[0, 1]\n\t[Eiger] Sets detector size to a quad. 0 (disabled) is default.\
    \ (Specific hardware required)."
  infer_action: true
ratecorr:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        argc: 1
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: false
  command_name: ratecorr
  function_alias: ratecorr
  help: ''
  infer_action: true
  is_description: true
readnrows:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getReadNRows
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setReadNRows
        input:
        - args[0]
        input_types:
        - int
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: readnrows
  function_alias: readnrows
  help: "\n\t[1-256]\n\t\t[Eiger] Number of rows to readout per half module starting\
    \ from the centre. Options: 0 - 256. 256 is default. The permissible values depend\
    \ on dynamic range and 10Gbe enabled.\n\t[8-512 (multiple of 8)]\n\t\t[Jungfrau]\
    \ Number of rows per module starting from the centre. Options: 8 - 512, must be\
    \ multiples of 8. Default is 512.\n\t\t[Moench] Number of rows per module starting\
    \ from the centre. Options:16 - 400, must be multiples of 16. Default is 400."
  infer_action: true
  template: true
readout:
  actions:
    PUT:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: true
        convert_det_id: true
        function: startDetectorReadout
        input: []
        input_types: []
        output:
        - '"successful"'
        require_det_id: false
        store_result_in_t: false
  command_name: readout
  function_alias: readout
  help: "\n\t[Mythen3] Starts detector readout. Status changes to TRANSMITTING and\
    \ automatically returns to idle at the end of readout."
  infer_action: true
  template: true
readoutspeed:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        exceptions:
        - condition: det_type == defs::CHIPTESTBOARD || det_type == defs::XILINX_CHIPTESTBOARD
          message: '"ReadoutSpeed not implemented. Did you mean runclk?"'
        extra_variables:
        - name: det_type
          type: auto
          value: det->getDetectorType().squash(defs::GENERIC);
        function: getReadoutSpeed
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - defs::speedLevel
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        exceptions:
        - condition: det_type == defs::CHIPTESTBOARD || det_type == defs::XILINX_CHIPTESTBOARD
          message: '"ReadoutSpeed not implemented. Did you mean runclk?"'
        extra_variables:
        - name: det_type
          type: auto
          value: det->getDetectorType().squash(defs::GENERIC);
        function: setReadoutSpeed
        input:
        - args[0]
        input_types:
        - defs::speedLevel
        output:
        - ToString(StringTo<defs::speedLevel>(args[0]))
        require_det_id: true
        store_result_in_t: false
  command_name: readoutspeed
  function_alias: readoutspeed
  help: "\n\t[0 or full_speed|1 or half_speed|2 or quarter_speed]\n\t[Eiger][Jungfrau][Moench][Mythen3]\
    \ Readout speed of chip.\n\t[Eiger][Moench] Default speed is full_speed.\n\t[Jungfrau][Mythen3]\
    \ Default speed is half_speed. \n\t[Jungfrau] full_speed option only available\
    \ from v2.0 boards and is recommended to set number of interfaces to 2. Also overwrites\
    \ adcphase to recommended default.\n\t [144|108]\n\t\t[Gotthard2] Readout speed\
    \ of chip in MHz. Default is 108."
  infer_action: true
readoutspeedlist:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getReadoutSpeedList
        input: []
        input_types: []
        output:
        - ToString(t)
        require_det_id: false
        store_result_in_t: true
  command_name: readoutspeedlist
  function_alias: readoutspeedlist
  help: "\n\tList of readout speed levels implemented for this detector."
  infer_action: true
  template: true
rebootcontroller:
  actions:
    PUT:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: rebootController
        input: []
        input_types: []
        output:
        - '"successful"'
        require_det_id: true
        store_result_in_t: false
  command_name: rebootcontroller
  function_alias: rebootcontroller
  help: "\n\t[Jungfrau][Moench][Ctb][Gotthard][Mythen3][Gotthard2][Xilinx Ctb] Reboot\
    \ controller of detector."
  infer_action: true
  template: true
reg:
  actions:
    GET:
      args:
      - arg_types:
        - uint32_t
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: readRegister
        input:
        - args[0]
        input_types:
        - uint32_t
        output:
        - OutStringHex(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - uint32_t
        - uint32_t
        argc: 2
        cast_input:
        - true
        - true
        - true
        check_det_id: false
        convert_det_id: true
        function: writeRegister
        input:
        - args[0]
        - args[1]
        - '"0"'
        input_types:
        - uint32_t
        - uint32_t
        - bool
        output:
        - '"["'
        - args[0]
        - '", "'
        - args[1]
        - '"]"'
        require_det_id: true
        store_result_in_t: false
      - arg_types:
        - uint32_t
        - uint32_t
        - special::validate
        argc: 3
        cast_input:
        - true
        - true
        - true
        check_det_id: false
        convert_det_id: true
        exceptions:
        - condition: args[2] != "--validate"
          message: '"Could not scan third argument. Did you mean --validate?"'
        function: writeRegister
        input:
        - args[0]
        - args[1]
        - '"1"'
        input_types:
        - uint32_t
        - uint32_t
        - bool
        output:
        - '"["'
        - args[0]
        - '", "'
        - args[1]
        - '"]"'
        require_det_id: true
        store_result_in_t: false
  command_name: reg
  function_alias: reg
  help: "[address] [32 bit value][(optional)--validate]\n\t[Mythen3][Gotthard2] Reads/writes\
    \ to a 32 bit register in hex. Advanced Function!\n\tGoes to stop server. Hence,\
    \ can be called while calling blocking acquire().\n\t\t Use --validate to force\
    \ validation when writing to it.\n\t[Eiger] +0x100 for only left, +0x200 for only\
    \ right."
  infer_action: true
resetdacs:
  actions:
    PUT:
      args:
      - arg_types:
        - special::hard
        argc: 1
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        exceptions:
        - condition: args[0] != "hard"
          message: '"Unknown argument " + args[0] + ". Did you mean hard?"'
        function: resetToDefaultDacs
        input:
        - '"1"'
        input_types:
        - bool
        output:
        - '"successful"'
        require_det_id: true
        store_result_in_t: false
      - arg_types: []
        argc: 0
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: resetToDefaultDacs
        input:
        - '"0"'
        input_types:
        - bool
        output:
        - '"successful"'
        require_det_id: true
        store_result_in_t: false
  command_name: resetdacs
  function_alias: resetdacs
  help: "[(optional) hard] \n\t[Eiger][Jungfrau][Moench][Gotthard][Gotthard2][Mythen3]Reset\
    \ dac values to the defaults. A 'hard' optional reset will reset the dacs to the\
    \ hardcoded defaults in on-board detector server."
  infer_action: true
resetfpga:
  actions:
    PUT:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: resetFPGA
        input: []
        input_types: []
        output:
        - '"successful"'
        require_det_id: true
        store_result_in_t: false
  command_name: resetfpga
  function_alias: resetfpga
  help: "\n\t[Jungfrau][Moench][Ctb][Xilinx Ctb] Reset FPGA."
  infer_action: true
  template: true
roi:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getROI
        input: []
        input_types: []
        output:
        - t
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        - int
        argc: 2
        cast_input:
        - false
        check_det_id: false
        convert_det_id: false
        exceptions:
        - condition: det_id == -1 && det->size() > 1
          message: '"Cannot execute ROI at multi module level"'
        extra_variables:
        - name: t
          type: defs::ROI
          value: defs::ROI(StringTo<int>(args[0]), StringTo<int>(args[1]))
        function: setROI
        input:
        - t
        input_types:
        - defs::ROI
        output:
        - t
        require_det_id: true
        store_result_in_t: false
  command_name: roi
  function_alias: roi
  help: "[xmin] [xmax] \n\t[Gotthard] Region of interest in detector.\n\tOptions:\
    \ Only a single ROI per module. \n\tEither all channels or a single adc or 2 chips\
    \ (256 channels). Default is all channels enabled (-1 -1). "
  infer_action: true
romode:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getReadoutMode
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - defs::readoutMode
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setReadoutMode
        input:
        - args[0]
        input_types:
        - defs::readoutMode
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: romode
  function_alias: romode
  help: "[analog|digital|analog_digital|transceiver|digital_transceiver]\n\t[Ctb][xilinx\
    \ Ctb] Readout mode. [Ctb] Default is analog. [Xilinx Ctb] Default is Transceiver\
    \ (only one implemented so far)"
  infer_action: true
  template: true
row:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getRow
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setRow
        input:
        - args[0]
        input_types:
        - int
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: row
  function_alias: row
  help: "[value]\n\tSet Detector row (udp header) to value. \n\tGui uses it to rearrange\
    \ for complete image"
  infer_action: true
  template: true
runclk:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getRUNClock
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setRUNClock
        input:
        - args[0]
        input_types:
        - int
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: runclk
  function_alias: runclk
  help: "[n_clk in MHz]\n\t[Ctb] Run clock in MHz."
  infer_action: true
  template: true
runtime:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getActualTime
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
      - arg_types:
        - special::time_unit
        argc: 1
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getActualTime
        input: []
        input_types: []
        output:
        - OutString(t , args[0])
        require_det_id: true
        store_result_in_t: true
  command_name: runtime
  function_alias: runtime
  help: "[(optional unit) ns|us|ms|s]\n\t[Jungfrau][Moench][Mythen3][Gotthard2][Ctb][Xilinx\
    \ Ctb] Time from detector start up.\n\t[Gotthard2] not in burst and auto mode."
  infer_action: true
  template: true
rx_arping:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getRxArping
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - bool
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setRxArping
        input:
        - args[0]
        input_types:
        - bool
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: rx_arping
  function_alias: rx_arping
  help: "[0, 1]\n\tStarts a thread in slsReceiver to arping the interface it is listening\
    \ to every minute. Useful in 10G mode."
  infer_action: true
  template: true
rx_clearroi:
  actions:
    PUT:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: true
        convert_det_id: true
        function: clearRxROI
        input: []
        input_types: []
        output:
        - '"successful"'
        require_det_id: false
        store_result_in_t: false
  command_name: rx_clearroi
  function_alias: rx_clearroi
  help: "\n\tResets Region of interest in receiver. Default is all channels/pixels\
    \ enabled."
  infer_action: true
  template: true
rx_dbitlist:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: true
    PUT:
      args:
      - arg_types: []
        argc: -1
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: false
  command_name: rx_dbitlist
  function_alias: rx_dbitlist
  help: ''
  infer_action: true
  is_description: true
rx_dbitoffset:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getRxDbitOffset
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setRxDbitOffset
        input:
        - args[0]
        input_types:
        - int
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: rx_dbitoffset
  function_alias: rx_dbitoffset
  help: "[n_bytes]\n\t[Ctb] Offset in bytes in digital data to skip in receiver."
  infer_action: true
  template: true
rx_discardpolicy:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getRxFrameDiscardPolicy
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - defs::frameDiscardPolicy
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setRxFrameDiscardPolicy
        input:
        - args[0]
        input_types:
        - defs::frameDiscardPolicy
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: rx_discardpolicy
  function_alias: rx_discardpolicy
  help: "[nodiscard (default)|discardempty|discardpartial(fastest)]\n\tFrame discard\
    \ policy of receiver. nodiscard does not discard frames, discardempty discards\
    \ empty frames, discardpartial discards partial frames."
  infer_action: true
  template: true
rx_fifodepth:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getRxFifoDepth
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setRxFifoDepth
        input:
        - args[0]
        input_types:
        - int
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: rx_fifodepth
  function_alias: rx_fifodepth
  help: "[n_frames]\n\tSet the number of frames in the receiver fifo depth (buffer\
    \ between listener and writer threads)."
  infer_action: true
  template: true
rx_frameindex:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getRxCurrentFrameIndex
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
  command_name: rx_frameindex
  function_alias: rx_frameindex
  help: "\n\tCurrent frame index received for each port in receiver during acquisition."
  infer_action: true
  template: true
rx_framescaught:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getFramesCaught
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
  command_name: rx_framescaught
  function_alias: rx_framescaught
  help: "\n\tNumber of frames caught by each port in receiver."
  infer_action: true
  template: true
rx_framesperfile:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getFramesPerFile
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setFramesPerFile
        input:
        - args[0]
        input_types:
        - int
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: rx_framesperfile
  function_alias: rx_framesperfile
  help: "[n_frames]\n\tNumber of frames per file in receiver in an acquisition. Default\
    \ depends on detector type. 0 is infinite or all frames in single file."
  infer_action: true
  template: true
rx_hostname:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: true
    PUT:
      args:
      - arg_types: []
        argc: -1
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: false
  command_name: rx_hostname
  function_alias: rx_hostname
  help: ''
  infer_action: true
  is_description: true
rx_jsonaddheader:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: true
    PUT:
      args:
      - arg_types: []
        argc: -1
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: false
  command_name: rx_jsonaddheader
  function_alias: rx_jsonaddheader
  help: ''
  infer_action: true
  is_description: true
rx_jsonpara:
  actions:
    GET:
      args:
      - arg_types:
        - std::string
        argc: 1
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: getAdditionalJsonParameter
        input:
        - args[0]
        input_types:
        - std::string
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - std::string
        argc: 1
        cast_input:
        - false
        - false
        check_det_id: false
        convert_det_id: true
        function: setAdditionalJsonParameter
        input:
        - args[0]
        - '""'
        input_types:
        - std::string
        - std::string
        output:
        - args[0]
        - '" deleted"'
        require_det_id: true
        store_result_in_t: false
      - arg_types:
        - std::string
        - std::string
        argc: 2
        cast_input:
        - false
        - false
        check_det_id: false
        convert_det_id: true
        function: setAdditionalJsonParameter
        input:
        - args[0]
        - args[1]
        input_types:
        - std::string
        - std::string
        output:
        - '"{"'
        - args[0]
        - '": "'
        - args[1]
        - '"}"'
        require_det_id: true
        store_result_in_t: false
  command_name: rx_jsonpara
  function_alias: rx_jsonpara
  help: "[key1] [value1]\n\t[Receiver] Additional json header parameter streamed out\
    \ from receiver. If not found in header, the pair is appended. An empty values\
    \ deletes parameter. Max 20 characters for each key/value."
  infer_action: true
rx_lastclient:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getRxLastClientIP
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
  command_name: rx_lastclient
  function_alias: rx_lastclient
  help: "\n\tClient IP Address that last communicated with the receiver."
  infer_action: true
  template: true
rx_lock:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getRxLock
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - bool
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setRxLock
        input:
        - args[0]
        input_types:
        - bool
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: rx_lock
  function_alias: rx_lock
  help: "[0, 1]\n\tLock receiver to one client IP, 1 locks, 0 unlocks. Default is\
    \ unlocked."
  infer_action: true
  template: true
rx_missingpackets:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getNumMissingPackets
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
  command_name: rx_missingpackets
  function_alias: rx_missingpackets
  help: "\n\tNumber of missing packets for receiver. If negative, they are packets\
    \ in excess."
  infer_action: true
  template: true
rx_padding:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getPartialFramesPadding
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - bool
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setPartialFramesPadding
        input:
        - args[0]
        input_types:
        - bool
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: rx_padding
  function_alias: rx_padding
  help: "[0, 1]\n\tPartial frames padding enable in the receiver. Default: enabled.\
    \ Disabling is fastest."
  infer_action: true
  template: true
rx_printconfig:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: printRxConfiguration
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
  command_name: rx_printconfig
  function_alias: rx_printconfig
  help: "\n\tPrints the receiver configuration."
  infer_action: true
  template: true
rx_realudpsocksize:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getRxRealUDPSocketBufferSize
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
  command_name: rx_realudpsocksize
  function_alias: rx_realudpsocksize
  help: "\n\tActual udp socket buffer size. Double the size of rx_udpsocksize due\
    \ to kernel bookkeeping."
  infer_action: true
  template: true
rx_roi:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        - int
        argc: 2
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: false
      - arg_types:
        - int
        - int
        - int
        - int
        argc: 4
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: false
  command_name: rx_roi
  function_alias: rx_roi
  help: ''
  infer_action: true
  is_description: true
rx_silent:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getRxSilentMode
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - bool
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setRxSilentMode
        input:
        - args[0]
        input_types:
        - bool
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: rx_silent
  function_alias: rx_silent
  help: "[0, 1]\n\tSwitch on or off receiver text output during acquisition."
  infer_action: true
  template: true
rx_start:
  actions:
    PUT:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: true
        convert_det_id: true
        function: startReceiver
        input: []
        input_types: []
        output:
        - '"successful"'
        require_det_id: false
        store_result_in_t: false
  command_name: rx_start
  function_alias: rx_start
  help: "\n\tStarts receiver listener for detector data packets and create a data\
    \ file (if file write enabled)."
  infer_action: true
  template: true
rx_status:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getReceiverStatus
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types: []
        argc: -1
        cast_input: []
        check_det_id: false
        convert_det_id: true
        exceptions:
        - condition: 'true'
          message: '"Cannot put. Did you mean to use command: \"rx_start\" or \"rx_stop\"?"'
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: false
  command_name: rx_status
  function_alias: rx_status
  help: "[running, idle, transmitting]\n\tReceiver listener status."
  infer_action: true
rx_stop:
  actions:
    PUT:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: true
        convert_det_id: true
        function: stopReceiver
        input: []
        input_types: []
        output:
        - '"successful"'
        require_det_id: false
        store_result_in_t: false
  command_name: rx_stop
  function_alias: rx_stop
  help: "\n\tStops receiver listener for detector data packets and closes current\
    \ data file (if file write enabled)."
  infer_action: true
  template: true
rx_tcpport:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getRxPort
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - uint16_t
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: false
        function: setRxPort
        input:
        - args[0]
        input_types:
        - uint16_t
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: rx_tcpport
  function_alias: rx_tcpport
  help: "[port]\n\tTCP port for client-receiver communication. Default is 1954. Must\
    \ be different if multiple receivers on same pc. Must be first command to set\
    \ a receiver parameter. Multi command will automatically increment for individual\
    \ modules."
  infer_action: true
  template: true
rx_threads:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getRxThreadIds
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
  command_name: rx_threads
  function_alias: rx_threads
  help: "\n\tGet kernel thread ids from the receiver in order of [parent, tcp, listener\
    \ 0, processor 0, streamer 0, listener 1, processor 1, streamer 1, arping]. If\
    \ no streamer yet or there is no second interface, it gives 0 in its place."
  infer_action: true
  template: true
rx_udpsocksize:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getRxUDPSocketBufferSize
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setRxUDPSocketBufferSize
        input:
        - args[0]
        input_types:
        - int
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: rx_udpsocksize
  function_alias: rx_udpsocksize
  help: "[n_size]\n\tUDP socket buffer size in receiver. Tune rmem_default and rmem_max\
    \ accordingly. Max value is INT_MAX/2."
  infer_action: true
  template: true
rx_version:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getReceiverVersion
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
  command_name: rx_version
  function_alias: rx_version
  help: "\n\tReceiver version"
  infer_action: true
  template: true
rx_zmqfreq:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getRxZmqFrequency
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setRxZmqFrequency
        input:
        - args[0]
        input_types:
        - int
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: rx_zmqfreq
  function_alias: rx_zmqfreq
  help: "[nth frame]\n\tFrequency of frames streamed out from receiver via zmq\n\t\
    Default: 1, Means every frame is streamed out. \n\tIf 2, every second frame is\
    \ streamed out. \n\tIf 0, streaming timer is the timeout, after which current\
    \ frame is sent out. (default timeout is 500 ms). Usually used for gui purposes."
  infer_action: true
  template: true
rx_zmqhwm:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getRxZmqHwm
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        argc: 1
        cast_input:
        - true
        check_det_id: true
        convert_det_id: true
        function: setRxZmqHwm
        input:
        - args[0]
        input_types:
        - int
        output:
        - args.front()
        require_det_id: false
        store_result_in_t: false
  command_name: rx_zmqhwm
  function_alias: rx_zmqhwm
  help: "[n_value]\n\tReceiver's zmq send high water mark. Default is the zmq library's\
    \ default (1000). This is a high number and can be set to 2 for gui purposes.\
    \ One must also set the client's receive high water mark to similar value. Final\
    \ effect is sum of them. Also restarts receiver zmq streaming if enabled. Can\
    \ set to -1 to set default value."
  infer_action: true
  template: true
rx_zmqip:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: true
    PUT:
      args:
      - arg_types: []
        argc: -1
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: false
  command_name: rx_zmqip
  function_alias: rx_zmqip
  help: ''
  infer_action: true
  is_description: true
rx_zmqport:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getRxZmqPort
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - uint16_t
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: false
        function: setRxZmqPort
        input:
        - args[0]
        input_types:
        - uint16_t
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: rx_zmqport
  function_alias: rx_zmqport
  help: "[port]\n\tZmq port for data to be streamed out of the receiver. Also restarts\
    \ receiver zmq streaming if enabled. Default is 30001. Modified only when using\
    \ an intermediate process between receiver and client(gui). Must be different\
    \ for every detector (and udp port). Multi command will automatically increment\
    \ for individual modules."
  infer_action: true
  template: true
rx_zmqstartfnum:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getRxZmqStartingFrame
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setRxZmqStartingFrame
        input:
        - args[0]
        input_types:
        - int
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: rx_zmqstartfnum
  function_alias: rx_zmqstartfnum
  help: "[fnum]\n\tThe starting frame index to stream out. 0 by default, which streams\
    \ the first frame in an acquisition, and then depending on the rx zmq frequency/\
    \ timer"
  infer_action: true
  template: true
rx_zmqstream:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getRxZmqDataStream
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - bool
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setRxZmqDataStream
        input:
        - args[0]
        input_types:
        - bool
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: rx_zmqstream
  function_alias: rx_zmqstream
  help: "[0, 1]\n\tEnable/ disable data streaming from receiver via zmq (eg. to GUI\
    \ or to another process for further processing). This creates/ destroys zmq streamer\
    \ threads in receiver. \n\tSwitching to Gui automatically enables data streaming\
    \ in receiver. \n\tSwitching back to command line acquire will require disabling\
    \ data streaming in receiver for fast applications. "
  infer_action: true
  template: true
samples:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        argc: 1
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: false
  command_name: samples
  function_alias: samples
  help: ''
  infer_action: true
  is_description: true
savepattern:
  actions:
    PUT:
      args:
      - arg_types:
        - special::path
        argc: 1
        cast_input:
        - false
        check_det_id: true
        convert_det_id: true
        function: savePattern
        input:
        - args[0]
        input_types:
        - std::string
        output:
        - args.front()
        require_det_id: false
        store_result_in_t: false
  command_name: savepattern
  function_alias: savepattern
  help: "\n\t[Ctb][Mythen3][Xilinx Ctb] Saves pattern to file (ascii). \n\t[Ctb] Also\
    \ executes pattern."
  infer_action: true
  template: true
scan:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getScan
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        argc: 1
        cast_input:
        - false
        check_det_id: true
        convert_det_id: true
        exceptions:
        - condition: StringTo<int>(args[0]) != 0
          message: '"Unknown argument " + args[0] + ". Did you mean 0 to disable scan?"'
        function: setScan
        input:
        - defs::scanParameters()
        input_types:
        - auto
        output:
        - ToString(args)
        require_det_id: false
        store_result_in_t: false
      - arg_types:
        - defs::dacIndex
        - int
        - int
        - int
        argc: 4
        cast_input:
        - false
        check_det_id: true
        convert_det_id: true
        function: setScan
        input:
        - defs::scanParameters(StringTo<defs::dacIndex>(args[0]), StringTo<int>(args[1]),
          StringTo<int>(args[2]), StringTo<int>(args[3]))
        input_types:
        - auto
        output:
        - ToString(args)
        require_det_id: false
        store_result_in_t: false
      - arg_types:
        - defs::dacIndex
        - int
        - int
        - int
        - std::string
        argc: 5
        cast_input:
        - false
        check_det_id: true
        convert_det_id: true
        function: setScan
        input:
        - defs::scanParameters(StringTo<defs::dacIndex>(args[0]), StringTo<int>(args[1]),
          StringTo<int>(args[2]), StringTo<int>(args[3]), t)
        input_types:
        - auto
        output:
        - ToString(args)
        require_det_id: false
        separate_time_units:
          input: args[4]
          output:
          - t
          - unit
        store_result_in_t: false
  command_name: scan
  function_alias: scan
  help: "[dac_name|0|trimbits] [start_val] [stop_val] [step_size] [dac settling time\
    \ ns|us|ms|s]\n\tEnables/ disables scans for dac and trimbits \n\tEnabling scan\
    \ sets number of frames to number of steps in receiver. \n\tTo cancel scan configuration,\
    \ set dac to '0', which also sets number of frames to 1. \n\t[Eiger][Mythen3]\
    \ Use trimbits as dac name for a trimbit scan."
  infer_action: true
scanerrmsg:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getScanErrorMessage
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
  command_name: scanerrmsg
  function_alias: scanerrmsg
  help: "\n\tGets Scan error message if scan ended in error for non blocking acquisitions."
  infer_action: true
  template: true
selinterface:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getSelectedUDPInterface
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - bool
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: selectUDPInterface
        input:
        - args[0]
        input_types:
        - bool
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: selinterface
  function_alias: selinterface
  help: "[0, 1]\n\t[Jungfrau][Moench] The udp interface to stream data from detector.\
    \ Effective only when number of interfaces is 1. Default: 0 (outer)"
  infer_action: true
  template: true
serialnumber:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getSerialNumber
        input: []
        input_types: []
        output:
        - OutStringHex(t)
        require_det_id: true
        store_result_in_t: true
  command_name: serialnumber
  function_alias: serialnumber
  help: "\n\t[Jungfrau][Moench][Gotthard][Mythen3][Gotthard2][Ctb]\n\tSerial number\
    \ of detector."
  infer_action: true
  template: true
setbit:
  actions:
    PUT:
      args:
      - arg_types:
        - uint32_t
        - int
        argc: 2
        cast_input:
        - true
        - true
        - true
        check_det_id: false
        convert_det_id: true
        exceptions:
        - condition: StringTo<int>(args[1]) < 0 || StringTo<int>(args[1]) > 31
          message: '"Bit number out of range: " + args[1]'
        function: setBit
        input:
        - args[0]
        - args[1]
        - '"0"'
        input_types:
        - uint32_t
        - int
        - bool
        output:
        - '"["'
        - args[0]
        - '", "'
        - args[1]
        - '"]"'
        require_det_id: true
        store_result_in_t: false
      - arg_types:
        - uint32_t
        - int
        - special::validate
        argc: 3
        cast_input:
        - true
        - true
        - true
        check_det_id: false
        convert_det_id: true
        exceptions:
        - condition: StringTo<int>(args[1]) < 0 || StringTo<int>(args[1]) > 31
          message: '"Bit number out of range: " + args[1]'
        - condition: args[2] != "--validate"
          message: '"Could not scan third argument. Did you mean --validate?"'
        function: setBit
        input:
        - args[0]
        - args[1]
        - '"1"'
        input_types:
        - uint32_t
        - int
        - bool
        output:
        - '"["'
        - args[0]
        - '", "'
        - args[1]
        - '"]"'
        require_det_id: true
        store_result_in_t: false
  command_name: setbit
  function_alias: setbit
  help: "[reg address in hex] [bit index]\n\tSets bit in address.\n\tUse --validate\
    \ to force validation."
  infer_action: true
  template: true
settings:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getSettings
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - defs::detectorSettings
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setSettings
        input:
        - args[0]
        input_types:
        - defs::detectorSettings
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: settings
  function_alias: settings
  help: "[standard, fast, highgain, dynamicgain, lowgain, mediumgain, veryhighgain,\
    \ highgain0, fixgain1, fixgain2, forceswitchg1, forceswitchg2, verylowgain, g1_hg,\
    \ g1_lg, g2_hc_hg, g2_hc_lg, g2_lc_hg, g2_lc_lg, g4_hg, g4_lg, gain0]\n\t Detector\
    \ Settings\n\t[Jungfrau] - [ gain0 | highgain0]\n\t[Gotthard] - [dynamicgain |\
    \ highgain | lowgain | mediumgain | veryhighgain]\n\t[Gotthard] Also loads default\
    \ dacs on to the detector.\n\t[Gotthard2] - [dynamicgain | fixgain1 | fixgain2]\n\
    \t[Mythen3] - [standard | fast | highgain] Also changes vrshaper and vrpreamp.\
    \ \n\t[Eiger] Use threshold or thresholdnotb. \n\t[Eiger] threshold and settings\
    \ loaded from file found in settingspath. \n\t[Moench] - [g1_hg | g1_lg | g2_hc_hg\
    \ | g2_hc_lg | g2_lc_hg | g2_lc_lg | g4_hg | g4_lg]"
  infer_action: true
  template: true
settingslist:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getSettingsList
        input: []
        input_types: []
        output:
        - ToString(t)
        require_det_id: false
        store_result_in_t: true
  command_name: settingslist
  function_alias: settingslist
  help: "\n\tList of settings implemented for this detector."
  infer_action: true
  template: true
settingspath:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getSettingsPath
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - special::path
        argc: 1
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: setSettingsPath
        input:
        - args[0]
        input_types:
        - std::string
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: settingspath
  function_alias: settingspath
  help: "[path]\n\t[Eiger][Mythen3] Directory where settings files are loaded from/to."
  infer_action: true
  template: true
signalindex:
  actions:
    GET:
      args:
      - arg_types:
        - std::string
        argc: 1
        cast_input:
        - false
        check_det_id: true
        convert_det_id: true
        exceptions:
        - condition: det->getDetectorType().squash(defs::GENERIC) != defs::CHIPTESTBOARD
            && det->getDetectorType().squash(defs::GENERIC) != defs::XILINX_CHIPTESTBOARD
          message: cmd + " only allowed for CTB."
        function: getSignalIndex
        input:
        - args[0]
        input_types:
        - std::string
        output:
        - static_cast<int>(t)
        require_det_id: false
        store_result_in_t: true
  command_name: signalindex
  function_alias: signalindex
  help: "[name] \n\t\t[Ctb][Xilinx_Ctb] Get the signal index for the given name."
  infer_action: true
  template: true
signallist:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: true
        convert_det_id: true
        exceptions:
        - condition: cmd != "daclist" && det_type != defs::CHIPTESTBOARD && det_type
            != defs::XILINX_CHIPTESTBOARD
          message: cmd + " only allowed for CTB."
        extra_variables:
        - name: det_type
          type: auto
          value: det->getDetectorType().squash(defs::GENERIC);
        function: getSignalNames
        input: []
        input_types: []
        output:
        - ToString(t)
        require_det_id: false
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - std::string
        argc: -1
        cast_input:
        - false
        check_det_id: true
        convert_det_id: true
        exceptions:
        - condition: cmd != "daclist" && det_type != defs::CHIPTESTBOARD && det_type
            != defs::XILINX_CHIPTESTBOARD
          message: cmd + " only allowed for CTB."
        - condition: cmd == "daclist" && det_type != defs::CHIPTESTBOARD && det_type
            != defs::XILINX_CHIPTESTBOARD
          message: '"This detector already has fixed dac names. Cannot change them."'
        extra_variables:
        - name: det_type
          type: auto
          value: det->getDetectorType().squash(defs::GENERIC);
        function: setSignalNames
        input:
        - args
        input_types:
        - std::string
        output:
        - ToString(args)
        require_det_id: false
        store_result_in_t: false
  command_name: signallist
  function_alias: signallist
  help: "[signalname1 signalname2 .. signalname63] \n\t\t[Ctb][Xilinx_Ctb] Set the\
    \ list of signal names for this board."
  infer_action: true
  template: true
signalname:
  actions:
    GET:
      args:
      - arg_types:
        - int
        argc: 1
        cast_input:
        - true
        check_det_id: true
        convert_det_id: true
        exceptions:
        - condition: det->getDetectorType().squash(defs::GENERIC) != defs::CHIPTESTBOARD
            && det->getDetectorType().squash(defs::GENERIC) != defs::XILINX_CHIPTESTBOARD
          message: cmd + " only allowed for CTB."
        function: getSignalName
        input:
        - args[0]
        input_types:
        - int
        output:
        - args[0]
        - ''' '''
        - t
        require_det_id: false
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        - std::string
        argc: 2
        cast_input:
        - true
        - false
        check_det_id: true
        convert_det_id: true
        exceptions:
        - condition: det->getDetectorType().squash(defs::GENERIC) != defs::CHIPTESTBOARD
            && det->getDetectorType().squash(defs::GENERIC) != defs::XILINX_CHIPTESTBOARD
          message: cmd + " only allowed for CTB."
        function: setSignalName
        input:
        - args[0]
        - args[1]
        input_types:
        - int
        - std::string
        output:
        - ToString(args)
        require_det_id: false
        store_result_in_t: false
  command_name: signalname
  function_alias: signalname
  help: "[0-63][name] \n\t\t[Ctb][Xilinx_Ctb] Set the signal at the given position\
    \ to the given name."
  infer_action: true
  template: true
sleep:
  actions:
    PUT:
      args:
      - arg_types:
        - int
        argc: 1
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: false
      - arg_types:
        - int
        - special::time_unit
        argc: 2
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: false
  command_name: sleep
  function_alias: sleep
  help: ''
  infer_action: true
  is_description: true
slowadc:
  actions:
    GET:
      args:
      - arg_types:
        - int
        argc: 1
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: true
  command_name: slowadc
  function_alias: slowadc
  help: ''
  infer_action: true
  is_description: true
slowadcindex:
  actions:
    GET:
      args:
      - arg_types:
        - std::string
        argc: 1
        cast_input:
        - false
        check_det_id: true
        convert_det_id: true
        exceptions:
        - condition: det->getDetectorType().squash(defs::GENERIC) != defs::CHIPTESTBOARD
            && det->getDetectorType().squash(defs::GENERIC) != defs::XILINX_CHIPTESTBOARD
          message: cmd + " only allowed for CTB."
        extra_variables:
        - name: index
          type: defs::dacIndex
          value: defs::SLOW_ADC0
        function: getSlowADCIndex
        input:
        - args[0]
        input_types:
        - std::string
        output:
        - ToString(static_cast<int>(t) - index)
        require_det_id: false
        store_result_in_t: true
  command_name: slowadcindex
  function_alias: slowadcindex
  help: "[name] \n\t\t[Ctb][Xilinx_Ctb] Get the slowadc index for the given name."
  infer_action: true
  template: true
slowadclist:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: true
        convert_det_id: true
        exceptions:
        - condition: cmd != "daclist" && det_type != defs::CHIPTESTBOARD && det_type
            != defs::XILINX_CHIPTESTBOARD
          message: cmd + " only allowed for CTB."
        extra_variables:
        - name: det_type
          type: auto
          value: det->getDetectorType().squash(defs::GENERIC);
        function: getSlowADCNames
        input: []
        input_types: []
        output:
        - ToString(t)
        require_det_id: false
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - std::string
        argc: -1
        cast_input:
        - false
        check_det_id: true
        convert_det_id: true
        exceptions:
        - condition: cmd != "daclist" && det_type != defs::CHIPTESTBOARD && det_type
            != defs::XILINX_CHIPTESTBOARD
          message: cmd + " only allowed for CTB."
        - condition: cmd == "daclist" && det_type != defs::CHIPTESTBOARD && det_type
            != defs::XILINX_CHIPTESTBOARD
          message: '"This detector already has fixed dac names. Cannot change them."'
        extra_variables:
        - name: det_type
          type: auto
          value: det->getDetectorType().squash(defs::GENERIC);
        function: setSlowADCNames
        input:
        - args
        input_types:
        - std::string
        output:
        - ToString(args)
        require_det_id: false
        store_result_in_t: false
  command_name: slowadclist
  function_alias: slowadclist
  help: "[slowadcname1 slowadcname2 .. slowadcname7] \n\t\t[Ctb][Xilinx_Ctb] Set the\
    \ list of slowadc names for this board."
  infer_action: true
  template: true
slowadcname:
  actions:
    GET:
      args:
      - arg_types:
        - defs::dacIndex
        argc: 1
        cast_input:
        - false
        check_det_id: true
        convert_det_id: true
        exceptions:
        - condition: det->getDetectorType().squash(defs::GENERIC) != defs::CHIPTESTBOARD
            && det->getDetectorType().squash(defs::GENERIC) != defs::XILINX_CHIPTESTBOARD
          message: cmd + " only allowed for CTB."
        extra_variables:
        - name: index
          type: defs::dacIndex
          value: defs::SLOW_ADC0
        function: getSlowADCName
        input:
        - static_cast<defs::dacIndex>(StringTo<int>(args[0]) + index)
        input_types:
        - defs::dacIndex
        output:
        - args[0]
        - ''' '''
        - t
        require_det_id: false
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - defs::dacIndex
        - std::string
        argc: 2
        cast_input:
        - false
        - false
        check_det_id: true
        convert_det_id: true
        exceptions:
        - condition: det->getDetectorType().squash(defs::GENERIC) != defs::CHIPTESTBOARD
            && det->getDetectorType().squash(defs::GENERIC) != defs::XILINX_CHIPTESTBOARD
          message: cmd + " only allowed for CTB."
        extra_variables:
        - name: index
          type: defs::dacIndex
          value: defs::SLOW_ADC0
        function: setSlowADCName
        input:
        - static_cast<defs::dacIndex>(StringTo<int>(args[0]) + index)
        - args[1]
        input_types:
        - defs::dacIndex
        - std::string
        output:
        - ToString(args)
        require_det_id: false
        store_result_in_t: false
  command_name: slowadcname
  function_alias: slowadcname
  help: "[0-7][name] \n\t\t[Ctb][Xilinx_Ctb] Set the slowadc at the given position\
    \ to the given name."
  infer_action: true
  template: true
slowadcvalues:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        ctb_output_list:
          GETFCN: getSlowADC
          GETFCNLIST: getSlowADCList
          GETFCNNAME: getSlowADCNames
          printable_name: '*name_it++'
          suffix: uV
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: true
  command_name: slowadcvalues
  function_alias: slowadcvalues
  help: "[name] \n\t\t[Ctb][Xilinx_Ctb] Get values of all slow adcs."
  infer_action: true
start:
  actions:
    PUT:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: startDetector
        input: []
        input_types: []
        output:
        - '"successful"'
        require_det_id: true
        store_result_in_t: false
  command_name: start
  function_alias: start
  help: "\n\tStarts detector acquisition. Status changes to RUNNING or WAITING and\
    \ automatically returns to idle at the end of acquisition. If the acquisition\
    \ was abruptly stopped, some detectors come back to STOPPED."
  infer_action: true
  template: true
status:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getDetectorStatus
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types: []
        argc: -1
        cast_input: []
        check_det_id: false
        convert_det_id: true
        exceptions:
        - condition: 'true'
          message: '"Cannot put. Did you mean to use command: \"start\" or \"stop\"?"'
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: false
  command_name: status
  function_alias: status
  help: "[running, error, transmitting, finished, waiting, idle]\n\tDetector status.\
    \ Goes to stop server."
  infer_action: true
stop:
  actions:
    PUT:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: stopDetector
        input: []
        input_types: []
        output:
        - '"successful"'
        require_det_id: true
        store_result_in_t: false
  command_name: stop
  function_alias: stop
  help: "\n\tAbort detector acquisition. Status changes to IDLE or STOPPED. Goes to\
    \ stop server."
  infer_action: true
  template: true
stopport:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getStopPort
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - uint16_t
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setStopPort
        input:
        - args[0]
        input_types:
        - uint16_t
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: stopport
  function_alias: stopport
  help: "[n]\n\tPort number of the stop server on detector for detector-client tcp\
    \ interface. Default is 1953. Normally unchanged."
  infer_action: true
  template: true
storagecell_delay:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getStorageCellDelay
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
      - arg_types:
        - special::time_unit
        argc: 1
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getStorageCellDelay
        input: []
        input_types: []
        output:
        - OutString(t , args[0])
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - std::string
        argc: 1
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: setStorageCellDelay
        input:
        - converted_time
        input_types:
        - time::ns
        output:
        - args[0]
        require_det_id: true
        separate_time_units:
          input: args[0]
          output:
          - converted_time
          - unit
        store_result_in_t: false
      - arg_types:
        - int
        - special::time_unit
        argc: 2
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        convert_to_time:
          input:
          - args[0]
          - args[1]
          output: converted_time
        function: setStorageCellDelay
        input:
        - converted_time
        input_types:
        - time::ns
        output:
        - args[0]
        - args[1]
        require_det_id: true
        store_result_in_t: false
  command_name: storagecell_delay
  function_alias: storagecell_delay
  help: "[duration (0-1638375 ns)] [(optional unit) ns|us|ms|s]\n\t[Jungfrau] Additional\
    \ time delay between 2 consecutive exposures in burst mode (resolution of 25ns).\
    \ Only applicable for chipv1.0. For advanced users only."
  infer_action: true
  template: true
storagecell_start:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getStorageCellStart
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setStorageCellStart
        input:
        - args[0]
        input_types:
        - int
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: storagecell_start
  function_alias: storagecell_start
  help: "[0-max]\n\t[Jungfrau] Storage cell that stores the first acquisition of the\
    \ series. max is 15 (default) for chipv1.0 and 3 (default) for chipv1.1. For advanced\
    \ users only."
  infer_action: true
  template: true
subdeadtime:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getSubDeadTime
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
      - arg_types:
        - special::time_unit
        argc: 1
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getSubDeadTime
        input: []
        input_types: []
        output:
        - OutString(t , args[0])
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - std::string
        argc: 1
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: setSubDeadTime
        input:
        - converted_time
        input_types:
        - time::ns
        output:
        - args[0]
        require_det_id: true
        separate_time_units:
          input: args[0]
          output:
          - converted_time
          - unit
        store_result_in_t: false
      - arg_types:
        - int
        - special::time_unit
        argc: 2
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        convert_to_time:
          input:
          - args[0]
          - args[1]
          output: converted_time
        function: setSubDeadTime
        input:
        - converted_time
        input_types:
        - time::ns
        output:
        - args[0]
        - args[1]
        require_det_id: true
        store_result_in_t: false
  command_name: subdeadtime
  function_alias: subdeadtime
  help: "[duration] [(optional unit) ns|us|ms|s]\n\t[Eiger] Dead time of EIGER subframes\
    \ in 32 bit mode. Subperiod = subexptime + subdeadtime."
  infer_action: true
  template: true
subexptime:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getSubExptime
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
      - arg_types:
        - special::time_unit
        argc: 1
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getSubExptime
        input: []
        input_types: []
        output:
        - OutString(t , args[0])
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - std::string
        argc: 1
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: setSubExptime
        input:
        - converted_time
        input_types:
        - time::ns
        output:
        - args[0]
        require_det_id: true
        separate_time_units:
          input: args[0]
          output:
          - converted_time
          - unit
        store_result_in_t: false
      - arg_types:
        - int
        - special::time_unit
        argc: 2
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        convert_to_time:
          input:
          - args[0]
          - args[1]
          output: converted_time
        function: setSubExptime
        input:
        - converted_time
        input_types:
        - time::ns
        output:
        - args[0]
        - args[1]
        require_det_id: true
        store_result_in_t: false
  command_name: subexptime
  function_alias: subexptime
  help: "[duration] [(optional unit) ns|us|ms|s]\n\t[Eiger] Exposure time of EIGER\
    \ subframes in 32 bit mode."
  infer_action: true
  template: true
sync:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getSynchronization
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - bool
        argc: 1
        cast_input:
        - true
        check_det_id: true
        convert_det_id: true
        function: setSynchronization
        input:
        - args[0]
        input_types:
        - bool
        output:
        - args.front()
        require_det_id: false
        store_result_in_t: false
  command_name: sync
  function_alias: sync
  help: "[0, 1]\n\t[Jungfrau][Moench] Enables or disables synchronization between\
    \ modules. Sync mode requires at least one master configured. Also requires flatband\
    \ cabling between master and slave with termination board."
  infer_action: true
  template: true
syncclk:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getSYNCClock
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
  command_name: syncclk
  function_alias: syncclk
  help: "[n_clk in MHz]\n\t[Ctb] Sync clock in MHz."
  infer_action: true
  template: true
temp_10ge:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: getTemperature
        input:
        - defs::TEMPERATURE_10GE
        input_types:
        - int
        output:
        - OutString(t)
        - "\" \xB0C\""
        require_det_id: true
        store_result_in_t: true
  command_name: temp_10ge
  function_alias: temp_10ge
  help: "[n_value]\n\t[Eiger]Temperature close to the 10GbE"
  infer_action: true
  template: true
temp_adc:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: getTemperature
        input:
        - defs::TEMPERATURE_ADC
        input_types:
        - int
        output:
        - OutString(t)
        - "\" \xB0C\""
        require_det_id: true
        store_result_in_t: true
  command_name: temp_adc
  function_alias: temp_adc
  help: "[n_value]\n\t[Jungfrau][Moench][Gotthard] ADC Temperature"
  infer_action: true
  template: true
temp_control:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getTemperatureControl
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - bool
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setTemperatureControl
        input:
        - args[0]
        input_types:
        - bool
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: temp_control
  function_alias: temp_control
  help: "[0, 1]\n\t[Jungfrau][Moench] Temperature control enable. Default is 0 (disabled).\
    \ If temperature crosses threshold temperature and temperature control is enabled,\
    \ power to chip will be switched off and temperature event occurs. To power on\
    \ chip again, temperature has to be less than threshold temperature and temperature\
    \ event has to be cleared."
  infer_action: true
  template: true
temp_dcdc:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: getTemperature
        input:
        - defs::TEMPERATURE_DCDC
        input_types:
        - int
        output:
        - OutString(t)
        - "\" \xB0C\""
        require_det_id: true
        store_result_in_t: true
  command_name: temp_dcdc
  function_alias: temp_dcdc
  help: "[n_value]\n\t[Eiger]Temperature close to the dc dc converter"
  infer_action: true
  template: true
temp_event:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getTemperatureEvent
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        argc: 1
        cast_input: []
        check_det_id: false
        convert_det_id: true
        exceptions:
        - condition: StringTo<int>(args[0]) != 0
          message: '"Unknown argument for temp event: ( " + args[0] + " ). Did you
            mean 0 to reset event?"'
        function: resetTemperatureEvent
        input: []
        input_types: []
        output:
        - '"cleared"'
        require_det_id: true
        store_result_in_t: false
  command_name: temp_event
  function_alias: temp_event
  help: "[0]\n\t[Jungfrau][Moench] 1, if a temperature event occured. To clear this\
    \ event, set it to 0.\n\tIf temperature crosses threshold temperature and temperature\
    \ control is enabled, power to chip will be switched off and temperature event\
    \ occurs. To power on chip again, temperature has to be less than threshold temperature\
    \ and temperature event has to be cleared."
  infer_action: true
temp_fpga:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: getTemperature
        input:
        - defs::TEMPERATURE_FPGA
        input_types:
        - int
        output:
        - OutString(t)
        - "\" \xB0C\""
        require_det_id: true
        store_result_in_t: true
  command_name: temp_fpga
  function_alias: temp_fpga
  help: "[n_value]\n\t[Eiger][Jungfrau][Moench][Gotthard][Mythen3][Gotthard2][Xilinx\
    \ CTB] FPGA Temperature"
  infer_action: true
  template: true
temp_fpgaext:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: getTemperature
        input:
        - defs::TEMPERATURE_FPGAEXT
        input_types:
        - int
        output:
        - OutString(t)
        - "\" \xB0C\""
        require_det_id: true
        store_result_in_t: true
  command_name: temp_fpgaext
  function_alias: temp_fpgaext
  help: "[n_value]\n\t[Eiger]Temperature close to the FPGA"
  infer_action: true
  template: true
temp_fpgafl:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: getTemperature
        input:
        - defs::TEMPERATURE_FPGA2
        input_types:
        - int
        output:
        - OutString(t)
        - "\" \xB0C\""
        require_det_id: true
        store_result_in_t: true
  command_name: temp_fpgafl
  function_alias: temp_fpgafl
  help: "[n_value]\n\t[Eiger]Temperature of the left front end board fpga."
  infer_action: true
  template: true
temp_fpgafr:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: getTemperature
        input:
        - defs::TEMPERATURE_FPGA3
        input_types:
        - int
        output:
        - OutString(t)
        - "\" \xB0C\""
        require_det_id: true
        store_result_in_t: true
  command_name: temp_fpgafr
  function_alias: temp_fpgafr
  help: "[n_value]\n\t[Eiger]Temperature of the right front end board fpga."
  infer_action: true
  template: true
temp_slowadc:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: getTemperature
        input:
        - defs::SLOW_ADC_TEMP
        input_types:
        - int
        output:
        - OutString(t)
        - "\" \xB0C\""
        require_det_id: true
        store_result_in_t: true
  command_name: temp_slowadc
  function_alias: temp_slowadc
  help: "[n_value]\n\t[Ctb]Temperature of the slow adc"
  infer_action: true
  template: true
temp_sodl:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: getTemperature
        input:
        - defs::TEMPERATURE_SODL
        input_types:
        - int
        output:
        - OutString(t)
        - "\" \xB0C\""
        require_det_id: true
        store_result_in_t: true
  command_name: temp_sodl
  function_alias: temp_sodl
  help: "[n_value]\n\t[Eiger]Temperature close to the left so-dimm memory"
  infer_action: true
  template: true
temp_sodr:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: getTemperature
        input:
        - defs::TEMPERATURE_SODR
        input_types:
        - int
        output:
        - OutString(t)
        - "\" \xB0C\""
        require_det_id: true
        store_result_in_t: true
  command_name: temp_sodr
  function_alias: temp_sodr
  help: "[n_value]\n\t[Eiger]Temperature close to the right so-dimm memory"
  infer_action: true
  template: true
temp_threshold:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getThresholdTemperature
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setThresholdTemperature
        input:
        - args[0]
        input_types:
        - int
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: temp_threshold
  function_alias: temp_threshold
  help: "[n_temp (in degrees)]\n\t[Jungfrau][Moench] Threshold temperature in degrees.\
    \ If temperature crosses threshold temperature and temperature control is enabled,\
    \ power to chip will be switched off and temperature event occurs. To power on\
    \ chip again, temperature has to be less than threshold temperature and temperature\
    \ event has to be cleared."
  infer_action: true
  template: true
templist:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getTemperatureList
        input: []
        input_types: []
        output:
        - ToString(t)
        require_det_id: false
        store_result_in_t: true
  command_name: templist
  function_alias: templist
  help: "\n\tList of temperature commands implemented for this detector."
  infer_action: true
  template: true
tempvalues:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        ctb_output_list:
          GETFCN: getTemperature
          GETFCNLIST: getTemperatureList
          GETFCNNAME: ''
          printable_name: '*it'
          suffix: "\xB0C"
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: true
  command_name: tempvalues
  function_alias: tempvalues
  help: "\n\tGets the values for every temperature for this detector."
  infer_action: true
tengiga:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getTenGiga
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - bool
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setTenGiga
        input:
        - args[0]
        input_types:
        - bool
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: tengiga
  function_alias: tengiga
  help: "[0, 1]\n\t[Eiger][Ctb][Mythen3] 10GbE Enable."
  infer_action: true
  template: true
threshold:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        argc: 1
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: false
      - arg_types:
        - int
        - defs::detectorSettings
        argc: 2
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: false
      - arg_types:
        - int
        - int
        - int
        argc: 3
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: false
      - arg_types:
        - int
        - int
        - int
        - defs::detectorSettings
        argc: 4
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: false
  command_name: threshold
  function_alias: threshold
  help: ''
  infer_action: true
  is_description: true
thresholdnotb:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        argc: 1
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: false
      - arg_types:
        - int
        - defs::detectorSettings
        argc: 2
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: false
      - arg_types:
        - int
        - int
        - int
        argc: 3
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: false
      - arg_types:
        - int
        - int
        - int
        - defs::detectorSettings
        argc: 4
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: false
  command_name: thresholdnotb
  duplicate_function: true
  function_alias: threshold
  help: ''
  infer_action: true
  is_description: true
timing:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getTimingMode
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - defs::timingMode
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setTimingMode
        input:
        - args[0]
        input_types:
        - defs::timingMode
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: timing
  function_alias: timing
  help: "[auto|trigger|gating|burst_trigger|trigger_gating]\n\tTiming Mode of detector.\n\
    \t[Jungfrau][Moench][Gotthard][Ctb][Gotthard2][Xilinx Ctb] [auto|trigger]\n\t\
    [Mythen3] [auto|trigger|gating|trigger_gating]\n\t[Eiger] [auto|trigger|gating|burst_trigger]"
  infer_action: true
  template: true
timing_info_decoder:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getTimingInfoDecoder
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - defs::timingInfoDecoder
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setTimingInfoDecoder
        input:
        - args[0]
        input_types:
        - defs::timingInfoDecoder
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: timing_info_decoder
  function_alias: timing_info_decoder
  help: "[swissfel|shine]\n\t[Jungfrau] Advanced Command and only for Swissfel and\
    \ Shine. Sets the bunch id or timing info decoder. Default is swissfel."
  infer_action: true
  template: true
timinglist:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getTimingModeList
        input: []
        input_types: []
        output:
        - ToString(t)
        require_det_id: false
        store_result_in_t: true
  command_name: timinglist
  function_alias: timinglist
  help: "\n\tGets the list of timing modes for this detector."
  infer_action: true
  template: true
timingsource:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getTimingSource
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - defs::timingSourceType
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setTimingSource
        input:
        - args[0]
        input_types:
        - defs::timingSourceType
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: timingsource
  function_alias: timingsource
  help: "[internal|external]\n\t[Gotthard2] Timing source. Internal is crystal and\
    \ external is system timing. Default is internal."
  infer_action: true
  template: true
top:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getTop
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - bool
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setTop
        input:
        - args[0]
        input_types:
        - bool
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: top
  function_alias: top
  help: "[0, 1]\n\t[Eiger] Sets half module to top (1), else bottom."
  infer_action: true
  template: true
transceiverenable:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getTransceiverEnableMask
        input: []
        input_types: []
        output:
        - OutStringHex(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - uint32_t
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setTransceiverEnableMask
        input:
        - args[0]
        input_types:
        - uint32_t
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: transceiverenable
  function_alias: transceiverenable
  help: "[bitmask]\n\t[Ctb][Xilinx Ctb] Transceiver Enable Mask. Enable for each 4\
    \ Transceiver channel."
  infer_action: true
  template: true
trigger:
  actions:
    PUT:
      args:
      - arg_types: []
        argc: 0
        cast_input:
        - false
        check_det_id: true
        convert_det_id: true
        extra_variables:
        - name: block
          type: bool
          value: 'false'
        function: sendSoftwareTrigger
        input:
        - block
        input_types:
        - bool
        output:
        - '"successful"'
        require_det_id: false
        store_result_in_t: false
  command_name: trigger
  function_alias: trigger
  help: "\n\t[Eiger][Mythen3][Jungfrau][Moench] Sends software trigger signal to detector"
  infer_action: true
  template: true
triggers:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getNumberOfTriggers
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int64_t
        argc: 1
        cast_input:
        - true
        check_det_id: true
        convert_det_id: true
        function: setNumberOfTriggers
        input:
        - args[0]
        input_types:
        - int64_t
        output:
        - args.front()
        require_det_id: false
        store_result_in_t: false
  command_name: triggers
  function_alias: triggers
  help: "[n_triggers]\n\tNumber of triggers per aquire. Set timing mode to use triggers."
  infer_action: true
  template: true
triggersl:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getNumberOfTriggersLeft
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
  command_name: triggersl
  function_alias: triggersl
  help: "\n\t[Gotthard][Jungfrau][Moench][Mythen3][Gotthard2][Ctb][Xilinx Ctb] Number\
    \ of triggers left in acquisition. Only when external trigger used."
  infer_action: true
  template: true
trimbits:
  actions:
    GET:
      args:
      - arg_types:
        - special::path
        argc: 1
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: saveTrimbits
        input:
        - args[0]
        input_types:
        - std::string
        output:
        - args[0]
        require_det_id: true
        store_result_in_t: false
    PUT:
      args:
      - arg_types:
        - special::path
        argc: 1
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: loadTrimbits
        input:
        - args[0]
        input_types:
        - std::string
        output:
        - args[0]
        require_det_id: true
        store_result_in_t: false
  command_name: trimbits
  function_alias: trimbits
  help: "[fname]\n\t[Eiger][Mythen3] Put will load the trimbit file to detector. If\
    \ no extension specified, serial number of each module is attached. Get will save\
    \ the trimbits from the detector to file with serial number added to file name."
  infer_action: true
trimen:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: true
    PUT:
      args:
      - arg_types: []
        argc: -1
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: false
  command_name: trimen
  function_alias: trimen
  help: ''
  infer_action: true
  is_description: true
trimval:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getAllTrimbits
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setAllTrimbits
        input:
        - args[0]
        input_types:
        - int
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: trimval
  function_alias: trimval
  help: "[n_trimval]\n\t[Eiger][Mythen3] All trimbits set to this value. Returns -1\
    \ if all trimbits are different values."
  infer_action: true
  template: true
tsamples:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getNumberOfTransceiverSamples
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setNumberOfTransceiverSamples
        input:
        - args[0]
        input_types:
        - int
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: tsamples
  function_alias: tsamples
  help: "[n_value]\n\t[Ctb][Xilinx Ctb] Number of transceiver samples expected."
  infer_action: true
  template: true
txdelay:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: true
        convert_det_id: true
        function: getTransmissionDelay
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: false
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        argc: 1
        cast_input:
        - true
        check_det_id: true
        convert_det_id: true
        function: setTransmissionDelay
        input:
        - args[0]
        input_types:
        - int
        output:
        - args.front()
        require_det_id: false
        store_result_in_t: false
  command_name: txdelay
  function_alias: txdelay
  help: "[n_delay]\n\t[Eiger][Jungfrau][Moench][Mythen3] Set transmission delay for\
    \ all modules in the detector using the step size provided.Sets up \n\t[Eiger]\
    \ txdelay_left to (2 * mod_index * n_delay), \n\t[Eiger] txdelay_right to ((2\
    \ * mod_index + 1) * n_delay) and \n\t[Eiger] txdelay_frame to (2 *num_modules\
    \ * n_delay)\n\t[Jungfrau][Moench][Mythen3] txdelay_frame to (num_modules * n_delay)\
    \ for every module."
  infer_action: true
txdelay_frame:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getTransmissionDelayFrame
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setTransmissionDelayFrame
        input:
        - args[0]
        input_types:
        - int
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: txdelay_frame
  function_alias: txdelay_frame
  help: "[n_delay]\n\t[Eiger][Jungfrau][Moench][Mythen3] Transmission delay of first\
    \ udp packet being streamed out of the module.\n\t[Jungfrau][Moench] [0-31] Each\
    \ value represents 1 ms\n\t[Eiger] Additional delay to txdelay_left and txdelay_right.\
    \ Each value represents 10ns. Typical value is 50000.\n\t[Mythen3] [0-16777215]\
    \ Each value represents 8 ns (125 MHz clock), max is 134 ms."
  infer_action: true
  template: true
txdelay_left:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getTransmissionDelayLeft
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setTransmissionDelayLeft
        input:
        - args[0]
        input_types:
        - int
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: txdelay_left
  function_alias: txdelay_left
  help: "[n_delay]\n\t[Eiger] Transmission delay of first packet in an image being\
    \ streamed out of the module's left UDP port. Each value represents 10ns. Typical\
    \ value is 50000."
  infer_action: true
  template: true
txdelay_right:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getTransmissionDelayRight
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setTransmissionDelayRight
        input:
        - args[0]
        input_types:
        - int
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: txdelay_right
  function_alias: txdelay_right
  help: "[n_delay]\n\t[Eiger] Transmission delay of first packet in an image being\
    \ streamed out of the module's right UDP port. Each value represents 10ns. Typical\
    \ value is 50000."
  infer_action: true
  template: true
type:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getDetectorType
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
  command_name: type
  function_alias: type
  help: "\n\tReturns detector type. Can be Eiger, Jungfrau, Gotthard, Moench, Mythen3,\
    \ Gotthard2, ChipTestBoard, Xilinx_ChipTestBoard"
  infer_action: true
  template: true
udp_cleardst:
  actions:
    PUT:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: clearUDPDestinations
        input: []
        input_types: []
        output:
        - '"successful"'
        require_det_id: true
        store_result_in_t: false
  command_name: udp_cleardst
  function_alias: udp_cleardst
  help: "\n\tClears udp destination details on the detector."
  infer_action: true
  template: true
udp_dstip:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - std::string
        argc: 1
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: false
  command_name: udp_dstip
  function_alias: udp_dstip
  help: ''
  infer_action: true
  is_description: true
udp_dstip2:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - std::string
        argc: 1
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: false
  command_name: udp_dstip2
  function_alias: udp_dstip2
  help: ''
  infer_action: true
  is_description: true
udp_dstlist:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        exceptions:
        - condition: det_id == -1
          message: '"Can execute udp_dstlist only at module level."'
        - condition: rx_id < 0 || rx_id >= MAX_UDP_DESTINATION
          message: '"Invalid receiver index " + std::to_string(rx_id) + " to set round
            robin entry."'
        function: getDestinationUDPList
        input:
        - rx_id
        input_types:
        - auto
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - std::string
        argc: -1
        cast_input:
        - false
        check_det_id: false
        convert_det_id: false
        exceptions:
        - condition: det_id == -1
          message: '"Can execute udp_dstlist only at module level."'
        - condition: rx_id < 0 || rx_id >= MAX_UDP_DESTINATION
          message: '"Invalid receiver index " + std::to_string(rx_id) + " to set round
            robin entry."'
        - condition: args.empty()
          message: '"udp_dstlist require at least one argument."'
        function: setDestinationUDPList
        input:
        - getUdpEntry()
        input_types:
        - auto
        output:
        - ToString(args)
        require_det_id: true
        store_result_in_t: false
  command_name: udp_dstlist
  function_alias: udp_dstlist
  help: "[ip=x.x.x.x] [(optional)ip2=x.x.x.x] \n\t\t[mac=xx:xx:xx:xx:xx:xx] [(optional)mac2=xx:xx:xx:xx:xx:xx]\n\
    \t\t[port=value] [(optional)port2=value]\n\t\tThe order of ip, mac and port does\
    \ not matter. entry_value can be >0 only for [Eiger][Jungfrau][Moench][Mythen3][Gotthard2]\
    \ where round robin is implemented. If 'auto' used, then ip is set to ip of rx_hostname."
  infer_action: true
udp_dstmac:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getDestinationUDPMAC
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - MacAddr
        argc: 1
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: setDestinationUDPMAC
        input:
        - MacAddr(args[0])
        input_types:
        - MacAddr
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: udp_dstmac
  function_alias: udp_dstmac
  help: "[x:x:x:x:x:x]\n\tMac address of the receiver (destination) udp interface.\
    \ Not mandatory to set as udp_dstip retrieves it from slsReceiver process, but\
    \ must be set if you use a custom receiver (not slsReceiver). Use router mac if\
    \ router between detector and receiver."
  infer_action: true
  template: true
udp_dstmac2:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getDestinationUDPMAC2
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - MacAddr
        argc: 1
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: setDestinationUDPMAC2
        input:
        - MacAddr(args[0])
        input_types:
        - MacAddr
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: udp_dstmac2
  function_alias: udp_dstmac2
  help: "[x:x:x:x:x:x]\n\t[Jungfrau][Moench] Mac address of the receiver (destination)\
    \ udp interface 2. Not mandatory to set as udp_dstip2 retrieves it from slsReceiver\
    \ process but must be set if you use a custom receiver (not slsReceiver). \n\t\
    \ [Jungfrau][Moench] top half or inner interface \n\t [Gotthard2] veto debugging.\
    \ Use router mac if router between detector and receiver."
  infer_action: true
  template: true
udp_dstport:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getDestinationUDPPort
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - uint16_t
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: false
        function: setDestinationUDPPort
        input:
        - args[0]
        input_types:
        - uint16_t
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: udp_dstport
  function_alias: udp_dstport
  help: "[n]\n\tPort number of the receiver (destination) udp interface. Default is\
    \ 50001. \n\tIf multi command, ports for each module is calculated (incremented\
    \ by 1 if no 2nd interface)"
  infer_action: true
  template: true
udp_dstport2:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getDestinationUDPPort2
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - uint16_t
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: false
        function: setDestinationUDPPort2
        input:
        - args[0]
        input_types:
        - uint16_t
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: udp_dstport2
  function_alias: udp_dstport2
  help: "[n]\n\t[Jungfrau][Moench][Eiger][Gotthard2] Port number of the receiver (destination)\
    \ udp interface 2. Default is 50002. \n\tIf multi command, ports for each module\
    \ is calculated (incremented by 2) \n\t[Jungfrau][Moench] top half or inner interface\
    \ \n\t[Eiger] right half \n\t[Gotthard2] veto debugging"
  infer_action: true
  template: true
udp_firstdst:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getFirstUDPDestination
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setFirstUDPDestination
        input:
        - args[0]
        input_types:
        - int
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: udp_firstdst
  function_alias: udp_firstdst
  help: "\n\t[0 - N]\n\twhere N is the max number of udp destinations - 1.\n\t[Jungfrau][Moench][Gotthard2]\
    \ Max number of udp destinations is 32.\n\t[Mythen3] Max number of udp destination\
    \ is 64.\n\t One can set which is the first destination that the detector will\
    \ stream images out from in a round robin fashion. The entry must not have been\
    \ empty. Default: 0"
  infer_action: true
  template: true
udp_numdst:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getNumberofUDPDestinations
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
  command_name: udp_numdst
  function_alias: udp_numdst
  help: "\n\t[Jungfrau][Moench][Eiger][Mythen3][Gotthard2] One can enter upto 32 (64\
    \ for Mythen3) destinations that the detector will stream images out in a round\
    \ robin fashion. This is get only command. Default: 1"
  infer_action: true
  template: true
udp_reconfigure:
  actions:
    PUT:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: reconfigureUDPDestination
        input: []
        input_types: []
        output:
        - '"successful"'
        require_det_id: true
        store_result_in_t: false
  command_name: udp_reconfigure
  function_alias: udp_reconfigure
  help: "\n\tReconfigures Detector with UDP destination. More for debugging as the\
    \ configuration is done automatically when the detector has sufficient UDP details."
  infer_action: true
  template: true
udp_srcip:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - std::string
        argc: 1
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: false
  command_name: udp_srcip
  function_alias: udp_srcip
  help: ''
  infer_action: true
  is_description: true
udp_srcip2:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - std::string
        argc: 1
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: false
  command_name: udp_srcip2
  function_alias: udp_srcip2
  help: ''
  infer_action: true
  is_description: true
udp_srcmac:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getSourceUDPMAC
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - MacAddr
        argc: 1
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: setSourceUDPMAC
        input:
        - MacAddr(args[0])
        input_types:
        - MacAddr
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: udp_srcmac
  function_alias: udp_srcmac
  help: "[x:x:x:x:x:x]\n\tMac address of the detector (source) udp interface. \n\t\
    [Eiger] Do not set as detector will replace with its own DHCP Mac (1G) or DHCP\
    \ Mac + 1 (10G)."
  infer_action: true
  template: true
udp_srcmac2:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getSourceUDPMAC2
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - MacAddr
        argc: 1
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: setSourceUDPMAC2
        input:
        - MacAddr(args[0])
        input_types:
        - MacAddr
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: udp_srcmac2
  function_alias: udp_srcmac2
  help: "[x:x:x:x:x:x]\n\t[Jungfrau][Moench] Mac address of the top half or inner\
    \ (source) udp interface. "
  infer_action: true
  template: true
udp_validate:
  actions:
    PUT:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: validateUDPConfiguration
        input: []
        input_types: []
        output:
        - '"successful"'
        require_det_id: true
        store_result_in_t: false
  command_name: udp_validate
  function_alias: udp_validate
  help: "\n\tValidates that UDP configuration in the detector is valid. If not configured,\
    \ it will throw with error message requesting missing udp information."
  infer_action: true
  template: true
update:
  actions:
    PUT:
      args:
      - arg_types:
        - special::path
        - special::path
        argc: 2
        cast_input:
        - false
        - false
        check_det_id: false
        convert_det_id: true
        exceptions:
        - condition: args[args.size() - 1].find(".pof") == std::string::npos && args[args.size()
            - 1].find(".rbf") == std::string::npos
          message: '"Programming file must be a pof/rbf file."'
        function: updateFirmwareAndServer
        input:
        - args[0]
        - args[1]
        input_types:
        - std::string
        - std::string
        output:
        - '"successful"'
        require_det_id: true
        store_result_in_t: false
  command_name: update
  function_alias: update
  help: "\n\tWithout tftp: [server_name (incl fullpath)] [fname.pof (incl full path)]\
    \ This does not use tftp.\n\t\t[Jungfrau][Moench][Gotthard][Ctb] Updates the firmware,\
    \ detector server, deletes old server, creates the symbolic link and then reboots\
    \ detector controller. \n\t\t[Mythen3][Gotthard2] will require a script to start\
    \ up the shorter named server link at start up. \n\t\tserver_name is full path\
    \ name of detector server binary\n\t\tfname is full path of programming file"
  infer_action: true
updatedetectorserver:
  actions:
    PUT:
      args:
      - arg_types:
        - special::path
        argc: 1
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: updateDetectorServer
        input:
        - args[0]
        input_types:
        - std::string
        output:
        - '"successful"'
        require_det_id: true
        store_result_in_t: false
  command_name: updatedetectorserver
  function_alias: updatedetectorserver
  help: "[server_name  with full path]\n\t[Jungfrau][Moench][Eiger][Ctb][Mythen3][Gotthard2]\
    \ Copies detector server via TCP (without tftp). Makes a symbolic link with a\
    \ shorter name (without vx.x.x). Then, detector controller reboots (except Eiger).\n\
    \t[Jungfrau][Moench][Ctb]Also changes respawn server to the link, which is effective\
    \ after a reboot."
  infer_action: true
updatekernel:
  actions:
    PUT:
      args:
      - arg_types:
        - special::path
        argc: 1
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: updateKernel
        input:
        - args[0]
        input_types:
        - std::string
        output:
        - '"successful"'
        require_det_id: true
        store_result_in_t: false
  command_name: updatekernel
  function_alias: updatekernel
  help: "[kernel_name with full path]\n\t[Jungfrau][Moench][Ctb][Mythen3][Gotthard2]\
    \ Advanced Command!! You could damage the detector. Please use with caution.\n\
    \tUpdates the kernel image. Then, detector controller reboots with new kernel."
  infer_action: true
updatemode:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getUpdateMode
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setUpdateMode
        input:
        - args[0]
        input_types:
        - int
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: updatemode
  function_alias: updatemode
  help: "[0|1]\n\tRestart the detector server in update mode or not. This is useful\
    \ when server-firmware compatibility is at its worst and server cannot start up\
    \ normally"
  infer_action: true
  template: true
user:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: true
        convert_det_id: true
        function: getUserDetails
        input: []
        input_types: []
        output:
        - t
        require_det_id: false
        store_result_in_t: true
  command_name: user
  function_alias: user
  help: "\n\tUser details from shared memory (hostname, type, PID, User, Date)."
  infer_action: true
v_a:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: getPower
        input:
        - defs::V_POWER_A
        input_types:
        - int
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        - int
        argc: 1
        cast_input:
        - false
        - true
        check_det_id: false
        convert_det_id: true
        function: setPower
        input:
        - defs::V_POWER_A
        - args[0]
        input_types:
        - int
        - int
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: v_a
  function_alias: v_a
  help: "[n_value]\n\t[Ctb][Xilinx Ctb] Power supply a in mV."
  infer_action: true
  template: true
v_b:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: getPower
        input:
        - defs::V_POWER_B
        input_types:
        - int
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        - int
        argc: 1
        cast_input:
        - false
        - true
        check_det_id: false
        convert_det_id: true
        function: setPower
        input:
        - defs::V_POWER_B
        - args[0]
        input_types:
        - int
        - int
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: v_b
  function_alias: v_b
  help: "[n_value]\n\t[Ctb][Xilinx Ctb] Power supply b in mV."
  infer_action: true
  template: true
v_c:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: getPower
        input:
        - defs::V_POWER_C
        input_types:
        - int
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        - int
        argc: 1
        cast_input:
        - false
        - true
        check_det_id: false
        convert_det_id: true
        function: setPower
        input:
        - defs::V_POWER_C
        - args[0]
        input_types:
        - int
        - int
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: v_c
  function_alias: v_c
  help: "[n_value]\n\t[Ctb][Xilinx Ctb] Power supply c in mV."
  infer_action: true
  template: true
v_chip:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: getPower
        input:
        - defs::V_POWER_CHIP
        input_types:
        - int
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        - int
        argc: 1
        cast_input:
        - false
        - true
        check_det_id: false
        convert_det_id: true
        function: setPower
        input:
        - defs::V_POWER_CHIP
        - args[0]
        input_types:
        - int
        - int
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: v_chip
  function_alias: v_chip
  help: "[n_value]\n\t[Ctb] Power supply chip in mV. Do not use it unless you are\
    \ completely sure you will not fry the board."
  infer_action: true
  template: true
v_d:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: getPower
        input:
        - defs::V_POWER_D
        input_types:
        - int
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        - int
        argc: 1
        cast_input:
        - false
        - true
        check_det_id: false
        convert_det_id: true
        function: setPower
        input:
        - defs::V_POWER_D
        - args[0]
        input_types:
        - int
        - int
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: v_d
  function_alias: v_d
  help: "[n_value]\n\t[Ctb][Xilinx Ctb] Power supply d in mV."
  infer_action: true
  template: true
v_io:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: getPower
        input:
        - defs::V_POWER_IO
        input_types:
        - int
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        - int
        argc: 1
        cast_input:
        - false
        - true
        check_det_id: false
        convert_det_id: true
        function: setPower
        input:
        - defs::V_POWER_IO
        - args[0]
        input_types:
        - int
        - int
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: v_io
  function_alias: v_io
  help: "[n_value]\n\t[Ctb][Xilinx Ctb] Power supply io in mV. Minimum 1200 mV. Must\
    \ be the first power regulator to be set after fpga reset (on-board detector server\
    \ start up)."
  infer_action: true
  template: true
v_limit:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: getPower
        input:
        - defs::V_LIMIT
        input_types:
        - int
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        - int
        argc: 1
        cast_input:
        - false
        - true
        check_det_id: false
        convert_det_id: true
        function: setPower
        input:
        - defs::V_LIMIT
        - args[0]
        input_types:
        - int
        - int
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: v_limit
  function_alias: v_limit
  help: "[n_value]\n\t[Ctb][Xilinx Ctb] Soft limit for power supplies (ctb only) and\
    \ DACS in mV."
  infer_action: true
  template: true
vchip_comp_adc:
  actions:
    GET:
      args:
      - arg_types:
        - int
        - int
        argc: 1
        cast_input:
        - false
        - true
        check_det_id: false
        convert_det_id: true
        function: getOnChipDAC
        input:
        - defs::VB_COMP_ADC
        - args[0]
        input_types:
        - int
        - int
        output:
        - args[0]
        - ''' '''
        - OutStringHex(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        - int
        - int
        argc: 2
        cast_input:
        - false
        - true
        - true
        check_det_id: false
        convert_det_id: true
        function: setOnChipDAC
        input:
        - defs::VB_COMP_ADC
        - args[0]
        - args[1]
        input_types:
        - int
        - int
        - int
        output:
        - args[0]
        - ''' '''
        - args[1]
        require_det_id: true
        store_result_in_t: false
  command_name: vchip_comp_adc
  function_alias: vchip_comp_adc
  help: "[chip index 0-9, -1 for all][10 bit hex value] \n\t[Gotthard2] On chip Dac\
    \ for comparator current of ADC."
  infer_action: true
  template: true
vchip_comp_fe:
  actions:
    GET:
      args:
      - arg_types:
        - int
        - int
        argc: 1
        cast_input:
        - false
        - true
        check_det_id: false
        convert_det_id: true
        function: getOnChipDAC
        input:
        - defs::VB_COMP_FE
        - args[0]
        input_types:
        - int
        - int
        output:
        - args[0]
        - ''' '''
        - OutStringHex(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        - int
        - int
        argc: 2
        cast_input:
        - false
        - true
        - true
        check_det_id: false
        convert_det_id: true
        function: setOnChipDAC
        input:
        - defs::VB_COMP_FE
        - args[0]
        - args[1]
        input_types:
        - int
        - int
        - int
        output:
        - args[0]
        - ''' '''
        - args[1]
        require_det_id: true
        store_result_in_t: false
  command_name: vchip_comp_fe
  function_alias: vchip_comp_fe
  help: "[chip index 0-9, -1 for all][10 bit hex value] \n\t[Gotthard2] On chip Dac\
    \ for comparator current of analogue front end."
  infer_action: true
  template: true
vchip_cs:
  actions:
    GET:
      args:
      - arg_types:
        - int
        - int
        argc: 1
        cast_input:
        - false
        - true
        check_det_id: false
        convert_det_id: true
        function: getOnChipDAC
        input:
        - defs::VB_CS
        - args[0]
        input_types:
        - int
        - int
        output:
        - args[0]
        - ''' '''
        - OutStringHex(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        - int
        - int
        argc: 2
        cast_input:
        - false
        - true
        - true
        check_det_id: false
        convert_det_id: true
        function: setOnChipDAC
        input:
        - defs::VB_CS
        - args[0]
        - args[1]
        input_types:
        - int
        - int
        - int
        output:
        - args[0]
        - ''' '''
        - args[1]
        require_det_id: true
        store_result_in_t: false
  command_name: vchip_cs
  function_alias: vchip_cs
  help: "[chip index 0-9, -1 for all][10 bit hex value] \n\t[Gotthard2] On chip Dac\
    \ for current injection into preamplifier."
  infer_action: true
  template: true
vchip_opa_1st:
  actions:
    GET:
      args:
      - arg_types:
        - int
        - int
        argc: 1
        cast_input:
        - false
        - true
        check_det_id: false
        convert_det_id: true
        function: getOnChipDAC
        input:
        - defs::VB_OPA_1ST
        - args[0]
        input_types:
        - int
        - int
        output:
        - args[0]
        - ''' '''
        - OutStringHex(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        - int
        - int
        argc: 2
        cast_input:
        - false
        - true
        - true
        check_det_id: false
        convert_det_id: true
        function: setOnChipDAC
        input:
        - defs::VB_OPA_1ST
        - args[0]
        - args[1]
        input_types:
        - int
        - int
        - int
        output:
        - args[0]
        - ''' '''
        - args[1]
        require_det_id: true
        store_result_in_t: false
  command_name: vchip_opa_1st
  function_alias: vchip_opa_1st
  help: "[chip index 0-9, -1 for all][10 bit hex value] \n\t[Gotthard2] On chip Dac\
    \ for opa current for driving the other DACs in chip."
  infer_action: true
  template: true
vchip_opa_fd:
  actions:
    GET:
      args:
      - arg_types:
        - int
        - int
        argc: 1
        cast_input:
        - false
        - true
        check_det_id: false
        convert_det_id: true
        function: getOnChipDAC
        input:
        - defs::VB_OPA_FD
        - args[0]
        input_types:
        - int
        - int
        output:
        - args[0]
        - ''' '''
        - OutStringHex(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        - int
        - int
        argc: 2
        cast_input:
        - false
        - true
        - true
        check_det_id: false
        convert_det_id: true
        function: setOnChipDAC
        input:
        - defs::VB_OPA_FD
        - args[0]
        - args[1]
        input_types:
        - int
        - int
        - int
        output:
        - args[0]
        - ''' '''
        - args[1]
        require_det_id: true
        store_result_in_t: false
  command_name: vchip_opa_fd
  function_alias: vchip_opa_fd
  help: "[chip index 0-9, -1 for all][10 bit hex value] \n\t[Gotthard2] On chip Dac\
    \ current for CDS opa stage."
  infer_action: true
  template: true
vchip_ref_comp_fe:
  actions:
    GET:
      args:
      - arg_types:
        - int
        - int
        argc: 1
        cast_input:
        - false
        - true
        check_det_id: false
        convert_det_id: true
        function: getOnChipDAC
        input:
        - defs::VREF_COMP_FE
        - args[0]
        input_types:
        - int
        - int
        output:
        - args[0]
        - ''' '''
        - OutStringHex(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        - int
        - int
        argc: 2
        cast_input:
        - false
        - true
        - true
        check_det_id: false
        convert_det_id: true
        function: setOnChipDAC
        input:
        - defs::VREF_COMP_FE
        - args[0]
        - args[1]
        input_types:
        - int
        - int
        - int
        output:
        - args[0]
        - ''' '''
        - args[1]
        require_det_id: true
        store_result_in_t: false
  command_name: vchip_ref_comp_fe
  function_alias: vchip_ref_comp_fe
  help: "[chip index 0-9, -1 for all][10 bit hex value] \n\t[Gotthard2] On chip Dac\
    \ for reference voltage of the comparator of analogue front end."
  infer_action: true
  template: true
versions:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: true
  command_name: versions
  function_alias: versions
  help: ''
  infer_action: true
  is_description: true
veto:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getVeto
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - bool
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setVeto
        input:
        - args[0]
        input_types:
        - bool
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: veto
  function_alias: veto
  help: "[0, 1]\n\t[Gotthard2] Enable or disable veto data data from chip. Default\
    \ is 0."
  infer_action: true
  template: true
vetoalg:
  actions:
    GET:
      args:
      - arg_types:
        - defs::streamingInterface
        argc: 1
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        exceptions:
        - condition: interface == defs::streamingInterface::NONE
          message: '"Must specify an interface to set algorithm"'
        extra_variables:
        - name: interface
          type: defs::streamingInterface
          value: StringTo<defs::streamingInterface>(args[0])
        function: getVetoAlgorithm
        input:
        - interface
        input_types:
        - defs::streamingInterface
        output:
        - OutString(t)
        - ''' '''
        - ToString(interface)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - defs::vetoAlgorithm
        - defs::streamingInterface
        argc: 2
        cast_input:
        - false
        - false
        check_det_id: false
        convert_det_id: true
        exceptions:
        - condition: interface == defs::streamingInterface::NONE
          message: '"Must specify an interface to set algorithm"'
        extra_variables:
        - name: alg
          type: defs::vetoAlgorithm
          value: StringTo<defs::vetoAlgorithm>(args[0])
        - name: interface
          type: defs::streamingInterface
          value: StringTo<defs::streamingInterface>(args[1])
        function: setVetoAlgorithm
        input:
        - alg
        - interface
        input_types:
        - defs::vetoAlgorithm
        - defs::streamingInterface
        output:
        - ToString(alg)
        - ''' '''
        - ToString(interface)
        require_det_id: true
        store_result_in_t: false
  command_name: vetoalg
  function_alias: vetoalg
  help: "[hits|raw] [lll|10gbe]\n\t[Gotthard2] Set the veto algorithm. Default is\
    \ hits."
  infer_action: true
vetofile:
  actions:
    GET:
      args:
      - arg_types: []
        argc: -1
        cast_input: []
        check_det_id: false
        convert_det_id: true
        exceptions:
        - condition: 'true'
          message: '"Cannot get vetofile. Did you mean vetophoton?"'
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        - std::string
        argc: 2
        cast_input:
        - true
        - false
        check_det_id: false
        convert_det_id: true
        function: setVetoFile
        input:
        - args[0]
        - args[1]
        input_types:
        - int
        - std::string
        output:
        - ToString(args)
        require_det_id: true
        store_result_in_t: false
  command_name: vetofile
  function_alias: vetofile
  help: "[chip index 0-9, -1 for all] [file name] \n\t[Gotthard2] Set veto reference\
    \ for each 128 channels for specific chip. The file should have 128 rows of gain\
    \ index and 12 bit value in dec"
  infer_action: true
vetophoton:
  actions:
    GET:
      args:
      - arg_types:
        - int
        - std::string
        argc: 2
        cast_input:
        - true
        - false
        check_det_id: false
        convert_det_id: true
        function: getVetoPhoton
        input:
        - args[0]
        - args[1]
        input_types:
        - int
        - std::string
        output:
        - '"saved to file "'
        - args[1]
        require_det_id: true
        store_result_in_t: false
    PUT:
      args:
      - arg_types:
        - int
        - int
        - int
        - std::string
        argc: 4
        cast_input:
        - true
        - true
        - true
        - false
        check_det_id: false
        convert_det_id: true
        function: setVetoPhoton
        input:
        - args[0]
        - args[1]
        - args[2]
        - args[3]
        input_types:
        - int
        - int
        - int
        - std::string
        output:
        - ToString(args)
        require_det_id: true
        store_result_in_t: false
  command_name: vetophoton
  function_alias: vetophoton
  help: "[ichip] [#photons] [energy in keV] [reference file]\n\t[Gotthard2] Set veto\
    \ reference for 128 channels for chip ichip according to reference file and #photons\
    \ and energy in keV.\n\t[ichip] [output file]\n\t Get gain indices and veto reference\
    \ for 128 channels for chip ichip, saved to file."
  infer_action: true
vetoref:
  actions:
    GET:
      args:
      - arg_types: []
        argc: -1
        cast_input: []
        check_det_id: false
        convert_det_id: true
        exceptions:
        - condition: 'true'
          message: '"Cannot get vetoref. Did you mean vetophoton?"'
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        - int
        argc: 2
        cast_input:
        - true
        - true
        check_det_id: false
        convert_det_id: true
        function: setVetoReference
        input:
        - args[0]
        - args[1]
        input_types:
        - int
        - int
        output:
        - ToString(args)
        require_det_id: false
        store_result_in_t: false
  command_name: vetoref
  function_alias: vetoref
  help: "[gain index] [12 bit value]\n\t[Gotthard2] Set veto reference for all 128\
    \ channels for all chips."
  infer_action: true
vetostream:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: true
    PUT:
      args:
      - arg_types: []
        argc: -1
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: ''
        input: []
        input_types: []
        output: []
        require_det_id: false
        store_result_in_t: false
  command_name: vetostream
  function_alias: vetostream
  help: ''
  infer_action: true
  is_description: true
virtual:
  actions:
    PUT:
      args:
      - arg_types:
        - int
        - uint16_t
        argc: 2
        cast_input:
        - true
        - true
        check_det_id: true
        convert_det_id: true
        function: setVirtualDetectorServers
        input:
        - args[0]
        - args[1]
        input_types:
        - int
        - uint16_t
        output:
        - ToString(args)
        require_det_id: false
        store_result_in_t: false
  command_name: virtual
  function_alias: virtualFunction
  help: "[n_servers] [starting_port_number]\n\tConnecs to n virtual server at local\
    \ host starting at specific control port. Every virtual server will have a stop\
    \ port (control port + 1)"
  infer_action: true
vm_a:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: getMeasuredPower
        input:
        - defs::V_POWER_A
        input_types:
        - int
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
  command_name: vm_a
  function_alias: vm_a
  help: "\n\t[Ctb] Measured voltage of power supply a in mV."
  infer_action: true
  template: true
vm_b:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: getMeasuredPower
        input:
        - defs::V_POWER_B
        input_types:
        - int
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
  command_name: vm_b
  function_alias: vm_b
  help: "\n\t[Ctb] Measured voltage of power supply b in mV."
  infer_action: true
  template: true
vm_c:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: getMeasuredPower
        input:
        - defs::V_POWER_C
        input_types:
        - int
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
  command_name: vm_c
  function_alias: vm_c
  help: "\n\t[Ctb] Measured voltage of power supply c in mV."
  infer_action: true
  template: true
vm_d:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: getMeasuredPower
        input:
        - defs::V_POWER_D
        input_types:
        - int
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
  command_name: vm_d
  function_alias: vm_d
  help: "\n\t[Ctb] Measured voltage of power supply d in mV."
  infer_action: true
  template: true
vm_io:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: getMeasuredPower
        input:
        - defs::V_POWER_IO
        input_types:
        - int
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
  command_name: vm_io
  function_alias: vm_io
  help: "\n\t[Ctb] Measured voltage of power supply io in mV."
  infer_action: true
  template: true
zmqhwm:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getClientZmqHwm
        input: []
        input_types: []
        output:
        - t
        require_det_id: false
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - int
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: true
        function: setClientZmqHwm
        input:
        - args[0]
        input_types:
        - int
        output:
        - det->getClientZmqHwm()
        require_det_id: false
        store_result_in_t: false
  command_name: zmqhwm
  function_alias: zmqhwm
  help: "[n_limit] \n\tClient's zmq receive high water mark. Default is the zmq library's\
    \ default (1000), can also be set here using -1. \n\tThis is a high number and\
    \ can be set to 2 for gui purposes. \n\tOne must also set the receiver's send\
    \ high water mark to similar value. Final effect is sum of them.\n\t Setting it\
    \ via command line is useful only before zmq enabled (before opening gui)."
  infer_action: true
zmqip:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getClientZmqIp
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - IpAddr
        argc: 1
        cast_input:
        - false
        check_det_id: false
        convert_det_id: true
        function: setClientZmqIp
        input:
        - IpAddr(args[0])
        input_types:
        - IpAddr
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: zmqip
  function_alias: zmqip
  help: "[x.x.x.x]\n\tIp Address to listen to zmq data streamed out from receiver\
    \ or intermediate process. Default connects to receiver zmq Ip Address (from rx_hostname).\
    \ Modified only when using an intermediate process between receiver and client(gui).\
    \ Also restarts client zmq streaming if enabled."
  infer_action: true
  template: true
zmqport:
  actions:
    GET:
      args:
      - arg_types: []
        argc: 0
        cast_input: []
        check_det_id: false
        convert_det_id: true
        function: getClientZmqPort
        input: []
        input_types: []
        output:
        - OutString(t)
        require_det_id: true
        store_result_in_t: true
    PUT:
      args:
      - arg_types:
        - uint16_t
        argc: 1
        cast_input:
        - true
        check_det_id: false
        convert_det_id: false
        function: setClientZmqPort
        input:
        - args[0]
        input_types:
        - uint16_t
        output:
        - args.front()
        require_det_id: true
        store_result_in_t: false
  command_name: zmqport
  function_alias: zmqport
  help: "[port]\n\tZmq port in client(gui) or intermediate process for data to be\
    \ streamed to from receiver. Default connects to receiver zmq streaming out port\
    \ (30001). Modified only when using an intermediate process between receiver and\
    \ client(gui). Also restarts client zmq streaming if enabled. Must be different\
    \ for every detector (and udp port). Multi command will automatically increment\
    \ for individual modules."
  infer_action: true
  template: true
